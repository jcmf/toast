head	1.488;
access;
symbols;
locks
	zaphod:1.488; strict;
comment	@# @;


1.488
date	2016.02.29.00.13.45;	author zaphod;	state Exp;
branches;
next	1.487;

1.487
date	2016.01.27.07.55.09;	author zaphod;	state Exp;
branches;
next	1.486;

1.486
date	2012.07.15.18.40.38;	author zaphod;	state Exp;
branches;
next	1.485;

1.485
date	2012.07.13.06.19.37;	author zaphod;	state Exp;
branches;
next	1.484;

1.484
date	2011.09.21.03.09.40;	author zaphod;	state Exp;
branches;
next	1.483;

1.483
date	2011.09.21.02.58.56;	author zaphod;	state Exp;
branches;
next	1.482;

1.482
date	2011.09.14.00.31.57;	author zaphod;	state Exp;
branches;
next	1.481;

1.481
date	2011.09.02.00.55.44;	author zaphod;	state Exp;
branches;
next	1.480;

1.480
date	2010.04.04.18.22.09;	author zaphod;	state Exp;
branches;
next	1.479;

1.479
date	2010.03.02.05.27.56;	author zaphod;	state Exp;
branches;
next	1.478;

1.478
date	2010.01.14.04.31.03;	author zaphod;	state Exp;
branches;
next	1.477;

1.477
date	2010.01.13.04.24.48;	author zaphod;	state Exp;
branches;
next	1.476;

1.476
date	2010.01.11.03.41.49;	author zaphod;	state Exp;
branches;
next	1.475;

1.475
date	2010.01.11.03.29.06;	author zaphod;	state Exp;
branches;
next	1.474;

1.474
date	2010.01.10.22.05.51;	author zaphod;	state Exp;
branches;
next	1.473;

1.473
date	2010.01.10.02.43.08;	author zaphod;	state Exp;
branches;
next	1.472;

1.472
date	2010.01.10.02.14.39;	author zaphod;	state Exp;
branches;
next	1.471;

1.471
date	2010.01.08.04.37.48;	author zaphod;	state Exp;
branches;
next	1.470;

1.470
date	2010.01.08.04.34.47;	author zaphod;	state Exp;
branches;
next	1.469;

1.469
date	2009.11.21.22.19.58;	author zaphod;	state Exp;
branches;
next	1.468;

1.468
date	2009.11.21.22.18.42;	author zaphod;	state Exp;
branches;
next	1.467;

1.467
date	2009.10.07.00.15.32;	author zaphod;	state Exp;
branches;
next	1.466;

1.466
date	2009.05.08.22.29.30;	author zaphod;	state Exp;
branches;
next	1.465;

1.465
date	2009.03.29.22.48.35;	author zaphod;	state Exp;
branches;
next	1.464;

1.464
date	2009.03.20.06.05.00;	author zaphod;	state Exp;
branches;
next	1.463;

1.463
date	2009.03.20.04.54.13;	author zaphod;	state Exp;
branches;
next	1.462;

1.462
date	2009.03.20.01.21.35;	author zaphod;	state Exp;
branches;
next	1.461;

1.461
date	2009.03.20.01.18.10;	author zaphod;	state Exp;
branches;
next	1.460;

1.460
date	2008.08.22.18.38.56;	author zaphod;	state Exp;
branches;
next	1.459;

1.459
date	2008.05.28.22.31.51;	author zaphod;	state Exp;
branches;
next	1.458;

1.458
date	2008.05.08.23.20.31;	author zaphod;	state Exp;
branches;
next	1.457;

1.457
date	2008.05.07.05.21.00;	author zaphod;	state Exp;
branches;
next	1.456;

1.456
date	2008.05.02.02.24.10;	author zaphod;	state Exp;
branches;
next	1.455;

1.455
date	2008.04.09.21.14.06;	author zaphod;	state Exp;
branches;
next	1.454;

1.454
date	2008.04.07.00.24.26;	author zaphod;	state Exp;
branches;
next	1.453;

1.453
date	2008.03.31.19.14.18;	author zaphod;	state Exp;
branches;
next	1.452;

1.452
date	2008.03.20.01.29.53;	author zaphod;	state Exp;
branches;
next	1.451;

1.451
date	2008.03.16.05.23.06;	author zaphod;	state Exp;
branches;
next	1.450;

1.450
date	2008.03.14.00.18.26;	author zaphod;	state Exp;
branches;
next	1.449;

1.449
date	2008.03.13.23.58.52;	author zaphod;	state Exp;
branches;
next	1.448;

1.448
date	2008.03.13.22.20.25;	author zaphod;	state Exp;
branches;
next	1.447;

1.447
date	2008.03.13.22.04.18;	author zaphod;	state Exp;
branches;
next	1.446;

1.446
date	2008.03.10.22.16.03;	author zaphod;	state Exp;
branches;
next	1.445;

1.445
date	2007.09.11.23.06.00;	author zaphod;	state Exp;
branches;
next	1.444;

1.444
date	2007.08.21.21.18.45;	author zaphod;	state Exp;
branches;
next	1.443;

1.443
date	2007.07.08.21.53.25;	author zaphod;	state Exp;
branches;
next	1.442;

1.442
date	2007.07.01.20.50.29;	author zaphod;	state Exp;
branches;
next	1.441;

1.441
date	2007.06.04.23.32.59;	author zaphod;	state Exp;
branches;
next	1.440;

1.440
date	2006.12.29.22.47.10;	author zaphod;	state Exp;
branches;
next	1.439;

1.439
date	2006.12.14.04.25.03;	author zaphod;	state Exp;
branches;
next	1.438;

1.438
date	2006.12.14.02.02.42;	author zaphod;	state Exp;
branches;
next	1.437;

1.437
date	2006.12.14.00.28.02;	author zaphod;	state Exp;
branches;
next	1.436;

1.436
date	2006.12.13.23.52.54;	author zaphod;	state Exp;
branches;
next	1.435;

1.435
date	2006.12.12.02.31.42;	author zaphod;	state Exp;
branches;
next	1.434;

1.434
date	2006.12.12.00.48.19;	author zaphod;	state Exp;
branches;
next	1.433;

1.433
date	2005.12.11.23.38.18;	author zaphod;	state Exp;
branches;
next	1.432;

1.432
date	2005.11.27.07.01.15;	author zaphod;	state Exp;
branches;
next	1.431;

1.431
date	2005.11.27.05.47.57;	author zaphod;	state Exp;
branches;
next	1.430;

1.430
date	2005.11.25.00.08.46;	author zaphod;	state Exp;
branches;
next	1.429;

1.429
date	2005.11.16.05.59.52;	author zaphod;	state Exp;
branches;
next	1.428;

1.428
date	2005.11.16.05.54.00;	author zaphod;	state Exp;
branches;
next	1.427;

1.427
date	2005.11.13.02.06.37;	author zaphod;	state Exp;
branches;
next	1.426;

1.426
date	2005.11.11.05.56.39;	author zaphod;	state Exp;
branches;
next	1.425;

1.425
date	2005.11.11.05.37.16;	author zaphod;	state Exp;
branches;
next	1.424;

1.424
date	2005.10.23.03.42.07;	author zaphod;	state Exp;
branches;
next	1.423;

1.423
date	2005.10.23.00.16.02;	author zaphod;	state Exp;
branches;
next	1.422;

1.422
date	2005.10.22.06.46.29;	author zaphod;	state Exp;
branches;
next	1.421;

1.421
date	2005.10.13.04.43.43;	author zaphod;	state Exp;
branches;
next	1.420;

1.420
date	2005.10.05.01.57.13;	author zaphod;	state Exp;
branches;
next	1.419;

1.419
date	2005.10.04.06.38.31;	author zaphod;	state Exp;
branches;
next	1.418;

1.418
date	2005.10.04.05.27.12;	author zaphod;	state Exp;
branches;
next	1.417;

1.417
date	2005.10.03.05.48.05;	author zaphod;	state Exp;
branches;
next	1.416;

1.416
date	2005.10.03.03.43.54;	author zaphod;	state Exp;
branches;
next	1.415;

1.415
date	2005.10.02.22.46.37;	author zaphod;	state Exp;
branches;
next	1.414;

1.414
date	2005.10.02.22.20.31;	author zaphod;	state Exp;
branches;
next	1.413;

1.413
date	2005.10.01.23.38.57;	author zaphod;	state Exp;
branches;
next	1.412;

1.412
date	2005.09.30.06.10.35;	author zaphod;	state Exp;
branches;
next	1.411;

1.411
date	2005.09.23.05.22.07;	author zaphod;	state Exp;
branches;
next	1.410;

1.410
date	2005.09.20.00.25.13;	author zaphod;	state Exp;
branches;
next	1.409;

1.409
date	2005.09.19.04.47.38;	author zaphod;	state Exp;
branches;
next	1.408;

1.408
date	2005.09.17.06.28.18;	author zaphod;	state Exp;
branches;
next	1.407;

1.407
date	2005.09.15.01.50.14;	author zaphod;	state Exp;
branches;
next	1.406;

1.406
date	2005.09.13.06.34.41;	author zaphod;	state Exp;
branches;
next	1.405;

1.405
date	2005.09.13.06.21.19;	author zaphod;	state Exp;
branches;
next	1.404;

1.404
date	2005.09.12.04.08.07;	author zaphod;	state Exp;
branches;
next	1.403;

1.403
date	2005.09.09.20.37.45;	author zaphod;	state Exp;
branches;
next	1.402;

1.402
date	2005.09.08.05.22.05;	author zaphod;	state Exp;
branches;
next	1.401;

1.401
date	2005.09.08.04.39.31;	author zaphod;	state Exp;
branches;
next	1.400;

1.400
date	2005.09.07.05.47.57;	author zaphod;	state Exp;
branches;
next	1.399;

1.399
date	2005.09.06.06.42.44;	author zaphod;	state Exp;
branches;
next	1.398;

1.398
date	2005.09.06.03.40.29;	author zaphod;	state Exp;
branches;
next	1.397;

1.397
date	2005.09.06.00.10.01;	author zaphod;	state Exp;
branches;
next	1.396;

1.396
date	2005.09.05.22.29.42;	author zaphod;	state Exp;
branches;
next	1.395;

1.395
date	2005.09.05.00.36.12;	author zaphod;	state Exp;
branches;
next	1.394;

1.394
date	2005.09.04.20.20.54;	author zaphod;	state Exp;
branches;
next	1.393;

1.393
date	2005.08.29.04.50.38;	author zaphod;	state Exp;
branches;
next	1.392;

1.392
date	2005.08.27.23.19.24;	author zaphod;	state Exp;
branches;
next	1.391;

1.391
date	2005.08.27.22.34.13;	author zaphod;	state Exp;
branches;
next	1.390;

1.390
date	2005.08.26.05.25.13;	author zaphod;	state Exp;
branches;
next	1.389;

1.389
date	2005.08.26.05.17.36;	author zaphod;	state Exp;
branches;
next	1.388;

1.388
date	2005.07.24.18.37.09;	author zaphod;	state Exp;
branches;
next	1.387;

1.387
date	2005.07.18.03.00.47;	author zaphod;	state Exp;
branches;
next	1.386;

1.386
date	2005.07.06.06.15.57;	author zaphod;	state Exp;
branches;
next	1.385;

1.385
date	2005.07.04.22.35.35;	author zaphod;	state Exp;
branches;
next	1.384;

1.384
date	2005.07.04.19.05.50;	author zaphod;	state Exp;
branches;
next	1.383;

1.383
date	2005.07.04.18.46.27;	author zaphod;	state Exp;
branches;
next	1.382;

1.382
date	2005.06.24.03.48.28;	author zaphod;	state Exp;
branches;
next	1.381;

1.381
date	2005.06.10.23.01.35;	author zaphod;	state Exp;
branches;
next	1.380;

1.380
date	2005.05.17.05.04.31;	author zaphod;	state Exp;
branches;
next	1.379;

1.379
date	2005.05.12.06.05.10;	author zaphod;	state Exp;
branches;
next	1.378;

1.378
date	2005.05.10.23.50.50;	author zaphod;	state Exp;
branches;
next	1.377;

1.377
date	2005.05.04.04.30.03;	author zaphod;	state Exp;
branches;
next	1.376;

1.376
date	2005.04.10.17.50.03;	author zaphod;	state Exp;
branches;
next	1.375;

1.375
date	2005.03.17.03.31.38;	author zaphod;	state Exp;
branches;
next	1.374;

1.374
date	2005.03.07.00.32.13;	author zaphod;	state Exp;
branches;
next	1.373;

1.373
date	2005.01.17.04.46.17;	author zaphod;	state Exp;
branches;
next	1.372;

1.372
date	2005.01.16.18.48.22;	author zaphod;	state Exp;
branches;
next	1.371;

1.371
date	2004.12.27.03.25.41;	author zaphod;	state Exp;
branches;
next	1.370;

1.370
date	2004.12.26.19.49.27;	author zaphod;	state Exp;
branches;
next	1.369;

1.369
date	2004.12.26.07.01.02;	author zaphod;	state Exp;
branches;
next	1.368;

1.368
date	2004.12.19.04.49.55;	author zaphod;	state Exp;
branches;
next	1.367;

1.367
date	2004.12.19.04.40.00;	author zaphod;	state Exp;
branches;
next	1.366;

1.366
date	2004.12.06.04.34.01;	author zaphod;	state Exp;
branches;
next	1.365;

1.365
date	2004.12.06.00.34.43;	author zaphod;	state Exp;
branches;
next	1.364;

1.364
date	2004.12.05.23.42.41;	author zaphod;	state Exp;
branches;
next	1.363;

1.363
date	2004.12.05.06.45.04;	author zaphod;	state Exp;
branches;
next	1.362;

1.362
date	2004.12.02.06.28.30;	author zaphod;	state Exp;
branches;
next	1.361;

1.361
date	2004.11.08.05.01.07;	author zaphod;	state Exp;
branches;
next	1.360;

1.360
date	2004.11.07.06.25.00;	author zaphod;	state Exp;
branches;
next	1.359;

1.359
date	2004.11.07.05.38.21;	author zaphod;	state Exp;
branches;
next	1.358;

1.358
date	2004.11.07.05.15.03;	author zaphod;	state Exp;
branches;
next	1.357;

1.357
date	2004.10.30.05.59.20;	author zaphod;	state Exp;
branches;
next	1.356;

1.356
date	2004.10.28.05.18.16;	author zaphod;	state Exp;
branches;
next	1.355;

1.355
date	2004.10.11.06.21.36;	author zaphod;	state Exp;
branches;
next	1.354;

1.354
date	2004.10.04.05.16.04;	author zaphod;	state Exp;
branches;
next	1.353;

1.353
date	2004.10.03.04.03.07;	author zaphod;	state Exp;
branches;
next	1.352;

1.352
date	2004.10.02.22.58.58;	author zaphod;	state Exp;
branches;
next	1.351;

1.351
date	2004.10.01.04.51.30;	author zaphod;	state Exp;
branches;
next	1.350;

1.350
date	2004.09.28.05.55.31;	author zaphod;	state Exp;
branches;
next	1.349;

1.349
date	2004.09.27.03.32.38;	author zaphod;	state Exp;
branches;
next	1.348;

1.348
date	2004.09.26.22.09.23;	author zaphod;	state Exp;
branches;
next	1.347;

1.347
date	2004.09.26.05.40.25;	author zaphod;	state Exp;
branches;
next	1.346;

1.346
date	2004.09.25.23.55.10;	author zaphod;	state Exp;
branches;
next	1.345;

1.345
date	2004.09.22.04.27.51;	author zaphod;	state Exp;
branches;
next	1.344;

1.344
date	2004.09.19.01.29.00;	author zaphod;	state Exp;
branches;
next	1.343;

1.343
date	2004.09.18.21.33.36;	author zaphod;	state Exp;
branches;
next	1.342;

1.342
date	2004.09.05.22.03.00;	author zaphod;	state Exp;
branches;
next	1.341;

1.341
date	2004.09.05.01.54.59;	author zaphod;	state Exp;
branches;
next	1.340;

1.340
date	2004.09.05.01.03.40;	author zaphod;	state Exp;
branches;
next	1.339;

1.339
date	2004.08.29.21.33.52;	author zaphod;	state Exp;
branches;
next	1.338;

1.338
date	2004.08.28.22.56.42;	author zaphod;	state Exp;
branches;
next	1.337;

1.337
date	2004.07.25.23.53.17;	author zaphod;	state Exp;
branches;
next	1.336;

1.336
date	2004.07.19.03.52.38;	author zaphod;	state Exp;
branches;
next	1.335;

1.335
date	2004.07.18.22.56.16;	author zaphod;	state Exp;
branches;
next	1.334;

1.334
date	2004.07.18.20.20.18;	author zaphod;	state Exp;
branches;
next	1.333;

1.333
date	2004.07.12.04.07.33;	author zaphod;	state Exp;
branches;
next	1.332;

1.332
date	2004.07.10.21.08.02;	author zaphod;	state Exp;
branches;
next	1.331;

1.331
date	2004.07.10.18.33.20;	author zaphod;	state Exp;
branches;
next	1.330;

1.330
date	2004.06.01.01.01.08;	author zaphod;	state Exp;
branches;
next	1.329;

1.329
date	2004.05.24.00.04.39;	author zaphod;	state Exp;
branches;
next	1.328;

1.328
date	2004.05.06.21.16.32;	author zaphod;	state Exp;
branches;
next	1.327;

1.327
date	2004.05.04.21.40.10;	author zaphod;	state Exp;
branches;
next	1.326;

1.326
date	2004.05.04.20.03.03;	author zaphod;	state Exp;
branches;
next	1.325;

1.325
date	2004.04.25.05.03.59;	author zaphod;	state Exp;
branches;
next	1.324;

1.324
date	2004.04.25.00.50.13;	author zaphod;	state Exp;
branches;
next	1.323;

1.323
date	2004.04.24.22.37.06;	author zaphod;	state Exp;
branches;
next	1.322;

1.322
date	2004.04.24.22.16.57;	author zaphod;	state Exp;
branches;
next	1.321;

1.321
date	2004.04.24.22.04.04;	author zaphod;	state Exp;
branches;
next	1.320;

1.320
date	2004.04.09.23.28.59;	author zaphod;	state Exp;
branches;
next	1.319;

1.319
date	2004.04.09.21.31.37;	author zaphod;	state Exp;
branches;
next	1.318;

1.318
date	2004.04.09.21.25.40;	author zaphod;	state Exp;
branches;
next	1.317;

1.317
date	2004.04.08.20.57.16;	author zaphod;	state Exp;
branches;
next	1.316;

1.316
date	2004.04.05.06.27.45;	author zaphod;	state Exp;
branches;
next	1.315;

1.315
date	2004.04.02.22.10.13;	author zaphod;	state Exp;
branches;
next	1.314;

1.314
date	2004.03.31.00.40.43;	author zaphod;	state Exp;
branches;
next	1.313;

1.313
date	2004.03.25.00.51.15;	author zaphod;	state Exp;
branches;
next	1.312;

1.312
date	2004.03.25.00.26.43;	author zaphod;	state Exp;
branches;
next	1.311;

1.311
date	2004.03.21.02.09.40;	author zaphod;	state Exp;
branches;
next	1.310;

1.310
date	2004.03.10.03.10.43;	author zaphod;	state Exp;
branches;
next	1.309;

1.309
date	2004.03.08.06.42.27;	author zaphod;	state Exp;
branches;
next	1.308;

1.308
date	2004.03.07.03.27.35;	author zaphod;	state Exp;
branches;
next	1.307;

1.307
date	2004.03.06.22.10.11;	author zaphod;	state Exp;
branches;
next	1.306;

1.306
date	2004.03.06.06.43.10;	author zaphod;	state Exp;
branches;
next	1.305;

1.305
date	2004.02.29.06.55.50;	author zaphod;	state Exp;
branches;
next	1.304;

1.304
date	2004.02.27.00.15.37;	author zaphod;	state Exp;
branches;
next	1.303;

1.303
date	2004.02.26.02.02.18;	author zaphod;	state Exp;
branches;
next	1.302;

1.302
date	2004.02.25.06.47.25;	author zaphod;	state Exp;
branches;
next	1.301;

1.301
date	2004.02.25.05.42.30;	author zaphod;	state Exp;
branches;
next	1.300;

1.300
date	2004.02.25.05.32.38;	author zaphod;	state Exp;
branches;
next	1.299;

1.299
date	2004.02.21.20.57.20;	author zaphod;	state Exp;
branches;
next	1.298;

1.298
date	2004.02.21.06.27.07;	author zaphod;	state Exp;
branches;
next	1.297;

1.297
date	2004.02.21.04.36.07;	author zaphod;	state Exp;
branches;
next	1.296;

1.296
date	2004.02.14.07.52.25;	author zaphod;	state Exp;
branches;
next	1.295;

1.295
date	2004.02.13.05.50.09;	author zaphod;	state Exp;
branches;
next	1.294;

1.294
date	2004.02.11.02.38.10;	author zaphod;	state Exp;
branches;
next	1.293;

1.293
date	2004.02.09.23.27.11;	author zaphod;	state Exp;
branches;
next	1.292;

1.292
date	2004.02.08.22.52.56;	author zaphod;	state Exp;
branches;
next	1.291;

1.291
date	2004.02.05.07.32.24;	author zaphod;	state Exp;
branches;
next	1.290;

1.290
date	2004.02.05.00.04.15;	author zaphod;	state Exp;
branches;
next	1.289;

1.289
date	2004.02.04.23.19.21;	author zaphod;	state Exp;
branches;
next	1.288;

1.288
date	2004.02.04.06.06.21;	author zaphod;	state Exp;
branches;
next	1.287;

1.287
date	2004.02.04.01.34.44;	author zaphod;	state Exp;
branches;
next	1.286;

1.286
date	2004.02.04.00.38.50;	author zaphod;	state Exp;
branches;
next	1.285;

1.285
date	2004.02.04.00.16.42;	author zaphod;	state Exp;
branches;
next	1.284;

1.284
date	2004.02.02.05.24.05;	author zaphod;	state Exp;
branches;
next	1.283;

1.283
date	2004.02.02.01.45.56;	author zaphod;	state Exp;
branches;
next	1.282;

1.282
date	2004.02.02.01.11.05;	author zaphod;	state Exp;
branches;
next	1.281;

1.281
date	2004.02.02.00.30.43;	author zaphod;	state Exp;
branches;
next	1.280;

1.280
date	2004.02.02.00.14.15;	author zaphod;	state Exp;
branches;
next	1.279;

1.279
date	2004.01.29.03.38.25;	author zaphod;	state Exp;
branches;
next	1.278;

1.278
date	2004.01.18.07.19.26;	author zaphod;	state Exp;
branches;
next	1.277;

1.277
date	2004.01.16.23.59.32;	author zaphod;	state Exp;
branches;
next	1.276;

1.276
date	2004.01.15.19.39.47;	author zaphod;	state Exp;
branches;
next	1.275;

1.275
date	2003.12.29.00.19.07;	author zaphod;	state Exp;
branches;
next	1.274;

1.274
date	2003.12.28.07.16.52;	author zaphod;	state Exp;
branches;
next	1.273;

1.273
date	2003.12.24.23.02.05;	author zaphod;	state Exp;
branches;
next	1.272;

1.272
date	2003.12.21.21.01.43;	author zaphod;	state Exp;
branches;
next	1.271;

1.271
date	2003.12.15.07.22.09;	author zaphod;	state Exp;
branches;
next	1.270;

1.270
date	2003.12.15.00.49.56;	author zaphod;	state Exp;
branches;
next	1.269;

1.269
date	2003.12.13.02.36.56;	author zaphod;	state Exp;
branches;
next	1.268;

1.268
date	2003.12.11.05.16.53;	author zaphod;	state Exp;
branches;
next	1.267;

1.267
date	2003.12.10.06.22.00;	author zaphod;	state Exp;
branches;
next	1.266;

1.266
date	2003.12.09.05.07.32;	author zaphod;	state Exp;
branches;
next	1.265;

1.265
date	2003.12.09.02.49.47;	author zaphod;	state Exp;
branches;
next	1.264;

1.264
date	2003.12.08.04.42.53;	author zaphod;	state Exp;
branches;
next	1.263;

1.263
date	2003.12.08.01.04.45;	author zaphod;	state Exp;
branches;
next	1.262;

1.262
date	2003.12.07.23.56.35;	author zaphod;	state Exp;
branches;
next	1.261;

1.261
date	2003.12.07.21.10.30;	author zaphod;	state Exp;
branches;
next	1.260;

1.260
date	2003.12.06.21.20.06;	author zaphod;	state Exp;
branches;
next	1.259;

1.259
date	2003.12.04.07.03.43;	author zaphod;	state Exp;
branches;
next	1.258;

1.258
date	2003.12.04.04.28.20;	author zaphod;	state Exp;
branches;
next	1.257;

1.257
date	2003.12.01.19.19.28;	author zaphod;	state Exp;
branches;
next	1.256;

1.256
date	2003.12.01.06.46.57;	author zaphod;	state Exp;
branches;
next	1.255;

1.255
date	2003.12.01.04.22.31;	author zaphod;	state Exp;
branches;
next	1.254;

1.254
date	2003.12.01.04.19.59;	author zaphod;	state Exp;
branches;
next	1.253;

1.253
date	2003.11.29.00.33.21;	author zaphod;	state Exp;
branches;
next	1.252;

1.252
date	2003.11.29.00.18.29;	author zaphod;	state Exp;
branches;
next	1.251;

1.251
date	2003.11.28.22.27.31;	author zaphod;	state Exp;
branches;
next	1.250;

1.250
date	2003.11.28.21.06.42;	author zaphod;	state Exp;
branches;
next	1.249;

1.249
date	2003.11.28.05.16.49;	author zaphod;	state Exp;
branches;
next	1.248;

1.248
date	2003.11.27.02.38.30;	author zaphod;	state Exp;
branches;
next	1.247;

1.247
date	2003.11.27.02.33.02;	author zaphod;	state Exp;
branches;
next	1.246;

1.246
date	2003.11.27.02.07.26;	author zaphod;	state Exp;
branches;
next	1.245;

1.245
date	2003.11.24.00.46.28;	author zaphod;	state Exp;
branches;
next	1.244;

1.244
date	2003.11.23.23.49.36;	author zaphod;	state Exp;
branches;
next	1.243;

1.243
date	2003.11.23.00.34.30;	author zaphod;	state Exp;
branches;
next	1.242;

1.242
date	2003.11.22.21.17.23;	author zaphod;	state Exp;
branches;
next	1.241;

1.241
date	2003.11.21.05.29.46;	author zaphod;	state Exp;
branches;
next	1.240;

1.240
date	2003.11.21.05.05.47;	author zaphod;	state Exp;
branches;
next	1.239;

1.239
date	2003.11.09.23.43.26;	author zaphod;	state Exp;
branches;
next	1.238;

1.238
date	2003.11.08.21.52.54;	author zaphod;	state Exp;
branches;
next	1.237;

1.237
date	2003.11.04.03.26.24;	author zaphod;	state Exp;
branches;
next	1.236;

1.236
date	2003.11.02.21.59.05;	author zaphod;	state Exp;
branches;
next	1.235;

1.235
date	2003.11.02.20.36.31;	author zaphod;	state Exp;
branches;
next	1.234;

1.234
date	2003.11.02.03.19.49;	author zaphod;	state Exp;
branches;
next	1.233;

1.233
date	2003.10.27.04.08.26;	author zaphod;	state Exp;
branches;
next	1.232;

1.232
date	2003.10.26.22.13.57;	author zaphod;	state Exp;
branches;
next	1.231;

1.231
date	2003.10.26.21.43.17;	author zaphod;	state Exp;
branches;
next	1.230;

1.230
date	2003.10.26.20.27.45;	author zaphod;	state Exp;
branches;
next	1.229;

1.229
date	2003.10.26.18.12.46;	author zaphod;	state Exp;
branches;
next	1.228;

1.228
date	2003.10.26.02.04.12;	author zaphod;	state Exp;
branches;
next	1.227;

1.227
date	2003.10.25.22.43.34;	author zaphod;	state Exp;
branches;
next	1.226;

1.226
date	2003.10.25.22.38.34;	author zaphod;	state Exp;
branches;
next	1.225;

1.225
date	2003.10.25.02.51.52;	author zaphod;	state Exp;
branches;
next	1.224;

1.224
date	2003.10.24.18.33.37;	author zaphod;	state Exp;
branches;
next	1.223;

1.223
date	2003.10.24.03.32.26;	author zaphod;	state Exp;
branches;
next	1.222;

1.222
date	2003.10.23.05.46.34;	author zaphod;	state Exp;
branches;
next	1.221;

1.221
date	2003.10.20.22.07.50;	author zaphod;	state Exp;
branches;
next	1.220;

1.220
date	2003.10.20.00.32.55;	author zaphod;	state Exp;
branches;
next	1.219;

1.219
date	2003.10.19.21.03.47;	author zaphod;	state Exp;
branches;
next	1.218;

1.218
date	2003.10.19.18.45.08;	author zaphod;	state Exp;
branches;
next	1.217;

1.217
date	2003.10.13.05.35.37;	author zaphod;	state Exp;
branches;
next	1.216;

1.216
date	2003.10.13.05.15.58;	author zaphod;	state Exp;
branches;
next	1.215;

1.215
date	2003.10.13.04.55.05;	author zaphod;	state Exp;
branches;
next	1.214;

1.214
date	2003.10.13.04.34.23;	author zaphod;	state Exp;
branches;
next	1.213;

1.213
date	2003.10.05.23.17.17;	author zaphod;	state Exp;
branches;
next	1.212;

1.212
date	2003.10.05.22.53.42;	author zaphod;	state Exp;
branches;
next	1.211;

1.211
date	2003.10.05.20.14.32;	author zaphod;	state Exp;
branches;
next	1.210;

1.210
date	2003.10.05.19.08.29;	author zaphod;	state Exp;
branches;
next	1.209;

1.209
date	2003.09.24.01.41.53;	author zaphod;	state Exp;
branches;
next	1.208;

1.208
date	2003.09.22.19.00.19;	author zaphod;	state Exp;
branches;
next	1.207;

1.207
date	2003.09.19.05.50.09;	author zaphod;	state Exp;
branches;
next	1.206;

1.206
date	2003.09.17.02.58.57;	author zaphod;	state Exp;
branches;
next	1.205;

1.205
date	2003.09.16.20.47.02;	author zaphod;	state Exp;
branches;
next	1.204;

1.204
date	2003.09.16.01.22.30;	author zaphod;	state Exp;
branches;
next	1.203;

1.203
date	2003.09.15.22.20.09;	author zaphod;	state Exp;
branches;
next	1.202;

1.202
date	2003.09.15.04.49.20;	author zaphod;	state Exp;
branches;
next	1.201;

1.201
date	2003.09.12.00.52.29;	author zaphod;	state Exp;
branches;
next	1.200;

1.200
date	2003.09.10.23.09.32;	author zaphod;	state Exp;
branches;
next	1.199;

1.199
date	2003.09.09.22.19.31;	author zaphod;	state Exp;
branches;
next	1.198;

1.198
date	2003.09.09.01.19.04;	author zaphod;	state Exp;
branches;
next	1.197;

1.197
date	2003.09.05.00.08.19;	author zaphod;	state Exp;
branches;
next	1.196;

1.196
date	2003.09.04.02.51.19;	author zaphod;	state Exp;
branches;
next	1.195;

1.195
date	2003.09.04.00.26.29;	author zaphod;	state Exp;
branches;
next	1.194;

1.194
date	2003.09.03.05.08.59;	author zaphod;	state Exp;
branches;
next	1.193;

1.193
date	2003.09.03.02.41.43;	author zaphod;	state Exp;
branches;
next	1.192;

1.192
date	2003.09.02.18.03.09;	author zaphod;	state Exp;
branches;
next	1.191;

1.191
date	2003.09.02.03.31.06;	author zaphod;	state Exp;
branches;
next	1.190;

1.190
date	2003.09.01.22.25.59;	author zaphod;	state Exp;
branches;
next	1.189;

1.189
date	2003.08.31.23.25.35;	author zaphod;	state Exp;
branches;
next	1.188;

1.188
date	2003.08.31.23.03.34;	author zaphod;	state Exp;
branches;
next	1.187;

1.187
date	2003.08.31.20.18.38;	author zaphod;	state Exp;
branches;
next	1.186;

1.186
date	2003.08.30.06.47.16;	author zaphod;	state Exp;
branches;
next	1.185;

1.185
date	2003.08.26.23.21.16;	author zaphod;	state Exp;
branches;
next	1.184;

1.184
date	2003.08.26.18.47.29;	author zaphod;	state Exp;
branches;
next	1.183;

1.183
date	2003.08.26.18.44.01;	author zaphod;	state Exp;
branches;
next	1.182;

1.182
date	2003.08.25.23.51.27;	author zaphod;	state Exp;
branches;
next	1.181;

1.181
date	2003.08.25.17.23.59;	author zaphod;	state Exp;
branches;
next	1.180;

1.180
date	2003.08.25.05.06.36;	author zaphod;	state Exp;
branches;
next	1.179;

1.179
date	2003.08.24.23.48.52;	author zaphod;	state Exp;
branches;
next	1.178;

1.178
date	2003.08.24.23.44.33;	author zaphod;	state Exp;
branches;
next	1.177;

1.177
date	2003.08.24.23.37.53;	author zaphod;	state Exp;
branches;
next	1.176;

1.176
date	2003.08.24.23.31.55;	author zaphod;	state Exp;
branches;
next	1.175;

1.175
date	2003.08.24.23.25.11;	author zaphod;	state Exp;
branches;
next	1.174;

1.174
date	2003.08.24.22.44.22;	author zaphod;	state Exp;
branches;
next	1.173;

1.173
date	2003.08.12.01.00.13;	author zaphod;	state Exp;
branches;
next	1.172;

1.172
date	2003.08.11.21.05.01;	author zaphod;	state Exp;
branches;
next	1.171;

1.171
date	2003.08.11.20.36.42;	author zaphod;	state Exp;
branches;
next	1.170;

1.170
date	2003.08.10.23.50.48;	author zaphod;	state Exp;
branches;
next	1.169;

1.169
date	2003.08.09.19.33.29;	author zaphod;	state Exp;
branches;
next	1.168;

1.168
date	2003.08.09.02.32.50;	author zaphod;	state Exp;
branches;
next	1.167;

1.167
date	2003.08.07.06.18.52;	author zaphod;	state Exp;
branches;
next	1.166;

1.166
date	2003.08.07.02.14.55;	author zaphod;	state Exp;
branches;
next	1.165;

1.165
date	2003.08.06.22.41.32;	author zaphod;	state Exp;
branches;
next	1.164;

1.164
date	2003.08.06.06.04.24;	author zaphod;	state Exp;
branches;
next	1.163;

1.163
date	2003.08.06.02.20.08;	author zaphod;	state Exp;
branches;
next	1.162;

1.162
date	2003.08.05.21.52.21;	author zaphod;	state Exp;
branches;
next	1.161;

1.161
date	2003.08.05.01.40.01;	author zaphod;	state Exp;
branches;
next	1.160;

1.160
date	2003.07.30.21.20.14;	author zaphod;	state Exp;
branches;
next	1.159;

1.159
date	2003.07.28.04.46.50;	author zaphod;	state Exp;
branches;
next	1.158;

1.158
date	2003.07.27.00.26.00;	author zaphod;	state Exp;
branches;
next	1.157;

1.157
date	2003.07.27.00.12.34;	author zaphod;	state Exp;
branches;
next	1.156;

1.156
date	2003.07.26.03.12.09;	author zaphod;	state Exp;
branches;
next	1.155;

1.155
date	2003.07.26.02.43.37;	author zaphod;	state Exp;
branches;
next	1.154;

1.154
date	2003.07.26.00.09.22;	author zaphod;	state Exp;
branches;
next	1.153;

1.153
date	2003.07.24.04.07.23;	author zaphod;	state Exp;
branches;
next	1.152;

1.152
date	2003.07.21.03.12.03;	author zaphod;	state Exp;
branches;
next	1.151;

1.151
date	2003.07.21.00.08.16;	author zaphod;	state Exp;
branches;
next	1.150;

1.150
date	2003.07.20.04.48.37;	author zaphod;	state Exp;
branches;
next	1.149;

1.149
date	2003.07.19.05.42.47;	author zaphod;	state Exp;
branches;
next	1.148;

1.148
date	2003.07.19.04.44.30;	author zaphod;	state Exp;
branches;
next	1.147;

1.147
date	2003.07.19.02.38.29;	author zaphod;	state Exp;
branches;
next	1.146;

1.146
date	2003.07.19.02.03.45;	author zaphod;	state Exp;
branches;
next	1.145;

1.145
date	2003.07.16.03.32.27;	author zaphod;	state Exp;
branches;
next	1.144;

1.144
date	2003.07.12.23.00.58;	author zaphod;	state Exp;
branches;
next	1.143;

1.143
date	2003.07.12.22.28.31;	author zaphod;	state Exp;
branches;
next	1.142;

1.142
date	2003.07.07.06.08.55;	author zaphod;	state Exp;
branches;
next	1.141;

1.141
date	2003.06.29.05.31.24;	author zaphod;	state Exp;
branches;
next	1.140;

1.140
date	2003.06.29.05.22.45;	author zaphod;	state Exp;
branches;
next	1.139;

1.139
date	2003.06.27.00.00.48;	author zaphod;	state Exp;
branches;
next	1.138;

1.138
date	2003.06.25.07.32.11;	author zaphod;	state Exp;
branches;
next	1.137;

1.137
date	2003.06.25.06.32.50;	author zaphod;	state Exp;
branches;
next	1.136;

1.136
date	2003.06.25.06.21.21;	author zaphod;	state Exp;
branches;
next	1.135;

1.135
date	2003.06.17.05.17.10;	author zaphod;	state Exp;
branches;
next	1.134;

1.134
date	2003.06.17.03.08.02;	author zaphod;	state Exp;
branches;
next	1.133;

1.133
date	2003.06.16.03.18.17;	author zaphod;	state Exp;
branches;
next	1.132;

1.132
date	2003.06.16.00.43.07;	author zaphod;	state Exp;
branches;
next	1.131;

1.131
date	2003.06.15.22.39.25;	author zaphod;	state Exp;
branches;
next	1.130;

1.130
date	2003.06.15.22.03.25;	author zaphod;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.12.06.29.40;	author zaphod;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.12.04.27.26;	author zaphod;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.12.02.09.17;	author zaphod;	state Exp;
branches;
next	1.126;

1.126
date	2003.06.12.01.08.22;	author zaphod;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.11.05.46.25;	author zaphod;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.11.04.58.28;	author zaphod;	state Exp;
branches;
next	1.123;

1.123
date	2003.06.10.03.53.04;	author zaphod;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.09.05.13.29;	author zaphod;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.09.04.10.33;	author zaphod;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.08.02.24.39;	author zaphod;	state Exp;
branches;
next	1.119;

1.119
date	2003.06.08.02.06.37;	author zaphod;	state Exp;
branches;
next	1.118;

1.118
date	2003.06.08.01.47.58;	author zaphod;	state Exp;
branches;
next	1.117;

1.117
date	2003.06.08.00.37.18;	author zaphod;	state Exp;
branches;
next	1.116;

1.116
date	2003.06.08.00.26.45;	author zaphod;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.06.05.17.49;	author zaphod;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.06.04.40.11;	author zaphod;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.06.02.10.38;	author zaphod;	state Exp;
branches;
next	1.112;

1.112
date	2003.05.08.03.24.40;	author zaphod;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.05.03.27.50;	author zaphod;	state Exp;
branches;
next	1.110;

1.110
date	2003.05.01.03.33.01;	author zaphod;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.23.20.20.19;	author zaphod;	state Exp;
branches;
next	1.108;

1.108
date	2003.04.22.22.11.16;	author zaphod;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.22.20.24.18;	author zaphod;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.22.17.47.06;	author zaphod;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.21.20.56.16;	author zaphod;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.21.20.37.10;	author zaphod;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.20.02.55.45;	author zaphod;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.20.00.59.23;	author zaphod;	state Exp;
branches;
next	1.101;

1.101
date	2003.04.20.00.57.43;	author zaphod;	state Exp;
branches;
next	1.100;

1.100
date	2003.04.20.00.17.15;	author zaphod;	state Exp;
branches;
next	1.99;

1.99
date	2003.04.19.23.32.38;	author zaphod;	state Exp;
branches;
next	1.98;

1.98
date	2003.04.19.04.59.01;	author zaphod;	state Exp;
branches;
next	1.97;

1.97
date	2003.04.19.04.08.39;	author zaphod;	state Exp;
branches;
next	1.96;

1.96
date	2003.04.18.21.54.10;	author zaphod;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.18.04.23.49;	author zaphod;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.15.05.07.50;	author zaphod;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.15.04.59.15;	author zaphod;	state Exp;
branches;
next	1.92;

1.92
date	2003.04.15.04.53.39;	author zaphod;	state Exp;
branches;
next	1.91;

1.91
date	2003.04.12.00.06.27;	author zaphod;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.11.02.56.49;	author zaphod;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.11.02.52.16;	author zaphod;	state Exp;
branches;
next	1.88;

1.88
date	2003.04.11.02.33.21;	author zaphod;	state Exp;
branches;
next	1.87;

1.87
date	2003.04.09.05.35.13;	author zaphod;	state Exp;
branches;
next	1.86;

1.86
date	2003.04.05.02.41.06;	author zaphod;	state Exp;
branches;
next	1.85;

1.85
date	2003.04.04.04.03.16;	author zaphod;	state Exp;
branches;
next	1.84;

1.84
date	2003.04.02.05.56.50;	author zaphod;	state Exp;
branches;
next	1.83;

1.83
date	2003.04.02.05.07.29;	author zaphod;	state Exp;
branches;
next	1.82;

1.82
date	2003.04.02.04.25.19;	author zaphod;	state Exp;
branches;
next	1.81;

1.81
date	2003.04.01.04.56.55;	author zaphod;	state Exp;
branches;
next	1.80;

1.80
date	2003.04.01.04.52.26;	author zaphod;	state Exp;
branches;
next	1.79;

1.79
date	2003.03.31.03.33.38;	author zaphod;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.31.03.24.10;	author zaphod;	state Exp;
branches;
next	1.77;

1.77
date	2003.03.31.03.15.03;	author zaphod;	state Exp;
branches;
next	1.76;

1.76
date	2003.03.30.02.48.20;	author zaphod;	state Exp;
branches;
next	1.75;

1.75
date	2003.03.30.02.13.43;	author zaphod;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.30.00.54.25;	author zaphod;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.30.00.23.01;	author zaphod;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.28.04.28.35;	author zaphod;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.21.22.04.01;	author zaphod;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.21.01.38.59;	author zaphod;	state Exp;
branches;
next	1.69;

1.69
date	2003.03.20.22.37.06;	author zaphod;	state Exp;
branches;
next	1.68;

1.68
date	2003.03.20.19.16.28;	author zaphod;	state Exp;
branches;
next	1.67;

1.67
date	2003.03.20.02.07.53;	author zaphod;	state Exp;
branches;
next	1.66;

1.66
date	2003.03.19.04.31.45;	author zaphod;	state Exp;
branches;
next	1.65;

1.65
date	2003.03.17.04.13.11;	author zaphod;	state Exp;
branches;
next	1.64;

1.64
date	2003.03.14.03.24.04;	author zaphod;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.09.08.37.37;	author zaphod;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.09.08.11.54;	author zaphod;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.09.07.29.04;	author zaphod;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.09.01.57.25;	author zaphod;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.09.01.13.00;	author zaphod;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.09.00.53.52;	author zaphod;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.09.00.50.21;	author zaphod;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.09.00.33.45;	author zaphod;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.08.04.39.58;	author zaphod;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.08.03.16.17;	author zaphod;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.07.04.42.28;	author zaphod;	state Exp;
branches;
next	1.52;

1.52
date	2002.12.29.23.59.35;	author zaphod;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.29.01.36.49;	author zaphod;	state Exp;
branches;
next	1.50;

1.50
date	2002.12.28.23.38.23;	author zaphod;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.26.23.11.29;	author zaphod;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.26.01.37.15;	author zaphod;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.24.22.29.38;	author zaphod;	state Exp;
branches;
next	1.46;

1.46
date	2002.09.24.20.32.50;	author zaphod;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.24.02.25.18;	author zaphod;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.23.23.12.01;	author zaphod;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.21.01.00.29;	author zaphod;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.20.23.20.06;	author zaphod;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.20.22.44.00;	author zaphod;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.15.04.26.05;	author zaphod;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.14.01.11.13;	author zaphod;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.13.22.01.25;	author zaphod;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.13.20.10.19;	author zaphod;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.10.22.36.16;	author zaphod;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.09.03.19.32;	author zaphod;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.09.02.38.34;	author zaphod;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.07.00.23.14;	author zaphod;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.10.21.56.22;	author zaphod;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.09.04.19.14;	author zaphod;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.04.22.40.12;	author zaphod;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.03.03.48.20;	author zaphod;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.27.03.50.58;	author zaphod;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.19.01.52.25;	author zaphod;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.18.03.42.17;	author zaphod;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.18.03.28.02;	author zaphod;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.18.03.15.03;	author zaphod;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.18.03.08.57;	author zaphod;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.18.02.33.43;	author zaphod;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.17.02.05.26;	author zaphod;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.16.01.14.26;	author zaphod;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.15.03.47.16;	author zaphod;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.14.04.38.37;	author zaphod;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.23.53.58;	author zaphod;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.07.03.57.02;	author zaphod;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.22.18.51;	author zaphod;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.04.22.43.47;	author zaphod;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.04.18.21.03;	author zaphod;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.03.02.17.50;	author zaphod;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.01.15.33;	author zaphod;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.31.23.05.32;	author zaphod;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.31.18.33.19;	author zaphod;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.02.09.18;	author zaphod;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.29.23.52.13;	author zaphod;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.21.09.11;	author zaphod;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.03.31.11;	author zaphod;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.28.23.54.07;	author zaphod;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.28.22.12.51;	author zaphod;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.28.01.58.13;	author zaphod;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.28.01.34.35;	author zaphod;	state Exp;
branches;
next	;


desc
@first complete rewrite of the fabled toast-script
@


1.488
log
@try to filter toast find output by version; bump copyright date
@
text
@#!/bin/sh

##############################################################################
#                                                                            #
# This entire file is toast, a program for installing and managing software. #
# Copyright (C) 2003-2016 Jacques Frechet.                                   #
# This file should also contain version 3 of the GNU General Public License, #
# which includes its own copyright notice.                                   #
#                                                                            #
# For more information on toast, including purpose, usage, licensing, and    #
# LACK OF ANY WARRANTY, visit http://www.toastball.net/toast/, run "toast"   #
# without arguments, or refer to the documentation at the end of this file.  #
#                                                                            #
##############################################################################

exec perl -x $0 ${1+"$@@"}
echo "Can't find perl in PATH; aborting." >&2
exit 1

##############################################################################

#!perl
#line 24
# the #line directive above tells perl that this is line 24, not line 3

use 5; # oldest version that actually works might be 5.003; not sure....

# allow script to run even in the absence of strict.pm, etc.
BEGIN { $^W = 1 } # use warnings
BEGIN { $^H |= 0x602 } # use strict

# warn if "use warnings" and "use strict" are not both in effect
if($^V && %SIG) # test requires perl 5.6.0 with working %SIG (not microperl)
{
  { my($ok); { local $SIG{'__WARN__'} = sub { die };
      $ok = !eval('1 + "a"') } $ok || warn("use warnings"); }
  { eval('$foo = 1') && warn("use strict"); $@@ = undef }
}

##############################################################################

my($rcsid) = q$Id: toast,v 1.487 2016/01/27 07:55:09 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\S+) (\S+ \S+) (\S+) Exp (\S+ )?$/ || die;
my($myname, $myversion, $mytimestamp, $myauthor) = ($1, $2, $3, $4);
$myversion .= "+" if $5; # if this version may contain changes not in RCS
my($myurl) = "http://www.toastball.net/toast/";
my($bugurl) = $myurl . "sendbug";
my($mycopyright) = "Copyright (C) 2003-2016 Jacques Frechet";
my($genby) = "generated by $myname version $myversion [$myurl]";
$myname eq "toast" && $myauthor eq "zaphod" || die; # avoid accidents w/ CVS

##############################################################################

sub trace(;$)
{
  my($i, $out, $prev) = (shift || 1, "", "");
  while(my($package, $file, $line) = caller($i++))
  {
    $out .= ($prev eq $file ? "/" : $out ? "; $file: " : "$file: ") . $line;
    $prev = $file;
  }
  $out .= " v$myversion";
  return $out;
}

sub msg($@@)
{
  my($default) = shift;
  my($msg) = join('', @@_) || $default;
  $msg =~ s/\n+$//;
  return $msg . "\n[" . trace(2) . "]\n";
}

sub error(@@)
{
  die(msg("assertion failed", @@_));
}

sub warning(@@)
{
  warn(msg("warning", @@_));
}

##############################################################################

sub true() { 1 }
sub false() { "" }

sub scalify(@@) { return @@_ if wantarray; error if scalar(@@_) > 1; $_[0] }
sub emptytoundef(@@) { scalify(map(defined($_) && $_ eq "" ? undef : $_, @@_)) }
sub undeftoempty(@@) { scalify(map(defined($_) ? $_ : "", @@_)) }
sub firstdef(@@) { return $_ foreach grep(defined($_), @@_); undef; }

sub samelist(\@@\@@)
{
  my($x, $y) = @@_;
  my($size) = scalar(@@$x);
  return false if $size != scalar(@@$y);
  return true unless $size > 0;
  for(0..$size-1)
  {
    my($vx, $vy) = ($$x[$_], $$y[$_]);
    my($dx, $dy) = map { defined($_) ? 1 : 0 } ($vx, $vy);
    return false if $dx != $dy || $dx & $vx ne $vy;
  }
  return true;
}

##############################################################################

sub max(@@)
{
  my($result);
  for(@@_)
  {
    $result = $_ if !defined($result) || $result < $_;
  }
  $result;
}

sub min(@@)
{
  my($result);
  for(@@_)
  {
    $result = $_ if !defined($result) || $result > $_;
  }
  $result;
}

sub uniq(@@)
{
  my(@@list) = @@_;
  my(@@result, %seen);
  for(@@list)
  {
    next if $seen{$_};
    $seen{$_} = true;
    push(@@result, $_);
  }
  return @@result;
}

##############################################################################

sub dirname($) { my($arg) = @@_; $arg =~ s|/[^/]*$|| ? $arg : "."; }
sub basename($) { my($arg) = @@_; $arg =~ s|.*/||g; $arg; }
sub stripext($) { my($a)=@@_;$a=~s/(\.(t|sh)ar(\.g?z)?)?(\.[a-z]\w*)?$//i;$a }
sub stripquery($) { my($arg) = @@_; $arg =~ s/\?.*$//; $arg; }

sub path(@@)
{
  my(@@args) = @@_;
  @@args || error("empty path");
  defined($_) || error("undefined path component in @@args") for @@args;
  $args[0] = "" if $args[0] eq "/";
  my($ret) = join("/", @@args);
  $ret =~ m|//| && error("double slash in path(@@args): $ret");
  $ret =~ m|/$| && error("final slash in path(@@args): $ret");
  return $ret;
}

sub laxpath(@@)
{
  my(@@args) = @@_;
  defined($_) || error("undefined path component in @@args") for @@args;
  length($_) || error("empty path component in @@args") for @@args;
  my($ret) = join("/", @@args);
  $ret =~ s|/+|/|g;
  $ret =~ s|/$||;
  return $ret;
}

sub optpath(@@)
{
  path(grep { defined($_) && $_ ne "" } @@_);
}

sub unpath($)
{
  my($path) = @@_;
  $path =~ s|^/|| || error;
  $path =~ m|^/| && error;
  $path =~ m|/$| && error;
  $path =~ m|//| && error;
  return split(/\//, $path);
}

##############################################################################

sub checkedeval($)
{
  my($code) = @@_;
  my($result) = eval($code);
  if($@@)
  {
    local($_) = $code;
    s/\s+/ /g;
    error($@@, $_);
  }
  $result;
}

##############################################################################

sub safeopen(*$$)
{
  local(*HANDLE) = shift;
  my($mode, $file) = @@_;
  my($escaped) = "$file\x00";
  $escaped = "./$escaped" unless $escaped =~ m!^/!;
  open(HANDLE, "$mode$escaped") || error("open $file: $!");
  binmode(HANDLE) || error("binmode $file: $!"); # perl 5.8.0 utf8 bug
}

sub whilefile(&$)
{
  my($sub, $file) = @@_;
  local(*FILE, $_);
  safeopen(*FILE, "<", $file);
  while(defined($_ = <FILE>) && &$sub($_)) { }
  close(FILE) || error("close $file for read: $!");
  !defined($_);
}

sub readfile($)
{
  my($file) = @@_;
  my(@@result);
  whilefile { push(@@result, $_) } $file;
  @@result;
}

##############################################################################

BEGIN
{
  my($uid, $euid) = ($<, $>);

  sub superuser()
  {
    $uid == 0 || $euid == 0;
  }
}

##############################################################################

BEGIN
{
  my(%optdefault) =
  (
    "storedir" =>
        (superuser || !$ENV{HOME}) ? "/toast" : "$ENV{HOME}/.toast",
    "armdir" => superuser ? "/usr/local" : "armed",
    "altarmdirs" => "",
    "username" => "toast",
    "fallbackuid" => 23,
    "nice" => 10,
    "postarmprog" => superuser ? "/sbin/ldconfig" : "",
    "editprog" => "",
    "defaultcmd" => "help",
    "stickyopts" => "reconfigure confappend makeappend compilecmd installcmd",
    "findsites" => "all",
    "httpproxy" => exists($ENV{http_proxy}) ? $ENV{http_proxy} : "",
    "ftpproxy" => exists($ENV{ftp_proxy}) ? $ENV{ftp_proxy} : "",
    "confappend" => "",
    "makeappend" => "",
    "compilecmd" => "",
    "installcmd" => "",
    "quiet" => "false",
    "expand" => "true",
    "autofind" => "true",
    "autochange" => "false",
    "autorename" => "true",
    "autoenv" => "true",
    "autoclean" => "true",
    "autopurge" => "false",
    "autoarm" => "true",
    "autodisarm" => "true",
    "autodemolish" => "true",
    "autoremove" => "false",
    "crossversion" => "false",
    "skipmismatched" => "true",
    "ccache" => "true",
    "preload" => "true",
    "strictpreload" => $^O eq "linux" ? "true" : "false",
    "useflock" => $^O =~ /win/i ? "false" : "true",
    "reconfigure" => "true",
    "fixliblinks" => "true",
    "interactive" => "false",
    "stoponerror" => "true",
    "ignorecase" => "true",
    "showurls" => "true",
    "showopts" => "true",
    "libvar" => "LD_LIBRARY_PATH",
    "infodir" => "true",
    "xmlcatalog" => "true",
    "hspkg" => "false",
    "protect" => "false",
    "relative" => "false",
    "debugrewrite" => "false",
  );

  sub envopt($)
  {
    $ENV{uc("${myname}_$_[0]")};
  }

  my(%optloaded);

  sub istrue($)
  {
    my($val) = @@_;
    return $val && $val =~ /^(1|true|on|yes|enabled)$/i;
  }

  sub isboolean($)
  {
    my($val) = @@_;
    return !$val || istrue($val) || $val =~ /^(false|off|no|disabled)$/i;
  }

  sub isopt($)
  {
    my($name) = @@_;
    return exists($optdefault{$name});
  }

  sub isboolopt($)
  {
    my($name) = @@_;
    return false unless isopt($name);
    my($def) = $optdefault{$name};
    return defined($def) && ($def eq "true" || $def eq "false");
  }

  sub checkoptname($)
  {
    my($name) = @@_;
    isopt($name) || error("no such option: $name");
  }

  my(%cmdlineopt);

  sub unloadopts(;$;$)
  {
    my($n, $v) = @@_;
    my($key) = undeftoempty($n) . "/" . undeftoempty($v);
    delete $optloaded{$key};
  }

  sub loadopts(;$;$)
  {
    my($n, $v) = @@_;
    my($key) = undeftoempty($n) . "/" . undeftoempty($v);
    return $optloaded{$key} if exists($optloaded{$key});
    my($opts) = $optloaded{$key} = {};
    my(@@list);
    push(@@list, laxpath($ENV{HOME}, qw[.toast conf]))
        if exists($ENV{HOME}) && length($ENV{HOME});
    push(@@list, qw[/toast/conf /etc/toast.conf /usr/local/etc/toast.conf]);
    @@list = path(pkgpath($n, $v), "conf") if defined($n);
    for(@@list)
    {
      my($dotfile) = $_;
      if(-e($dotfile))
      {
        whilefile
        {
          s/^\s+//;
          s/\s+$//;
          return true if $_ eq "" || /^\#/;
          /^([^\=]*?)\s*\=\s*(.*)$/ ||
              error("$dotfile: line $.: missing \"=\"");
          my($name, $val) = ($1, $2);
          isopt($name) ||
              error("$dotfile: line $.: unknown option name \"$name\"");
          !isboolopt($name) || isboolean($val) ||
              error("$dotfile: line $.: illegal boolean value: \"$val\"");
          $opts->{$name} = $val;
          true;
        } $dotfile;
        last unless defined($n);
      }

      next unless defined($n);
      next if (defined($v) ? 1 : 0) eq (&crossversion ? 1 : 0);

      my($changed);
      for(map($_ ne "all" ? $_ : grep($_ ne "stickyopts", keys(%cmdlineopt)),
          map(lc, split(/\W+/, getopt("stickyopts")))))
      {
        my($new) = $cmdlineopt{$_};
        next unless defined($new);
        my($old) = $opts->{$_};
        if($new eq parseopt($_, getglobalopt($_)))
        {
          next unless defined($old);
          delete($opts->{$_});
          $changed = true;
        }
        elsif(!defined($old) || $new ne $old)
        {
          $new =~ s/\n/ /g;
          $opts->{$_} = $new;
          $changed = true;
        }
      }
      if($changed && -w(dirname($dotfile)))
      {
        my(@@lines);
        for(sort(keys(%{$opts})))
        {
          my($value) = $opts->{$_};
          next unless defined($value);
          push(@@lines,
              "$_=" . (!isboolopt($_) ? $value : $value ? "1" : "0") . "\n");
        }
        writefile($dotfile, @@lines) if @@lines;
        rm($dotfile) unless @@lines;
      }

    }
    return $opts;
  }

  sub parseopt($$)
  {
    my($name, $val) = @@_;
    checkoptname($name);
    if(isboolopt($name))
    {
      error("$name is a boolean option") unless isboolean($val);
      $val = istrue($val);
    }
    else
    {
      error("option $name is undefined") unless defined($val);
      if($name =~ /dir$/ && $val !~ m|^/|)
      {
        error("relative path not allowed for storedir: $val")
            if $name eq "storedir";
        $val = path(&storedir, $val);
      }
    }
    return $val;
  }

  sub setopt($$)
  {
    my($name, $val) = @@_;
    $cmdlineopt{$name} = parseopt($name, $val);
  }

  sub getglobalopt($)
  {
    my($name) = @@_;
    error unless isopt($name);
    return firstdef(envopt($name), loadopts()->{$name}, $optdefault{$name});
  }

  my($an, $av);

  sub setactivepkg(;$;$)
  {
    unloadopts($an, $av) if defined($an);
    ($an, $av) = @@_;
    unloadopts($an, $av) if defined($an);
    loadopts($an, $av) if defined($an);
  }

  sub getopt($)
  {
    my($name) = @@_;
    error unless isopt($name);
    my($nvopts, $nopts);
    $nvopts = loadopts($an, $av) if defined($av);
    $nopts = loadopts($an) if defined($an);
    return parseopt($name, firstdef($cmdlineopt{$name},
        $nvopts->{$name}, $nopts->{$name}, getglobalopt($name)));
  }

  checkedeval("sub $_() { getopt('$_') }") foreach keys(%optdefault);
}

sub cmd_getopt(@@)
{
  my($name) = shift;
  error("option name required") unless defined($name);
  error("invalid option name: $name") unless isopt($name);
  my(@@pkgs) = parse(@@_);
  error("only one package allowed") if scalar(@@pkgs) > 1;
  setactivepkg();
  for(@@pkgs)
  {
    my($n, $v) = @@$_;
    setactivepkg($n, $v);
  }
  my($result);
  eval { $result = getopt($name) };
  my($err) = $@@;
  setactivepkg();
  die($err) if $err;
  $result = ($result ? "true" : "false") if isboolopt($name);
  error unless defined($result);
  print("$result\n");
}

##############################################################################

sub pkgdir() { "pkg" }
sub archivedir() { "archive" }
sub editdir() { "edit" }
sub urlfile() { "url" }
sub armdirlink() { "armdir" }
sub srcdir() { "src" }
sub helperdir() { "helpers" }
sub rootdir() { "root" }
sub buildlog() { "build.log" }
sub brokenlog() { "broken.log" }
sub offsuffix() { ".off" }
sub tmpsuffix() { ".tmp" }
sub baksuffix() { ".orig" }

##############################################################################

BEGIN
{
  my($verbosified) = false;
  sub verbosify() { $verbosified = true }
  sub say(@@) { print(@@_) if $verbosified || !quiet }
}

sub explain(@@) { say("# @@_\n"); }
sub announce(@@) { say("@@_\n"); }

##############################################################################

sub unbuffer(*)
{
  local(*HANDLE) = shift;
  my($save) = select(HANDLE) || error;
  $| = 1;
  select($save) || error;
}

##############################################################################

sub whiledir(&$)
{
  my($sub, $dir) = @@_;
  local(*DIR);
  opendir(DIR, $dir) || error("opendir $dir: $!");
  my(@@list) = sort(grep($_ ne "." && $_ ne "..", readdir(DIR)));
  closedir(DIR);
  my($result) = true;
  for(@@list)
  {
    last unless $result = &$sub($_);
  }
  return !!$result;
}

sub fordir(&@@)
{
  my($sub, $dir) = @@_;
  my($result) = true;
  whiledir { &$sub(@@_) || !($result = false) } $dir;
  $result;
}

sub abswhiledir(&$)
{
  my($sub, $dir) = @@_;
  whiledir { &$sub($_ = path($dir, $_)) } $dir;
}

sub ls($)
{
  my($dir) = @@_;
  my(@@result);
  whiledir { push(@@result, $_) } $dir;
  @@result;
}

sub optls($)
{
  my($dir) = @@_;
  return -e($dir) ? ls($dir) : ();
}

sub absls($)
{
  my($dir) = @@_;
  map { path($dir, $_) } ls($dir);
}

sub dfs($&&&)
{
  my($base, $predir, $file, $postdir, $rel) = @@_;
  defined($rel) || -e($base) || -l($base) || error("not found: $base");
  local($_) = optpath($base, $rel);
  (-l || !-d) ? &$file($rel) :
      &$predir($rel) &&
      (whiledir {&dfs($base, $predir, $file, $postdir, optpath($rel, $_))} $_)
      && &$postdir($rel);
}

##############################################################################

sub md(@@)
{
  announce("mkdir", @@_);
  mkdir($_, 0777) || error("mkdir $_: $!") foreach @@_;
  true;
}

sub optmd(@@)
{
  foreach(@@_)
  {
    next if -d;
    announce("mkdir", $_);
    if(!mkdir($_, 0777))
    {
      my($err) = $!;
      -d || error("mkdir $_: $err");
    }
  }
  true;
}

sub mdp(@@)
{
  foreach(@@_)
  {
    my($dirname) = dirname($_);
    $dirname eq "/" || $dirname eq "." || -d($dirname) || &mdp($dirname);
  }
  optmd(@@_);
}

##############################################################################

sub mv($$)
{
  my($source, $dest) = @@_;
  announce("mv", $source, $dest);
  rename($source, $dest) || error("mv $source $dest: $!");
}

sub ln($$)
{
  my($source, $target) = @@_;
  announce("ln", "-s", $source, $target);
  symlink($source, $target) || error("ln -s $source $target: $!");
}

sub relln($$)
{
  my($src, $target) = @@_;
  ln($src =~ m|^/| ? findrelpath(dirname($target), $src) : $src, $target);
}

sub optrelln($$)
{
  my($source, $target) = @@_;
  relln($source, $target) unless -e($target) || -l($target);
}

##############################################################################

sub safestat($)
{
  my($file) = @@_;
  my(@@result) = stat($file);
  @@result || error("stat $file: $!");
  @@result;
}

sub getmode($) { (safestat($_[0]))[2] & 07777 }
sub getmtime($) { (safestat($_[0]))[9] }

sub chmodimpl($$@@)
{
  my($mode, $announce, @@files) = @@_;
  $mode &= 01777 & ~umask;
  my($txtmode) = sprintf("%lo", $mode);
  @@files = grep { getmode($_) != $mode } @@files;
  announce("chmod", $txtmode, @@files) if @@files && $announce;
  chmod($mode, $_) || error("chmod $txtmode $_: $!") for @@files;
  true;
}

sub safechmod($@@)
{
  my($mode, @@files) = @@_;
  chmodimpl($mode, true, @@files);
}

sub silentchmod($@@)
{
  my($mode, @@files) = @@_;
  chmodimpl($mode, false, @@files);
}

sub writefilemode($$@@)
{
  my($name, $mode, @@contents) = @@_;
  local(*FILE);
  explain("creating $name");
  safeopen(*FILE, ">", $name) || error("open $name for write: $!");
  print FILE @@contents;
  close(FILE) || error("close $name for write: $!");
  safechmod($mode, $name) if $mode;
}

sub writefile($@@)
{
  my($name, @@contents) = @@_;
  writefilemode($name, false, @@contents);
}

sub writescript($@@)
{
  my($name, @@contents) = @@_;
  writefilemode($name, 0777, @@contents);
}

sub samefile($$)
{
  my($a, $b) = @@_;
  my($da, $ia) = safestat($a);
  my($db, $ib) = safestat($b);
  $da eq $db && $ia eq $ib;
}

sub optsamefile($$)
{
  my($a, $b) = @@_;
  my($da, $ia) = stat($a);
  return false unless defined($da);
  my($db, $ib) = stat($b);
  defined($db) && $da eq $db && $ia eq $ib;
}

sub patch(&$)
{
  my($sub, $file) = @@_;
  my(@@contents) = readfile($file);
  my($patched) = false;

  local($_);
  for(@@contents)
  {
    my($old) = $_;
    &$sub($_);
    $patched ||= $old ne $_;
  }

  if($patched)
  {
    my($mode) = getmode($file);
    mv($file, addbak($file));
    writefilemode($file, $mode, @@contents);
  }

  return $patched;
}

sub optpatch(&$)
{
  my($sub, $file) = @@_;
  return -e($file) ? &patch($sub, $file) : false;
}

##############################################################################

sub silentrm(@@)
{
  unlink || error("rm $_: $!") for @@_;
  true;
}

sub rm(@@)
{
  announce("rm", "-f", @@_) if @@_;
  silentrm(@@_);
}

sub silentrd(@@)
{
  rmdir || error("rmdir $_: $!") for @@_;
  true;
}

sub rd(@@)
{
  announce("rmdir", @@_) if @@_;
  silentrd(@@_);
}

sub rmall(@@)
{
  announce("rm", "-rf", @@_) if @@_;
  dfs
  (
    $_,
    sub { -w($_) ? true : silentchmod(0777, $_) },
    sub { silentrm($_) },
    sub { silentrd($_) }
  ) for @@_;
  true;
}

sub optrmall(@@) { rmall(grep(-e || -l, @@_)) }

##############################################################################

sub benice()
{
  my($inc) = nice;
  return $inc eq "0" unless $inc =~ /^-?[1-9][0-9]*$/;
  eval { setpriority(0, 0, min(getpriority(0, 0) + $inc, 20)) };
}

sub safeexec(@@)
{
  my(@@prog) = @@_;
  {
    local($^W) = false; # suppress misguided exec failure warning
    exec(@@prog);
  }
  error("exec @@prog: $!");
}

sub runimpl(@@)
{
  my(@@prog) = @@_;
  announce(@@prog);
  my($result);
  {
    local($^W) = false; # suppress misguided exec failure warning
    $result = system(@@prog);
  }
  return "exec @@prog: $!" unless defined($result) && $result != -1;
  my($code) = ($? >> 8) & 0xff;
  my($sig) = $? & 0xff;
  return "@@prog failed (code $code, signal $sig)" if $?;
  return undef;
}

sub run(@@)
{
  my($msg) = runimpl(@@_);
  error($msg) if defined($msg);
  return true;
}

sub optrun(@@)
{
  my($msg) = runimpl(@@_);
  explain("warning: $msg; continuing") if defined($msg);
  return !defined($msg);
}

sub optcdrunimpl($$@@)
{
  my($asroot, $dir, @@prog) = @@_;
  announce("(cd $dir; @@prog)");
  my($pid);
  if($pid = fork) # parent
  {
    waitpid($pid, 0);
    return !$?;
  }
  else # child
  {
    defined($pid) || error("fork: $!");
    dropprivs() unless $asroot;
    silentcd($dir);
    safeexec(@@prog);
  }
}

sub optcdrun($@@)
{
  my($dir, @@prog) = @@_;
  optcdrunimpl(true, $dir, @@prog);
}

sub cdrun($@@)
{
  my($dir, @@prog) = @@_;
  optcdrun($dir, @@prog) || error("@@prog returned $?");
}

sub cdrunnonroot($@@)
{
  my($dir, @@prog) = @@_;
  optcdrunimpl(false, $dir, @@prog) || error("@@prog returned $?");
}

sub shellescape(@@)
{
  my(@@words) = @@_;
  for(@@words)
  {
    error unless defined($_);
    next unless m![^\w\+,\./:\@@-]!;
    /'/ ? s!([^\w\+,\./:\@@-])!\\$1!g : ($_ = "'$_'");
  }
  return join(" ", @@words);
}

sub openprog(*$@@)
{
  local(*HANDLE) = shift;
  my($prog, @@args) = @@_;
  announce($prog, @@args);
  @@args = shellescape(@@args);
  {
    local($^W) = false; # suppress misguided exec failure warning
    if(!open(HANDLE, "$prog @@args |"))
    {
      explain("failed to exec $prog: $!");
      return false;
    }
  }
  binmode(HANDLE) || error("binmode: $!"); # perl 5.8.0 utf8 bug
}

##############################################################################

sub urlunescape($)
{
  local($_) = @@_;
  s/\%([0-9a-f]{2})/chr(hex($1))/gei;
  $_;
}

sub tcpconnect(*$$;$)
{
  local(*HANDLE) = shift;
  my($host, $port, $iaddr) = @@_;
  $iaddr = gethostbyname($host) || error("gethostbyname $host: $!")
      unless defined($iaddr);
  my($pf, $type, $proto, $paddr) = (2, 1, 0, pack("Sna4x8", 2, $port, $iaddr));
  eval q{
    use Socket;
    $paddr = sockaddr_in($port, $iaddr);
    ($pf, $type) = (PF_INET, SOCK_STREAM);
    $proto = getprotobyname("tcp");
  };
  socket(HANDLE, $pf, $type, $proto) || error("$!");
  binmode(HANDLE) || error("binmode: $!"); # perl 5.8.0 utf8 bug
  connect(HANDLE, $paddr) || error("connect $host:$port: $!");
  unbuffer(HANDLE);
  return $iaddr;
}

sub openhttp(*$;$;$;$;$)
{
  local(*HANDLE) = shift;
  my($url, $method, $proxy, $body) = @@_;
  $method ||= "GET";
  $proxy = httpproxy unless defined($proxy);
  explain("$method $url" . ($proxy ? " via $proxy" : ""));
  $url =~ m!^(\w+)://([-\w\.]+)(:(\d+))?(/[\!-\~]*)?$! ||
      error("bad url: $url");
  my($proto, $host, $port, $path) = ($1, $2, $4 || 80, $5 || '/');
  my($hdrhost) = $port == 80 ? $host : "$host:$port";
  if($proxy)
  {
    $path = "$proto://$host:$port$path";
    $proxy =~ m!^(\w+://)?([-\w\.]+)(:(\d+))?/?$!
        || error("bad proxy URL: $proxy");
    ($host, $port) = ($2, $4 || 8080);
  }
  my($uagent) = "$myname/$myversion ($^O; $myurl)";
  my($clen) = defined($body) ? "Content-Length: ".length($body)."\r\n" : "";
  $body = "" unless defined($body);
  my($request) = "$method $path HTTP/1.0\r\nHost: $hdrhost\r\n".
      "User-Agent: $uagent\r\nAccept: */*\r\n$clen\r\n$body";
  tcpconnect(*HANDLE, $host, $port);
  print HANDLE $request or error("write to $host:$port: $!");
}

sub httphead($)
{
  my($url) = @@_;
  local(*HANDLE);
  openhttp(*HANDLE, $url, "HEAD");
  my($result) = join('', <HANDLE>);
  close(HANDLE) || error;
  return $result;
}

sub httppost($$)
{
  my($url, $post) = @@_;
  local(*HANDLE);
  openhttp(*HANDLE, $url, "POST", undef, $post);
  my($result) = join('', <HANDLE>);
  close(HANDLE) || error;
  $result =~ s|^HTTP/[\w\.]+ (\d+) .*?\r?\n\r?\n||s
      || error("bad POST response from $url: $result");
  $1 eq "200" || error("POST to $url returned HTTP response code $1");
  return $result;
}

sub openhttpurl(*$;$)
{
  local(*HANDLE) = shift;
  my($url, $proxy) = @@_;
  local($_);
  for(1..5)
  {
    openhttp(*HANDLE, $url, undef, $proxy);
    local($_);
    $! = undef;
    $_ = <HANDLE>;
    error($! ? "$url: $!" : "$url: unexpected EOF") unless defined($_);
    s/\r?\n?$//;
    m|^HTTP/[\w\.]+ [23]0[01237] | || error("$url: $_");
    my($redirect);
    while(<HANDLE>)
    {
      $redirect = $1 if /^location:\s*(\S+)/i;
      last if /^\r?\n?$/;
    }
    return $url unless $redirect;
    ($url) = linksfromstring("<a href=$redirect>", $url); # *wince*
  }
  error("too many HTTP redirects");
}

sub ftpcmd(*$;$)
{
  local(*CTRL, $_) = shift;
  my($cmd, $expected) = @@_;
  print CTRL "$cmd\r\n" || error("error sending ftp command: $!") if $cmd;
  while(<CTRL>)
  {
    s/[\r\n]+$//;
    if(/^(\d{3}) /)
    {
      my($response) = $1;
      error("ftp server: $_") if defined($expected) && $response != $expected;
      return $_;
    }
  }
  error("lost ftp control connection") unless $cmd =~ /QUIT/;
}

sub openftpurl(*$)
{
  local(*HANDLE) = shift;
  my($url) = @@_;
  return openhttpurl(*HANDLE, $url, ftpproxy) if ftpproxy;

  explain("fetching $url");
  $url =~ m!^(\w+)://([-\w\.]+)(:(\d+))?(/[\!-\~]*)?$!
      || error("bad url: $url");
  my($proto, $host, $port, $path) = ($1, $2, $4 || 21, $5 || '/');
  error("don't know how to fetch FTP directory listings") if $path =~ m!/$!;

  local(*CTRL, *DATA);
  my($ip) = tcpconnect(*CTRL, $host, $port);
  ftpcmd(*CTRL, undef, 220);
  ftpcmd(*CTRL, "USER anonymous", 230);
  ftpcmd(*CTRL, "TYPE I");
  my($size) = ftpcmd(*CTRL, "SIZE $path", 213);
  $size =~ /^\d+\s+(\d+)/ or die("bad SIZE response: $size");
  $size = $1;
  my($pasv) = ftpcmd(*CTRL, "PASV", 227);
  $pasv =~ /(\d+)\s*,\s*(\d+)\s*\)/ || error("bad PASV response: $pasv");
  my($dataport) = $1*256 + $2;
  tcpconnect(*DATA, $host, $dataport, $ip);
  my($retr) = ftpcmd(*CTRL, "RETR $path");
  $retr =~ /^(\d+) / && $1 <= 150 || error("ftp RETR error: $retr");
  my($pid) = open(HANDLE, "-|");
  error("fork: $!") unless defined($pid);
  if($pid)
  {
    close(CTRL) || error("close ftp control: $!");
    close(DATA) || error("close ftp data: $!");
    return true;
  }

  binmode(STDOUT) || error("binmode stdout: $!"); # perl 5.8.0 utf8 bug
  my($buf) = 0;
  while(sysread(DATA, $buf = "", min(8192, $size), 0))
  {
    print($buf) || error("write stdout: $!");
    $size -= length($buf);
  }
  error("lost ftp data connection") if $size;
  close(DATA) || error("close ftp data: $!");
  ftpcmd(*CTRL, undef, 226);
  ftpcmd(*CTRL, "QUIT");
  exit(0);
  error;
}

sub openfileurl(*$)
{
  local(*HANDLE) = shift;
  my($url) = @@_;
  $url =~ m!^file://([^/]+)(/.*)$! || error("bad url: $url");
  my($host, $path) = ($1, $2);
  $host eq "localhost" || error("bad file-url hostname: $host");
  my($source) = urlunescape($path);
  explain("reading $source");
  safeopen(*HANDLE, "<", $source);
}

sub opensshurl(*$)
{
  local(*HANDLE) = shift;
  my($url) = @@_;
  $url =~ m!^ssh://([^/]+)(/.*)$! || error("bad url: $url");
  my($userhost, $path) = ($1, $2);
  $userhost = urlunecape($userhost);
  $path = urlunescape($path);
  $userhost =~ /^\-/ && error("bad url: $url");
  $path =~ /^\-/ && error("bad url: $url");
  openprog(*HANDLE, "ssh", $userhost, "cat", $path);
}

sub openurl(*$)
{
  local(*HANDLE) = shift;
  my($url) = @@_;
  $url =~ /^(\w+):/ || error("bad url: $url");
  my($proto) = lc($1);

  local($ENV{http_proxy}) = httpproxy if httpproxy;
  local($ENV{ftp_proxy}) = ftpproxy if ftpproxy;

  return openhttpurl(*HANDLE, $url) if $proto eq "http";

  $proto eq "file" && openfileurl(*HANDLE, $url) ||
  $proto eq "ssh" && opensshurl (*HANDLE, $url) ||
  openprog(*HANDLE, "wget", "-O-", $url) ||
  openprog(*HANDLE, "GET", $url) ||
  $proto eq "ftp" && openftpurl(*HANDLE, $url) ||
  error("unable to download: $url");

  return $url;
}

sub geturl($$)
{
  my($url, $dest) = @@_;

  my($newurl);
  eval q{
    use LWP::UserAgent;
    $newurl = false;
    explain("fetching $url to $dest");
    my($ua) = LWP::UserAgent->new;
    $ua->proxy(["http", "https"], httpproxy) if httpproxy;
    $ua->proxy("ftp", ftpproxy) if ftpproxy;
    my($r) = $ua->get($url, ":content_file" => $dest);
    my($msg) = $r->message;
    die("unable to fetch $url: $msg\n") if $r->is_error;
    $newurl = $r->base;
  } if $url !~ /^(file|ssh)/;
  error($@@) if $@@ && defined($newurl);
  return $newurl if $newurl;

  local(*SOURCE, *DEST);
  explain("creating $dest");
  safeopen(*DEST, ">", $dest);
  $newurl = openurl(*SOURCE, $url);

  my($buf, $result);
  my(@@dstat) = stat(DEST);
  my($bufsize) = $dstat[11] || 4096;
  while($result = read(SOURCE, $buf, $bufsize))
  {
    (print DEST $buf) || error("write to $dest: $!");
  }
  defined($result) || error("read from $url: $!");

  close(DEST) || error("close $dest for write: $!");
  close(SOURCE) || error("close $url for read: $!");
  return $newurl;
}

sub linksfromstring($$)
{
  my($html, $url) = @@_;
  $url =~ m!^((\w+:)//[^/]+)([^\?\#]*/)?! || error("bad url: $url");
  my($proto, $host, $parent) = ($2, $1, $3);
  $parent = defined($parent) && $parent ne "" ? "$host$parent" : "$host/";
  my(@@links);
  while($html =~ m!\b(href\s*\=\s*\"?|((http|ftp)://))([^\s\>\"]+)!ig)
  {
    my($link) = join("", undeftoempty($2, $4));
    next if $link =~ /^mailto:/i;
    $link = $proto . $link if $link =~ m!^//!;
    $link = $host . $link if $link =~ m!^/!;
    $link = $parent . $link unless $link =~ m!^(\w+)://!;
    $link =~ s/\&amp;/\&/g;
    push(@@links, cleanurl($link));
  }
  return @@links;
}

sub linksfromstream(*$)
{
  local(*HANDLE, $_) = shift;
  my($url) = @@_;
  my(@@links);
  while(<HANDLE>)
  {
    push(@@links, linksfromstring($_, $url));
  }
  return uniq(@@links);
}

sub linksfromurl($)
{
  my($url) = @@_;
  return map("file://localhost$_", absls($1)) if $url =~ m!^file://\w+(/.*)/$!;
  local(*HANDLE);
  my($newurl) = openurl(*HANDLE, $url);
  my(@@links) = linksfromstream(*HANDLE, $newurl);
  close(HANDLE) || error("unable to fetch $url");
  return @@links;
}

##############################################################################

{
  my($pwd);

  sub pwd()
  {
    return $pwd if defined($pwd);

    my($env) = $ENV{PWD};
    return $pwd = $env if defined($env) && -d($env) && samefile($env, ".");

    my($dir, $result) = (".", "");
    for(1..1024)
    {
      my($parent) = path($dir, "..");
      my($dd, $id) = safestat($dir);
      my($dp, $ip) = safestat($parent);
      return $pwd = "/$result" if $dd eq $dp && $id eq $ip;
      error("can't find working directory") if whiledir
      {
        my($d, $i) = safestat(path($parent, $_));
        my($same) = $d eq $dd && $i eq $id;
        $result = optpath($_, $result) if $same;
        !$same;
      } $parent;
      $dir = $parent;
    }
    error("level>1024 in pwd");
  }

  sub silentcd($)
  {
    my($dir) = @@_;
    $ENV{PWD} = $pwd = abspath($dir);
    chdir($dir) || error("chdir $dir: $!");
    return true;
  }
}

sub abspath($)
{
  my($path) = @@_;
  return $path if $path =~ m!^/!;
  $path =~ s!^./!!;
  $path =~ s!/./!/!g;
  return path(pwd, $path);
}

sub findrelpath($$)
{
  my($from, $to) = @@_;

  # allow last component of $to to be missing or not a directory
  my(@@append);
  if(!-d($to))
  {
    push(@@append, basename($to));
    $to = dirname($to);
  }

  # walk from $to all the way to /, leaving a trail of bread crumbs
  my($dir, $lastdi, @@names, %ditonameidx) = ($to, "");
  for(1..1024)
  {
    my($d, $i) = safestat($dir);
    my($di) = "$d $i";
    $ditonameidx{$di} = $#names unless exists($ditonameidx{$di});
    last if $dir eq "/";
    $dir = path($dir, "..");
    last unless -r($dir);
    last if whiledir # figure out how to get down one level from here
    {
      my($pd, $pi) = stat(path($dir, $_));
      return true unless defined($pd) && "$pd $pi" eq $di;
      push(@@names, $_);
      return false;
    } $dir;
    last if $di eq $lastdi;
    $lastdi = $di;
  }

  # walk up from $from towards / looking for bread crumbs
  ($dir, $lastdi) = ($from, "");
  my(@@result);
  for(1..1024)
  {
    my($d, $i) = safestat($dir);
    my($di) = "$d $i";
    last if $di eq $lastdi;
    $lastdi = $di;
    if(exists($ditonameidx{$di}))
    {
      my($nameidx) = $ditonameidx{$di};
      push(@@result, reverse(@@names[0..$nameidx]));
      push(@@result, @@append);
      return scalar(@@result) == 0 ? "." : path(@@result);
    }
    $dir = path($dir, "..");
    push(@@result, "..");
  }

  error("no relative path from $from to $to");
}

##############################################################################

sub validname($)
{
  my($name) = @@_;
  defined($name) && $name =~
      /^[\w\x80-\xff][\w_ -\)\+-\-\x80-\xff]*[\w\x80-\xff]/;
}

sub validversion($)
{
  my($version) = @@_;
  defined($version) && $version =~
      /^[\w\x80-\xff]([\w_ -\)\+-\-\x80-\xff\.]*[\w\x80-\xff])?/;
}

sub validbuild($)
{
  my($build) = @@_;
  defined($build) && /[1-9][0-9]*/;
}

##############################################################################

sub pkgpath(;$$$)
{
  my($name, $version, $build) = @@_;
  !defined($build) || ($build =~ /^[1-9]\d*$/) || error("bad build: $build");
  optpath(storedir, pkgdir, $name, defined($version) && "v$version", $build);
}

sub addoff($)
{
  my($path) = @@_;
  error if offsuffix eq "";
  return $path . offsuffix;
}

sub addtmp($)
{
  my($path) = @@_;
  error if tmpsuffix eq "";
  return $path . tmpsuffix;
}

sub addbak($)
{
  my($path) = @@_;
  error if baksuffix eq "";
  return $path . baksuffix;
}

##############################################################################

sub commonlen(@@)
{
  my(@@sources) = @@_;
  my($firstsource) = $sources[0] || error;
  my($i) = 0;
  while(true)
  {
    for(@@sources)
    {
      return $i if length == $i ||
          substr($_, $i, 1) ne substr($firstsource, $i, 1);
    }
    $i++;
  }
}

sub reverseall(@@)
{
  my(@@result);
  push(@@result, scalar reverse($_)) foreach @@_;
  @@result;
}

sub collapse(@@)
{
  my(@@sources) = @@_;
  my($firstsource) = $sources[0];
  return $firstsource if scalar(@@sources) == 1;
  my($frontlen) = commonlen(@@sources);
  my($backlen) = commonlen(reverseall(@@sources));
  my($len) = length($firstsource);
  return $firstsource if $frontlen + $backlen >= $len
      || $frontlen + $backlen == 0;
  substr($firstsource, 0, $frontlen) . substr($firstsource, $len - $backlen);
}

sub sanitize($)
{
  my($word) = @@_;
  $word =~ s/\:/_/g;
  $word =~ s/^[\W_]+//;
  $word =~ s/(source|src)$//i; # e.g. mozilla, libjpeg, minicom, XFree86
  $word =~ s/[^a-z0-9\+]+$//i; # allow e.g. gtk+
  $word eq "" ? undef : $word;
}

sub guessnv(@@)
{
  my(@@urls) = @@_;
  s/^(cvs.*)\#(\d+)$/$1-$2/ for @@urls;
  /^git:/ && s/(\.git)?#/./g for @@urls;
  my($base) = collapse(map(stripext(basename(stripquery($_))), @@urls));
  $base =~ /^([\w]+[\w\-]*[a-z]+)[-_]v?(\d[\w\.\+\-]+)$/i  # Cryptix_src_3-1-1
      || $base =~ /^([a-z][a-z_-]*[a-z])\.(\d[\d\.]+)$/i #device-mapper.1.00.07
      || $base =~ /^(LVM2)\.(2\.\d[\d\.]+)$/               # LVM2.2.00.08
      || $base =~ /^([^-]+)-(.*\d.+)$/                     # iputils-ss020124
      || $base =~ /^(\D+[^a-z])v(\d.*)$/                   # TinyMAZEv2.4a
      || $base =~ /^(\D+)(\d.*)$/                          # fceu019linux
      || $base =~ /^(.*)()$/;                              # Xmerge
  my($name, $version) = ($1, $2);
  $name =~ s/\./_/g; # helps parse() distinguish filenames from pkg names
  $name =~ s/::/-/g; # perl module naming convention
  return (sanitize($name), sanitize($version));
}

##############################################################################

sub padfactor() { 40 }

sub padsingle($)
{
  my($arg) = @@_;
  $arg = "" unless defined($arg);
  my($len) = length($arg);
  $len > padfactor ? $arg : (' ' x (padfactor - $len)) . $arg;
}

sub padnum($)
{
  my($arg) = @@_;
  my(@@post) = $arg =~ s/-?([a-z]+)(\d+)$//i ? ($1, $2) : ("z" x padfactor, 0);
  my(@@n) = split(/\./, $arg);
  join(' ', map(padsingle($_), @@n[0..max(padfactor, $#n)], @@post));
}

sub cmpab()
{
  my($na, $nb) = map
  {
    my($x) = $_;
    $x =~ s/\d+(\.\d+)*(-?(pre|rc|test)\d+)?/padnum($&)/gie;
    $x;
  } ($a, $b);
  my($lca, $lcb) = (lc($na), lc($nb));
  $lca ne $lcb ? $lca cmp $lcb : $na ne $nb ? $na cmp $nb : $a cmp $b;
}

sub lastitem(@@)
{
  @@_ ? $_[$#_] : undef;
}

sub mkcmdline(@@)
{
  join(' ', map { my($a) = $_; $a =~ s/[^\w_\-\.\/]/\\$&/g; $a; } @@_);
}

##############################################################################

BEGIN
{
  my($uid, $gid, $usertext);

  sub initnonroot()
  {
    error unless superuser;
    return if $uid;
    $usertext = username;
    my($name);
    ($name, undef, $uid, $gid) = getpwnam($usertext);
    return if defined($name);
    my($tryuid) = fallbackuid;
    error("no such user: $usertext") unless $tryuid;
    explain("no such user: $usertext");
    for(1..65535)
    {
      if(!defined(getpwuid($tryuid)))
      {
        explain("falling back on uid $tryuid, gid $tryuid");
        ($uid, $gid, $usertext) = ($tryuid, $tryuid, $tryuid);
        return;
      }
      ++$tryuid;
      $tryuid = 1 if $tryuid == 65536;
    }
    error("can't find unused uid");
  }

  sub chownnonroot(@@)
  {
    my(@@files) = @@_;
    return true unless superuser;
    initnonroot;
    $uid || error;
    announce("chown", $usertext, @@files);
    chown($uid, $gid, @@files) || error("chown $uid:$gid @@files: $!");
  }

  sub belongstononroot($)
  {
    my($path) = @@_;
    my(@@stats) = safestat($path);
    initnonroot;
    $uid || error;
    return $stats[4] == $uid;
  }

  sub dropprivs()
  {
    return true unless superuser;
    error if $^V && eval('${^TAINT}');
    initnonroot;
    explain("running as user $usertext");
    $uid || error("refusing to run as root");
    $! = undef;
    $( = $gid;
    error("can't set GID: $!") if $!;
    $) = "$gid $gid";
    error("can't set groups: $!") if $!;
    ($>, $<) = ($uid, $uid);
    error("can't set UID: $!") if $!;
    $> == $< || error("real and effective UIDs do not match");
    $> == $uid || error("uid is not set correctly");
    error if $^V && eval('${^TAINT}');
  }
}

##############################################################################

sub optwhich($)
{
  my($prog) = @@_;
  local($_);
  for(split(/:/, $ENV{"PATH"}))
  {
    next if $_ eq "";
    my($path) = laxpath($_, $prog);
    $path = abspath($path) unless $path =~ m!^/!;
    return $path if -x($path);
  }
  return false;
}

sub which($)
{
  my($prog) = @@_;
  return optwhich(path) || error("can't find $prog in PATH");
}

##############################################################################

sub newenvvar($$;$;$)
{
  my($varname, $subdir, $default, $delim) = @@_;
  my(@@subdirs) = ref($subdir) ? (@@$subdir) : ($subdir);
  $delim ||= ":";
  my($adirs, @@adirs) = altarmdirs;
  push(@@adirs, $2 eq "" ? armdir : $2) while $adirs =~ /(^|:)([^:]*)/g;
  my(@@dirs);
  for $subdir (@@subdirs)
  {
    push(@@dirs, map(path($_, $subdir),
        uniq(map(m!^/! ? $_ : path(storedir, $_), @@adirs))));
  }
  my($current) = exists($ENV{$varname}) ? $ENV{$varname} : $default;

  if(defined($current))
  {
    my(%have);
    $have{$_} = 1 for split(/$delim/, $current);
    @@dirs = grep(!$have{$_}, @@dirs);
    push(@@dirs, $current);
  }

  return($varname, join($delim, @@dirs));
}

sub newenv()
{
  my($defaultman) = "/usr/man:/usr/share/man:/usr/local/man:/usr/X11R6/man";
  if(!exists($ENV{MANPATH})) # don't bother unless we're going to use it...
  {
    my($out) = `man -w 2>/dev/null`;
    chomp($out) if defined($out);
    $defaultman = $out if defined($out) && $out =~ m!^/! && $out !~ /\n/;
  }
  my($x) = path(qw(etc xml toast-xml-catalog));
  my($hspkgdir) = path(qw(etc toast-hs-package.conf));

  my(@@vars);
  push(@@vars, newenvvar("PATH", "bin"));
  push(@@vars, newenvvar("MANPATH", "man", $defaultman));
  push(@@vars, newenvvar("INFOPATH", "info", "")) if infodir;
  push(@@vars, newenvvar("CPATH", "include"));
  push(@@vars, newenvvar("LIBRARY_PATH", "lib"));
  push(@@vars, newenvvar(libvar, "lib")) if libvar;
  push(@@vars,
      newenvvar("PKG_CONFIG_PATH", ["lib/pkgconfig", "share/pkgconfig"]));
  push(@@vars, newenvvar("XML_CATALOG_FILES", $x, "/$x", " ")) if xmlcatalog;
  push(@@vars, newenvvar("GHC_PACKAGE_PATH", $hspkgdir, "")) if hspkg;
  return @@vars;
}

sub printnewenv()
{
  my(@@vars) = newenv;
  while(@@vars)
  {
    my($key, $value) = (shift(@@vars), shellescape(shift(@@vars)));
    my($export) = exists($ENV{$key}) ? "" : " export $key;";
    print("$key=$value;$export\n");
  }
  return @@vars;
}

sub setbuildenv()
{
  my(%vars) = printnewenv;
  $ENV{$_} = $vars{$_} for keys(%vars);
  true;
}

sub env(@@)
{
  @@_ && error;
  printnewenv;
  return true;
}

##############################################################################

sub yes()
{
  explain("forking yes subprocess");
  my($pid) = open(STDIN, "-|");
  error("fork: $!") unless defined($pid);
  return if $pid;
  print("\n") || last for 1..9999;
  exit(0)
}

sub showprebuildinfo($$$)
{
  my($name, $version, $build) = @@_;
  explain("$myname $myversion building " . pkgname($name, $version, $build));
  explain("$^X $0 $] $^O");
  optrun("lsb_release", "-a");
  optrun("uname", "-a");
  optrun("perl", "-V");
  optrun("printenv") || optrun("env");
  explain("argv: $_") for @@ARGV;
  my(@@urls) = pkgurls($name, $version);
  explain("no urls") unless @@urls;
  explain("url: $_") for @@urls;
  my(@@archives) = absls(path(pkgpath($name, $version), archivedir));
  explain("no archives") unless @@archives;
  optrun("md5sum", @@archives) if @@archives;
  true;
}

sub gettimes() { (time, times) }

sub showtimedeltas(@@)
{
  my($swall, $suser, $ssys, $scuser, $scsys) = @@_;
  my($ewall, $euser, $esys, $ecuser, $ecsys) = gettimes;
  my($text) = "";
  if(defined($suser))
  {
    $text .= ($euser - $suser + $ecuser - $scuser) . "s user ";
    $text .= ($esys  - $ssys  + $ecsys  - $scsys ) . "s system ";
  }
  $text .= ($ewall - $swall) . "s total";
  explain($text);
}

##############################################################################

# patch files may have leading garbage, so it can help for this to be largish:
sub magicbufsize { 1024 }

sub magicstring($)
{
  local($_) = @@_;

  return ".Z" if /^\x1f\x9d/;
  return ".gz" if /^\x1f\x8b/;
  return ".bz2" if /^BZ/;
  return ".zip" if /^PK\x03\x04/;
  return ".rpm" if /^\xed\xab\xee\xdb/;
  return ".deb" if /^\!\<arch\>\n/;
  return ".cpio" if /^07070[a-f\d]{30}/i;
  return ".tar" if /^[^\x00]+(..)?\x00{5,}[\x00\s\d]{30}/
      || /\x00ustar[ \x00]/;
  return ".shar" if m:^(\#!/bin/sh\n)?\# This is a shell archive:;
  return ".patch" if /^(diff |\*\*\* |Only in |Common subdirectories: |--- )/m;
  return "script" if m:^#!/\w+/\w:;

  return "";
}

sub magicfile($)
{
  my($file) = $_;
  local(*FILE);
  safeopen(*FILE, "<", $file);
  my($buf);
  defined(read(FILE, $buf, magicbufsize)) || error("read $file: $!");
  my($type) = magicstring($buf);
  if(!$type && length($buf) >= magicbufsize)
  {
    seek(FILE, -22, 2) || error("seek $file: $!");
    defined(read(FILE, $buf = "", 22)) || error("read $file: $!");
    $type = ".zip" if $buf =~ /^PK\x05\x06/; # end-of-directory signature
  }
  close(FILE) || error("close $file for read: $!");
  return $type;
}

sub readstdin($)
{
  my($len) = @@_;
  my($buf) = "";
  while($len > 0)
  {
    my($result) = sysread(STDIN, $buf, $len, length($buf));
    defined($result) || error("read stdin: $!");
    last unless $result;
    $len -= $result;
  }
  $buf;
}

sub skipstdin($)
{
  my($len) = @@_;
  while($len > 0)
  {
    my($chunk) = min($len, 8192);
    error("unexpected eof") unless length(readstdin($chunk)) == $chunk;
    $len -= $chunk;
  }
  return true;
}

sub forkstdin()
{
  my($pid) = open(STDIN, "-|");
  defined($pid) || error("fork stdin: $!");
  binmode(STDIN) || error("binmode stdin: $!"); # perl 5.8.0 utf8 bug
  return $pid;
}

sub dumpstdin($)
{
  my($buf) = @@_;
  binmode(STDOUT) || error("binmode stdout: $!"); # perl 5.8.0 utf8 bug
  print($buf);
  print($buf) while sysread(STDIN, $buf = "", 8192, 0);
  exit(0);
}

sub extractstdin($);

sub autoextractstdin(;$)
{
  my($buf) = @@_;
  $buf = readstdin(magicbufsize) unless defined($buf);
  my($type) = magicstring($buf);
  error("unknown file type: " . unpack("H*", $buf)) unless $type;
  forkstdin ? extractstdin($type) : dumpstdin($buf);
}

sub applypatchfromstdin()
{
  my($subdir);
  my($ok) = whiledir { !defined($subdir) && ($subdir = $_) } ".";
  safeexec(qw[patch -p1 -d], $subdir) if $ok && $subdir;
  safeexec(qw[patch -p0]);
}

sub rpmextractstdin()
{
  my($lead) = readstdin(96);
  $lead =~ /^\xed\xab\xee\xdb[\x03\x04]/ || error("not rpm v3 or v4");

  my($pad) = 0;
  my($hdr);
  while(magicstring($hdr = readstdin($pad + 16)) !~ /^\..z/i)
  {
    error("short rpm: " . unpack("H*", $hdr)) unless length($hdr) == $pad + 16;
    my($magic, $zero, $sections, $bytes) = unpack("x$pad N4", $hdr);
    $magic == 0x8eade801 || error(sprintf("bad rpm header: %08x", $magic));
    skipstdin($bytes + 16*$sections);
    $pad = (8 - $bytes%8) % 8;
  }

  autoextractstdin($hdr);
  error;
}

sub debextractstdin()
{
  my($magic) = readstdin(8);
  error("bad deb magic: " . unpack("H*", $magic)) unless $magic eq "!<arch>\n";

  for(;;)
  {
    my($hdr) = readstdin(60);
    error("bad deb hdr: " . unpack("H*", $hdr)) unless $hdr =~ / (\d+) +\`$/;
    my($len) = $1;
    skipstdin(1) if $hdr =~ s/^\n//;
    autoextractstdin if $hdr =~ /^data\./; # autoextractstdin doesn't return
    skipstdin($len);
  }

  error;
}

BEGIN # built-in gunzip (zcat)
{
  my($inbuf, $inlen, $outbuf, $written);
  my(@@llens) = qw[3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83
      99 115 131 163 195 227 258];
  my(@@lbits) = qw[0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0];
  my(@@dists) = qw[1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769
      1025 1537 2049 3073 4097 6145 8193 12289 16385 24577];
  my(@@dbits) = qw[0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12
      12 13 13];
  my(@@order) = qw[16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15];

  sub zread($)
  {
    my($len) = @@_;
    my($ofs, $buf) = 0;
    while($len > 0)
    {
      my($ret) = read(STDIN, $buf, $len, $ofs);
      defined($ret) or die("read: $!");
      die("unexpected EOF") if $ret == 0;
      $ofs += $ret;
      $len -= $ret;
    }
    return $buf;
  }

  sub readbit()
  {
    ($inbuf, $inlen) = (unpack("C", zread(1)), 8) unless $inlen;
    return ($inbuf & (1 << (8 - $inlen--))) ? 1 : 0;
  }

  sub nextbyte()
  {
    readbit && die("bad pad bit") while $inlen;
  }

  sub readbits($)
  {
    my($result, $bits) = (0, @@_);
    $result |= readbit << $_ for(0..$bits-1);
    return $result;
  }

  sub inithuff(@@)
  {
    my(@@lens) = @@_;
    my($maxlen) = 0;
    $_ > $maxlen && ($maxlen = $_) for @@lens;
    my(%result) = (maxlen => $maxlen);
    my($code, $len) = 0;
    for $len (1..$maxlen)
    {
      $code <<= 1;
      for(0..$#lens)
      {
        $result{sprintf("\%0${len}b", $code++)} = $_ if $lens[$_] == $len;
      }
    }
    return %result;
  }

  sub readhuff(%)
  {
    my(%map) = @@_;
    my($maxlen) = $map{"maxlen"};
    my($bits) = "";
    while(length($bits) < $maxlen)
    {
      $bits .= readbit;
      return $map{$bits} if exists($map{$bits});
    }
    die("bad huffman code: $bits");
  }

  sub zwrite($)
  {
    my($data) = @@_;
    $written += length($data);
    $outbuf .= $data;
    substr($outbuf, 0, length($outbuf) - 32768) = "" if length($outbuf) > 65536;
    print($data);
  }

  sub zcat()
  {
    my($id1, $id2, $cm, $flg) = unpack("C4", zread(10));
    die("bad magic: $id1 $id2") unless $id1 == 31 && $id2 == 139;
    die("bad cm: $cm") unless $cm == 8;
    die("bad flags: $flg") if $flg & 0xe0;
    zread(unpack("v", zread(2))) if $flg & 4; # FEXTRA
    if($flg & 8) { while(zread(1) ne "\x00") { } } # FNAME
    if($flg & 16) { while(zread(1) ne "\x00") { } } # FCOMMENT
    zread(2) if $flg & 2; # FHCRC

    ($written, $outbuf) = (0, "");
    my($bfinal);
    do
    {
      $bfinal = readbit;
      my($btype) = readbits(2);
      if($btype == 3)
      {
        die("bad btype");
      }
      elsif($btype == 0) # no compression
      {
        nextbyte;
        my($len, $nlen) = unpack("v2", zread(4));
        die("bad nlen: $len $nlen") if $nlen != (65535 - $len);
        zwrite(zread($len));
      }
      else
      {
        my(%llmap, %dmap, $ll);
        if($btype == 1) # fixed Huffman
        {
          $llmap{sprintf('%07b', $_)} = $_ + 256 for 0..23;
          $llmap{sprintf('%08b', $_ + 48)} = $_ for 0..143;
          $llmap{sprintf('%08b', $_ + 192)} = $_ + 280 for 0..7;
          $llmap{sprintf('%09b', $_ + 400)} = $_ + 144 for 0..111;
          $llmap{"maxlen"} = 9;
          $dmap{sprintf('%05b', $_)} = $_ for 0..29;
          $dmap{"maxlen"} = 5;
        }
        else # dynamic Huffman
        {
          my($hlit, $hdist, $hclen) = map(readbits($_), 5, 5, 4);
          my(@@rawclens, @@clens, @@lens);
          push(@@rawclens, readbits(3)) for 1..4+$hclen;
          $clens[$order[$_]] = $rawclens[$_] || 0 for 0..$#order;
          my(%cmap) = inithuff(@@clens);
          while(scalar(@@lens) < $hlit + $hdist + 258)
          {
            my($code) = readhuff(%cmap);
            if($code == 16)
            {
              die("no last code") unless @@lens;
              my($last) = $lens[$#lens];
              push(@@lens, $last) for 1..3+readbits(2);
            }
            elsif($code == 17)
            {
              push(@@lens, 0) for 1..3+readbits(3);
            }
            elsif($code == 18)
            {
              push(@@lens, 0) for 1..11+readbits(7);
            }
            else
            {
              push(@@lens, $code);
            }
          }
          %llmap = inithuff(@@lens[0..$hlit+256]);
          %dmap = inithuff(@@lens[$hlit+257..$hlit+$hdist+257]);
        }

        while(256 != ($ll = readhuff(%llmap)))
        {
          if($ll < 256)
          {
            zwrite(chr($ll));
          }
          else
          {
            my($i) = $ll - 257;
            my($len) = $llens[$i] + readbits($lbits[$i]);
            my($dist) = $dists[$i = readhuff(%dmap)] + readbits($dbits[$i]);
            zwrite(substr($outbuf, length($outbuf) - $dist, 1)) for(1..$len);
          }
        }
      }
    } until($bfinal);
    my($crc32, $isize) = unpack("V2", zread(8));
    die("bad isize: $isize != $written") unless $isize == $written;
  }
}

sub zfork()
{
  explain("falling back on built-in gunzip");
  return true if forkstdin;
  zcat;
  exit(0);
  error;
}

sub extractstdin($)
{
  my($type) = @@_;

  safeexec("tar", "xf", "-") if $type eq ".tar";
  safeexec("cpio", "-di") if $type eq ".cpio";
  safeexec("/bin/sh") if $type eq ".shar";

  applypatchfromstdin if $type eq ".patch";

  rpmextractstdin if $type eq ".rpm";
  debextractstdin if $type eq ".deb";

  if($type =~ /^\.(Z|gz|bz2)$/)
  {
    my($prog) = $type eq ".bz2" ? "bunzip2" : "gunzip";
    open(STDIN, "$prog |") || $prog eq "gunzip" && zfork || error("$prog: $!");
    binmode(STDIN) || error("binmode stdin: $!"); # perl 5.8.0 utf8 bug
    autoextractstdin;
    error;
  }

  error("unable to handle $type data in this context") if $type;
  error("unknown file type");
}

sub extractfile($$)
{
  my($infile, $outdir) = @@_;
  explain("extracting $infile");

  my($type) = magicfile($infile);
  my($pid) = fork;
  error("fork: $!") unless defined($pid);
  if($pid)
  {
    waitpid($pid, 0);
    error("extract subprocess returned $?")
        if $? && !($? == 256 && $type eq ".zip");
  }
  else
  {
    silentcd($outdir);
    safeexec("unzip", "-qo", $infile) if $type eq ".zip";
    if($type eq "script")
    {
      md("bin");
      writescript(path("bin", basename($infile)), readfile($infile));
      exit(0);
    }
    safeopen(*STDIN, "<", $infile);
    extractstdin($type);
    error;
  }
}

sub extractname($)
{
  my($file) = @@_;

  my($arg) = local($_) = $file;
  s/\.tgz$/.tar.gz/i;

  my($cmd, $ok) = ("", false);
  ($cmd, $arg) = ($cmd . "gunzip < $arg | ", "-") if s/\.gz$//i;
  ($cmd, $arg) = ($cmd . "bunzip2 < $arg | ", "-") if s/\.bz2$//i;
  ($cmd, $ok) = ($cmd . "tar tf $arg | ", true) if s/\.tar$//i;
  ($cmd, $ok) = ("unzip -Z1 $arg | ", true) if $arg eq $_ && s/\.zip$//i;
  return undef unless $ok;
  $cmd .= "head";

  explain($cmd);

  local(*SAVE);
  open(SAVE, "<&STDIN") || error("save stdin: $!");
  safeopen(*STDIN, "<", $file);
  my($result) = `$cmd`;
  open(STDIN, "<&SAVE") || error("restore stdin: $!");

  $result = undeftoempty($result);
  $result =~ s/[\r\n].*//;
  $result =~ s|/+$||;
  emptytoundef($result);
}

##############################################################################

sub allnames(;$)
{
  @@_ && defined($_[0]) ? @@_ : sort cmpab optls(pkgpath);
}

sub allversions($;$)
{
  my($name) = shift;
  @@_ && defined($_[0]) ? @@_ : sort cmpab grep { s/^v// } ls(pkgpath($name));
}

sub allbuilds($$;$)
{
  my($name, $version) = (shift, shift);
  @@_ && defined $_[0] ? @@_ : sort { $a<=>$b } grep { /^[1-9]\d*$/ }
      ls(pkgpath($name, $version));
}

##############################################################################

sub isname($)
{
  my($name) = @@_;
  defined($name) && -d(pkgpath($name));
}

sub isversion($$)
{
  my($name, $version) = @@_;
  defined($name) && defined($version) && -d(pkgpath($name, $version));
}

sub isbuild($$$)
{
  my($name, $version, $build) = @@_;
  defined($name) && defined($version) && defined($build) &&
      -d(pkgpath($name, $version, $build));
}

##############################################################################

sub latestversion($;$)
{
  my($name, $version) = @@_;
  lastitem(allversions($name, $version));
}

sub latestbuilt($$;$)
{
  my($name, $version, $build) = @@_;
  defined($name) || error;
  defined($version) || error;
  return undef unless isversion($name, $version);
  for $build (reverse(allbuilds($name, $version, $build)))
  {
    return $build if isbuiltmatch($name, $version, $build);
  }
  return undef;
}

##############################################################################

sub whilebuild(&@@)
{
  my($sub, $name, $version, $build, @@urls) = @@_;

  for $name (allnames($name))
  {
    for $version (allversions($name, $version))
    {
      for $build (allbuilds($name, $version, $build))
      {
        return false unless &$sub($name, $version, $build);
      }
    }
  }

  return true;
}

##############################################################################

sub isadded($$)
{
  my($name, $version) = @@_;
  return -d(pkgpath($name, $version));
}

sub isstored($$)
{
  my($name, $version) = @@_;
  return -d(path(pkgpath($name, $version), archivedir));
}

sub isbuilt(@@)
{
  my($name, $version, $build) = @@_;
  return isadded($name, $version) && !whilebuild
  {
    my($name, $version, $build) = @@_;
    return !-f(path(pkgpath($name, $version, $build), buildlog));
  } @@_;
}

sub isbroken($$$)
{
  my($name, $version, $build) = @@_;
  my($log) = path(pkgpath($name, $version, $build), brokenlog);
  return -f($log) ? $log : false;
}

sub isclean($$$)
{
  my($name, $version, $build) = @@_;
  return !-d(path(pkgpath($name, $version, $build), srcdir));
}

sub isbuildarmedin($$$$)
{
  my($armdir, $name, $version, $build) = @@_;
  $build || error;
  my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
  return -d($rootdir) && !dfs
  (
    $rootdir,
    sub { true },
    sub
    {
      my($rel) = @@_;
      my($armfile) = path($armdir, $rel);
      while(-e($armfile) || -l($armfile))
      {
        return false if optsamefile($_, $armfile);
        $armfile = addoff($armfile);
      }
      return true;
    },
    sub { true }
  );
}

sub allarmdirs(;$$$)
{
  my($name, $version, $build) = @@_;
  my(@@candidates);
  @@candidates = path(pkgpath($name, $version, $build), armdirlink)
      if defined($build);
  push(@@candidates, armdir, split(/:/, altarmdirs));
  my(@@armdirs, %seendi);
  for(@@candidates)
  {
    next if $_ eq "";
    my($armdir) = m!^/! ? $_ : path(storedir, $_);
    my($device, $inode) = stat($armdir);
    next unless defined($device);
    next unless -d(_);
    my($di) = "$device $inode";
    next if exists($seendi{$di});
    $seendi{$di} = true;
    push(@@armdirs, $armdir);
  }
  return @@armdirs;
}

sub isarmed(@@)
{
  return !whilebuild
  {
    my($name, $version, $build) = @@_;
    for (allarmdirs($name, $version, $build))
    {
      return false if isbuildarmedin($_, $name, $version, $build);
    }
    return true;
  } @@_;
}

sub isarmedmatch(@@)
{
  return isarmed(@@_) if !skipmismatched;
  return !whilebuild
  {
    my($name, $version, $build) = @@_;
    return !isbuildarmedin(armdir, $name, $version, $build);
  } @@_;
}

sub ismismatched($$$)
{
  my($name, $version, $build) = @@_;
  $build || error;
  my($armdirlink) = path(pkgpath($name, $version, $build), armdirlink);
  my($armdirisdir, $linkisdir) = (-d(armdir), -d($armdirlink));
  return !samefile($armdirlink, armdir) if $armdirisdir && $linkisdir;
  return true if !$armdirisdir && $linkisdir;
  my($target) = readlink($armdirlink);
  return false unless defined($target);
  return $target ne armdir;
}

sub isbuiltmatch(@@)
{
  return isbuilt(@@_) if !skipmismatched;
  my($name, $version, $build) = @@_;
  return !whilebuild
  {
    my($name, $version, $build) = @@_;
    return !isbuilt(@@_) || ismismatched($name, $version, $build);
  } @@_;
}

##############################################################################

sub lookslikepkgurl($;$;$)
{
  my($url, $name, $version) = @@_;
  return false unless $url =~ m!^(http|ftp)://.*/[^/]+\.[a-z][^/]+$!i;
  return false if $url =~ m/\#/;
  my($noquery) = stripquery($url);
  return false unless $noquery =~ m!\.\w+$!;
  return false if $noquery =~ m!\.(html?|php|txt|diff|gif|jpg|png|css|asc|sum|sig|sign|lsm|md5)(\.\w\w)?$!i;
  return true unless defined($name);
  my($basename) = basename($noquery);
  return false unless $basename =~ /\Q$name\E/i;
  return true unless defined($version);
  return false unless $basename =~ /\Q$version\E/i;
  return true;
}

sub findnewpkg($$)
{
  my($name, $version) = @@_;
  defined($name) || error;
  $name =~ /^[\w-]+$/ || error("invalid package name: $name");
  my($lcname) = lc($name);
  my($perlname) = $name;
  $perlname =~ s/-/::/g;
  my($sfname) = $lcname;
  $sfname = substr($sfname,0,1) . '/' . substr($sfname,0,2) . '/' . $sfname
      if length($sfname)>2;

  my(@@sites) =
  (
    "freshmeat" => "http://freshmeat.net/projects/$lcname",
    "googlecode" => "http://code.google.com/p/$lcname/downloads/list",
    "sourceforge" => "http://www.mirrorservice.org/sites/" .
        "download.sourceforge.net/pub/sourceforge/$sfname/",
    "gnu" => "http://ftp.gnu.org/gnu/$lcname/",
    "cpan" => "http://cpan.uwinnipeg.ca/module/$perlname",
  );

  my(%sites) = @@sites;
  my(@@all) = grep(/^\w+$/, @@sites);
  my(@@findsites) = split(/\s+/, findsites);
  @@findsites = map { ($_ eq "all") ? @@all : $_ } @@findsites;
  @@findsites = map { exists($sites{$_}) ? $sites{$_} : $_ } @@findsites;
  s/\*/$name/g for @@findsites;
  @@findsites = $myurl if $lcname eq $myname;
  @@findsites = uniq(@@findsites);

  my($url);
  for $url (@@findsites)
  {
    my(@@ret) = eval
    {
      my($tries) = 1;
      if($url =~ m!^http://(freshmeat.net)/projects/[^/]+$!)
      {
        local(*HTML, $_);
        my($sitename) = $1;
        openurl(*HTML, $url);
        my($notfound, $fmurl);
        while(<HTML>)
        {
          $notfound ||= /^404 Not Found/i;
          if(m!>Download</a>!i)
          {
            ($fmurl) = linksfromstring($_, $url);
            last;
          }
        }
        close(HTML) || error("unable to contact $sitename");

        error("no listing for package $name on $sitename")
            if $notfound && !$fmurl;
        $fmurl || error("no suitable URL for package $name on $sitename");

        my($redirhead) = httphead($fmurl);
        $redirhead =~ /^Location: ([^\r\n]+)/im ||
            error("unexpected response from $fmurl");
        $url = $1;
        # wget can't always get FTP directory listing w/o trailing slash
        $url .= "/" if $url =~ m!^ftp:.*/[^/\.]+$!; # e.g. atop
        $url = cleanurl($url);
        $tries = 3;
      }

      my(@@links) = $url;
      for(1..$tries)
      {
        $url = $links[$#links];
        @@links = sort cmpab grep(lookslikepkgurl(
            $_, defined($version) ? $name : undef, $version), @@links);
        my(@@result);
        for(@@links)
        {
          my($v) = $version;
          (undef, $v) = guessnv($_) unless defined($v);
          push(@@result, [$name, $v, undef, $_])
        }
        if(scalar(@@result) == 1)
        {
          eval { @@result = findnewerpkg(@@{$result[0]}) }
        }
        return @@result if @@result;
        last if lookslikepkgurl($url);

        @@links = linksfromurl($url);
        my(@@urls) = grep(lookslikepkgurl($_, $name, $version), @@links);
        my($ext);
        for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .deb .rpm])
        {
          my(@@matches) = grep(stripquery($_) =~ /\Q$ext\E$/i, @@urls);

          my(@@namematches) =
              grep { my($n) = guessnv($_); lc($n) eq lc($name) } @@matches;
          @@matches = @@namematches if @@namematches;

          if(defined($version))
          {
            my(@@vermatches) =
                grep { my(undef, $v) = guessnv($_); $v eq $version } @@matches;
            @@matches = @@vermatches if @@vermatches;
          }

          @@matches = sort cmpab @@matches;
          @@result = ();
          for(@@matches)
          {
            my($undef, $v) = guessnv($_);
            push(@@result, [$name, $v, undef, $_]);
          }
          return @@result if @@result;
        }

        @@links = grep(/^\Q$url\E/, @@links);
        last unless @@links;
      }
    };

    return @@ret if !$@@ && @@ret && $ret[0];
    explain($_) for(split(/\n/, $@@));
  }

  error("can't find " . pkgname($name, $version));
}

sub pkgurls($$)
{
  my($name, $version) = @@_;
  defined($name) || error;
  defined($version) || error;
  my($urlfile) = path(pkgpath($name, $version), urlfile);
  return () unless -r($urlfile);
  return map { chomp; $_ } readfile($urlfile);
}

sub setpkgurls($$@@)
{
  my($name, $version, @@urls) = @@_;
  error unless defined($name);
  error unless defined($version);
  error unless @@urls;

  my($verdir) = pkgpath($name, $version);
  my($urlfile) = path($verdir, urlfile);
  my($tmpfile) = addtmp($urlfile);
  writefile($tmpfile, map("$_\n", @@urls));
  mv($tmpfile, $urlfile);
}

sub choose($@@)
{
  my($curver, @@pkgs) = @@_;
  return @@pkgs unless scalar(@@pkgs) > 1 && interactive;
  my(@@allurls);
  for(@@pkgs)
  {
    my($name, $version, $build, @@urls) = @@$_;
    error unless @@urls;
    push(@@allurls, @@urls);
  }
  error unless @@allurls;
  my($pl, $sl) = (commonlen(@@allurls), commonlen(reverseall(@@allurls)));
  print(substr($allurls[0], 0, $pl), " [...] ", substr($allurls[0], -$sl), "\n")
      if $pl || $sl;
  my($i, $cvi) = (0, 0);
  for(@@pkgs)
  {
    ++$i;
    my($name, $version, $build, @@urls) = @@$_;
    my($margin) = "   ";
    ($cvi, $margin) = ($i, "0) ")
        if !$cvi && $curver && $version && $curver eq $version;
    print("$margin$i) ",
        join(" ", map(substr($_, $pl, $sl ? -$sl : 9999), @@urls)), "\n");
  }
  my($choice) = "";
  while(!($choice =~ /^\d+$/ && $choice > 0 && $choice <= $i))
  {
    print("> [$i] ");
    $choice = scalar(<STDIN>);
    error("EOF") unless defined($choice);
    $choice =~ s/\s+//g;
    $choice = $i if $choice eq "";
    $choice = $cvi if $choice eq "0";
  }
  return $pkgs[$choice-1];
}

##############################################################################

sub add(@@)
{
  my($name, $version, $build, @@urls) = @@_;

  $build && error;
  $name || @@urls || error;

  if(!@@urls && autofind)
  {
    my(@@pkgs) = reverse(choose(undef, findnewpkg($name, $version)));
    error unless @@pkgs;
    ($name, $version, undef, @@urls) = @@{$pkgs[0]};
    error unless $name;
    error unless @@urls;
  }

  @@urls || error("autofind is disabled; please specify URL(s) for " .
      pkgname($name, $version));

  $name = "unknown" unless defined($name);
  my($namedir) = pkgpath($name);
  optmd(storedir, pkgpath, $namedir);

  my($goodver) = defined($version);
  $version = "unknown" unless $goodver;
  my($verdir) = pkgpath($name, $version);

  if($goodver)
  {
    if(!-d($verdir))
    {
      md($verdir);
    }
    else
    {
      my(@@existingurls) = pkgurls($name, $version);
      if(samelist(@@urls, @@existingurls))
      {
        explain(pkgname($name, $version) .
            " exists with matching urls; treating as successfully added");
        return($name, $version);
      }
      else
      {
        error(pkgname($name, $version) . " exists with conflicting urls:\n  " .
            join("\n  ", @@existingurls));
      }
    }
  }
  else
  {
    my($max, $errmsg) = (-1, true);
    while($errmsg)
    {
      local($_);
      for(allversions($name))
      {
        $max = max($max, $1 || 0) if /^unknown(\d*)$/;
      }
      if($max >= 0)
      {
        $version = "unknown" . ($max + 1);
        $verdir = pkgpath($name, $version);
      }
      $errmsg = mkdir($verdir, 0777) ? false : $!;
      error("mkdir $verdir: $errmsg") if $errmsg && !-d($verdir);
    }
    announce("mkdir", $verdir);
  }

  setpkgurls($name, $version, @@urls);

  setactivepkg($name, $version);
  ($name, $version, @@urls);
}

##############################################################################

sub smartgeturl($$)
{
  my($url, $dir) = @@_;

  if($url =~ m!^cvsroot(\+ssh)?:(.+)/([^/]+)\#(\d+)$!)
  {
    my($usessh, $cvsroot, $module, $time) = ($1, $2, $3, $4);
    announce("export CVS_RSH=ssh") if $usessh;
    local($ENV{CVS_RSH}) = "ssh" if $usessh;
    my($moddir) = path($dir, $module);
    optmd($moddir);
    chownnonroot($moddir);
    cdrunnonroot($dir, "cvs", (quiet ? "-Q" : "-q"),
        "-d", $cvsroot, "co", "-D", "\@@$time", $module);
    cdrun($dir, qw(tar czf), "$module.tar.gz", $module);
    rmall($moddir);
    return $url;
  }

  if($url =~ m!^git:([^#]+)(\#([^\-]\S*))?$!)
  {
    error("bad git url: $url") if $2 && !$3;
    my($repo, $rev) = ($1, $3);
    $repo = "git:$repo" if $repo =~ m!^//!;
    my($commit) = $rev || "";
    $commit =~ s/^\d+\#//;
    my($tmpdir) = path($dir, "toast.git.d");
    my($subdir) = path($tmpdir, "repo");
    md($tmpdir);
    chownnonroot($tmpdir);
    cdrunnonroot($tmpdir, qw[git clone -q --], $repo, "repo");
    if($commit ne "")
    {
      cdrunnonroot($subdir, qw[git reset --hard -q], $commit);
    }
    else
    {
      cdrunnonroot($subdir, "git rev-list --timestamp -n 1 HEAD > ../rev");
      my(@@revlist) = readfile(path($tmpdir, "rev"));
      error("trouble parsing git rev-list") unless scalar(@@revlist) == 1 &&
          $revlist[0] =~ /^(\d+) (\w+)$/;
      $rev = "$1#$2";
      $url .= "#$rev";
    }
    rmall(path($subdir, ".git"));
    my($name) = basename($repo);
    $name = $name eq "." ? $rev : "$name-$rev";
    $name =~ s/#/./g;
    cdrun($subdir, qw(tar czf), "../../$name.tar.gz", ".");
    rmall($tmpdir);
    return $url;
  }

  my(%visited);
  for(1..5)
  {
    my($basename) = basename(stripquery($url));
    $basename = "index" if $basename eq "";
    my($file) = path($dir, $basename);

    my($newurl) = geturl($url, $file);
    $visited{$url} = 1;

    local(*FILE);
    safeopen(*FILE, "<", $file);
    my($header);
    read(FILE, $header, 128) || error("read $file: $!");
    my($redir);
    if($header =~ /^\<.*\bHTML\b/i)
    {
      seek(FILE, 0, 0) || error("rewind $file: $!");
      my(@@links) = reverse(sort cmpab linksfromstream(*FILE, $newurl));
      my(@@goodlinks) = grep(/\.tar\./, @@links);
      @@goodlinks = grep(!/\.(s?html?|php)$/i, @@links) unless @@goodlinks;
      @@links = @@goodlinks if @@goodlinks;
      for (@@links)
      {
        $redir = $_ if !$redir && basename(stripquery($_)) eq $basename
            && !$visited{$_};
      }
      my($ext);
      for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .deb .rpm])
      {
        for (@@links)
        {
          $redir = $_ if !$redir && stripquery($_) =~ /\Q$ext\E$/i
              && !$visited{$_};
        }
      }
      error("no more links to try") unless $redir;
    }
    close(FILE) || error("close $file: $!");

    return $url unless $redir;

    rm($file);
    $url = $redir;
    error if $visited{$url};
  }

  error("too many links: $url");
}

sub renamepkg($$$$)
{
  my($oldname, $oldversion, $newname, $newversion) = @@_;

  my($oldnamedir) = pkgpath($oldname);
  my($newnamedir) = pkgpath($newname);
  my($oldverdir) = pkgpath($oldname, $oldversion);
  my($newverdir) = pkgpath($newname, $newversion);

  optmd($newnamedir);
  mv($oldverdir, $newverdir);
  rmdir($oldnamedir) && announce("rmdir", $oldnamedir);
  return ($newname, $newversion);
}

sub autorenamepkg($$@@)
{
  my($name, $version, @@urls) = @@_;

  if(@@urls)
  {
    my($newname, $newversion) = guessnv(@@urls);
    return renamepkg($name, $version, $newname, $newversion)
        if defined($newname) && defined($newversion);
  }

  my($verdir) = pkgpath($name, $version);
  my($archivedir) = path($verdir, archivedir);

  local($_);
  for(absls($archivedir))
  {
    my($extractname) = extractname($_);
    next unless defined($extractname);

    my($newname, $newversion) = guessnv($extractname);
    return renamepkg($name, $version, $newname, $newversion)
        if defined($newname) && defined($newversion);
  }

  ($name, $version);
}

sub get(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  my($autorename) = @@urls && !defined($version) && autorename;

  ($name, $version, @@urls) = add(@@_) if @@urls || !isadded($name, $version);

  $build && error;
  defined($name) || error;
  defined($version) || error;

  @@urls = pkgurls($name, $version) unless @@urls;

  return ($name, $version, @@urls) if isstored($name, $version);

  my($verdir) = pkgpath($name, $version);
  my($realdir) = path($verdir, archivedir);
  my($tempdir) = addtmp($realdir);

  optmd($tempdir);

  my($changed) = false;
  for(@@urls)
  {
    my($newurl) = smartgeturl($_, $tempdir);
    if($newurl ne $_ && (/^git:/ || autochange))
    {
      $_ = $newurl;
      $changed = true;
    }
  }
  setpkgurls($name, $version, @@urls) if $changed;

  mv($tempdir, $realdir);
  ($name, $version) = autorenamepkg($name, $version, $changed ? @@urls : ())
      if $autorename;

  ($name, $version, @@urls);
}

##############################################################################

sub exprecedence($)
{
  local($_) = @@_;
  /\.(patch|diff)\b/i;
}

sub excmp($$)
{
  my($a, $b) = @@_;
  exprecedence($a) - exprecedence($b) || $a cmp $b;
}

sub extract($$)
{
  my($indir, $outdir) = @@_;
  my(@@infiles) = absls($indir);
  @@infiles || error("$indir is empty");
  extractfile($_, $outdir) foreach sort { excmp($a, $b) } @@infiles;
}

sub makedir($)
{
  my($dir) = @@_;
  my($subdir);
  my($ok) = whiledir
  {
    my($abs) = path($dir, $_);
    return false unless -d($abs);
    return true if -l($abs); # e.g. xcircuit 3.6.19
    return true if $_ eq "CVS";
    return false if defined($subdir);
    $subdir = $abs;
    return true;
  } $dir;
  error("empty directory: $dir") if $ok && !defined($subdir);
  return $ok ? &makedir($subdir) : $dir;
}

sub quote($)
{
  local($_) = undeftoempty(@@_);
  s/\\/\\\\/g;
  s/'/\\'/g;
  "'$_'";
}

sub cquote($)
{
  local($_) = @@_;
  s/\\/\\\\/g;
  s/"/\\"/g;
  "\"$_\"";
}

sub helpstub($$)
{
  my($helperdir, $cmd) = @@_;
  my($path) = quote($ENV{PATH});
  writescript(path($helperdir, $cmd),
      "#!/bin/sh\nPATH=$path\nexec $cmd \"\$\@@\"\n");
}

sub helpnop($$)
{
  my($helperdir, $cmd) = @@_;
  helpstub($helperdir, $cmd);
  writescript(path($helperdir, "$cmd.helper"), "#!/bin/sh\ntrue\n");
}

sub helprewrite($$$$$)
{
  my($srcdir, $rootdir, $helperdir, $cmd, $force) = @@_;
  helpstub($helperdir, $cmd);
  writescript(path($helperdir, "$cmd.helper"), "#!/bin/sh\n# $genby\n", q[

exec perl -x $0 ${1+"$@@"}
echo "Can't find perl in PATH; aborting." >&2
exit 1

#!perl
$cmd = ], quote($cmd), q[;
$srcdir = ], quote($srcdir), q[;
$rootdir = ], quote($rootdir), q[;
$armdir = ], quote(armdir), q[;
$path = ], quote($ENV{PATH}), q[;
$preload = ], quote($ENV{LD_PRELOAD}), q[;
$myname = ], quote($myname), q[;

# cleanse environment
$ENV{PATH} = $path;
if($preload eq "")
{
  delete($ENV{LD_PRELOAD});
}
else
{
  $ENV{LD_PRELOAD} = $preload;
}

# save old arguments
@@oldargs = @@ARGV;

# compute new arguments
my($dashp) = $cmd eq "mkdir"; # force mkdir -p
while(@@ARGV)
{
  $_ = shift(@@ARGV);
  $dashp &&= $_ ne "-p";
  if($cmd eq "install" && /^-(o|-owner|g|-group)$/)
  {
    $rewritten = 1;
    shift(@@ARGV);
  }
  else
  {
    if(m|^/| && !m!^(\Q$srcdir\E|\Q$rootdir\E)($|/)! &&
        (s!^\Q$armdir\E($|/)!$1! || !m!^/(dev|proc|tmp)($|/)!))
    {
      $rewritten = 1;
      my($dir, $elem) = "";
      for $component (split(/\//, $_))
      {
        $dir ne "" && mkdir("$rootdir$dir", 0777) &&
            print("$myname: created directory $rootdir$dir\n");
        $dir .= "/$component";
      }
      -d("$armdir$_") && mkdir("$rootdir$_", 0777) &&
          print("$myname: created directory $rootdir$_\n");
      $_ = "$rootdir$_";
    }
    push(@@newargs, $_);
  }
}
if($dashp)
{
  $rewritten = 1;
  unshift(@@newargs, "-p");
}

# print and execute real command
print("$myname: rewriting $cmd @@oldargs -> $cmd @@newargs\n") if $rewritten;
], $force ? q[
# return success, even if command returns failure
system($cmd, @@newargs) == -1 && die("system $cmd: $!");
exit(0);
] : q[
# allow command to fail
exec($cmd, @@newargs);
die("exec $cmd: $!");
]);
}

sub helphspkg($$$)
{
  my($rootdir, $helperdir, $cmd) = @@_;
  return true unless hspkg;
  helpstub($helperdir, $cmd);
  writescript(path($helperdir, "$cmd.helper"), "#!/bin/sh\n# $genby\n", q[
rootdir=], quote($rootdir), q[
name=], time() . "-$$", q[
PATH=], quote($ENV{"PATH"}), q[

ghc-pkg "$@@" --user # let --auto-ghci-libs do its thing

for arg; do
  case "$arg" in
    -*) ;;
    *) [ -r "$arg" ] && exec < "$arg" ;;
  esac
done

exec cat > "$rootdir/hspkg/$name"
]);
}

sub helpccache($$$)
{
  my($rootdir, $helperdir, $cmd) = @@_;
  return true unless ccache && optwhich("ccache");

  my $qpath = quote($ENV{"PATH"});
  for($cmd, "$cmd.helper")
  {
    writescript(path($helperdir, $_), qq[#!/bin/sh
# $genby
PATH=$qpath
exec ccache $cmd "\$\@@"
]);
  }
}

sub helplib($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;

  return undef unless preload;

  my($defdebug) = "#define DEBUG stderr";
  $defdebug = "/* $defdebug */" unless debugrewrite;

  my($code) = qq[/* $genby */

#define _GNU_SOURCE

#include <dlfcn.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>

#ifdef __CYGWIN__
#ifndef RTLD_NEXT
#define RTLD_NEXT ((void *) -1L)
#endif
#endif

#ifndef DEBUG
$defdebug
#endif

struct timeval; /* to match the utimes() prototype that SunOS pulls in... */

#ifdef DEBUG
pid_t getpid(void);
#define debug(fmt, args...) do { fprintf(DEBUG, "$myname: pid %u: " fmt "\\n", (unsigned)getpid(), ## args); fflush(DEBUG); } while(0)
#else
#define debug(fmt, args...) ((void)0)
#endif

#define BUFSIZE 4096

static const char *srcdir = ] . cquote($srcdir) . qq[;
static const char *rootdir = ] . cquote($rootdir) . qq[;
static const char *helperdir = ] . cquote($helperdir) . qq[;
static const char *armdir = ] . cquote(armdir) . qq[;

static int startswith(const char *s, const char *prefix)
{
  int len = strlen(prefix);
  int result = strncmp(s, prefix, len) == 0 && (s[len] == 0 || s[len] == '/');
  /* debug("startswith(%s, %s) = %d", s, prefix, result); */
  return result;
}

static const char *check_strip_armdir(const char *pathname)
{
  if(!pathname)
  {
    debug("NULL pathname");
    return 0;
  }
  else if(pathname[0] != '/')
  {
    debug("relative pathname: %s", pathname);
    return 0;
  }
  else if(startswith(pathname, srcdir))
  {
    debug("pathname in srcdir: %s", pathname);
    return 0;
  }
  else if(startswith(pathname, rootdir))
  {
    debug("pathname in rootdir: %s", pathname);
    return 0;
  }
  else if(startswith(pathname, helperdir))
  {
    debug("pathname in helperdir: %s", pathname);
    return 0;
  }
  else
  {
    if(startswith(pathname, armdir))
    {
      debug("pathname in armdir: %s", pathname);
      pathname += strlen(armdir);
      debug("stripping armdir: %s", pathname);
    }
    else if(startswith(pathname, "/dev"))
    {
      debug("pathname in /dev: %s", pathname);
      return 0;
    }
    else if(startswith(pathname, "/proc"))
    {
      debug("pathname in /proc: %s", pathname);
      return 0;
    }
    else if(startswith(pathname, "/tmp"))
    {
      debug("pathname in /tmp: %s", pathname);
      return 0;
    }

    if(BUFSIZE < strlen(rootdir) + strlen(pathname) + 1)
    {
      debug("pathname is too long: %s", pathname);
      return 0;
    }
    else
    {
      debug("pathname is rewritable: %s", pathname);
      return pathname;
    }
  }
}

static int real_mkdir(const char *pathname, int mode);

static void mkparents(const char *pathname)
{
  const char *stripped = check_strip_armdir(pathname);
  if(!stripped)
  {
    debug("not creating parents for %s", pathname);
  }
  else
  {
    int saved_errno = errno;
    char buf[BUFSIZE];
    char *p = buf + strlen(rootdir);
    int done = 0;

    memset(buf, 0, sizeof(buf));
    strcpy(buf, rootdir);

    while(!done)
    {
      do
      {
        *(p++) = *(stripped++);
        done = done || !*stripped;
      } while(!done && *stripped != '/');

      if(!done)
      {
        int ret = real_mkdir(buf, 0755) != 0;
        if(ret == -1)
        {
          debug("can't create parent directory %s", buf);
        }
        else
        {
          debug("created parent directory %s", buf);
        }
      }
    }

    errno = saved_errno;
  }
}

static const char *rewrite(const char *pathname, char *buffer)
{
  const char *stripped = check_strip_armdir(pathname);

  if(!stripped)
  {
    debug("not rewriting pathname %s", pathname);
    return pathname;
  }
  else
  {
    strcpy(buffer, rootdir);
    strcat(buffer, stripped);
    debug("rewriting %s -> %s", pathname, buffer);
    return buffer;
  }
}

];

  my(@@decls) = split(/;/, q[
    wrap FILE *fopen(const char *pathname, const char *mode);
    wrap FILE *freopen(const char *pathname, const char *mode, FILE *file);
    wrap void *opendir(const char *pathname);
    wrap void *dlopen(const char *pathname, int flag);
    wrap int creat(const char *pathname, int flags);
    wrapva int open(const char *pathname, int flags, int mode);
    wrap int access(const char *pathname, int flags);
    wrap int chdir(const char *pathname);
    wrap int xstat(int version, const char *pathname, void *foo);
    wrap int lxstat(int version, const char *pathname, void *foo);
    wrap int readlink(const char *pathname, char *buf, int size);
    wrap int link(const char *pathname1, const char *pathname2);
    wrap int symlink(const char *pathname1, const char *pathname2);
    wrap0 int mkdir(const char *pathname, int mode);
    wrap int rmdir(const char *pathname);
    wrap int chmod(const char *pathname, int mode);
    wrap0 int rename(const char *pathname1, const char *pathname2);
    wrap0 int unlink(const char *pathname);
    wrap int utime(const char *pathname, void *foo);
    wrap int utimes(const char *pathname, const struct timeval *tvp);
    wrap int execve(const char *pathname, void *foo1, void *foo2);
    suppress int chown(const char *pathname, int user, int group);
    suppress int lchown(const char *pathname, int user, int group);
    suppress int fchown(int fd, int user, int group);
    suppress int getuid();
    suppress int geteuid();
  ]);

  for(@@decls)
  {
    s/\s+//;
    next unless $_;
    /^(wrap|wrap0|wrapva|suppress) (int |\w+ \*)(\w+)\((.*)\)$/ || error;
    my($iswrap, $rettype, $basename, $proto) = ($1 ne "suppress", $2, $3, $4);
    # wrapped dlopen() always fails with "Service not available" in FreeBSD (?)
    next if $basename eq "dlopen" && $^O eq "freebsd";
    my($iswrap0) = $1 eq "wrap0";
    my($iswrapva) = $1 eq "wrapva";
    my($ptrproto) = $proto;
    $ptrproto =~ s/int mode/.../ or error if $iswrapva;
    my($retfailed, $retfmt) = $rettype =~ /\*/ ? (0, '%p') : (-1, '%d');
    my(@@alist) = map { /\w+$/ ? $& : error } split(/, /, $proto);
    my($args) = join(", ", @@alist);
    my($newargs) = join(", ", map { /pathname/ ?
        "rewrite($_, rewritten_$_)" : $_ } @@alist);
    my($buffers) = join(", ", map("rewritten_${_}[BUFSIZE]",
        grep(/pathname/, @@alist)));
    my($allrewritable) = join(" && ", map("check_strip_armdir($_)",
        grep(/pathname/, @@alist)));
    my($destarg) = $proto =~ /pathname2/ ? "pathname2" : "pathname";

    my($nameprefix, $namesuffix);
    for $nameprefix ("", "_", "__")
    {
      for $namesuffix ("", "64")
      {
        my($name) = "$nameprefix$basename$namesuffix";
        $code .= $iswrap ? qq[
static ${rettype}real_$name($proto)
{
  $rettype(*next_$name)($ptrproto) = dlsym(RTLD_NEXT, "$name");
  debug("invoking next_$name = %p", next_$name);
  return next_$name($args);
}

$rettype$name($proto)
{
  ${rettype}result;
  char $buffers;

  debug("rewriting $name");

  mkparents($destarg);

  result = real_$name($newargs);
  debug("rewritten $name returned $retfmt", result);

  if(result == $retfailed)
  {
    debug("retrying $name with original args");
    result = real_$name($args);
    debug("original $name returned $retfmt", result);
  }
] . ($iswrap0 ? qq[
  if(result == $retfailed && $allrewritable)
  {
    debug("suppressing $name");
    result = 0;
    errno = 0;
  }
] : "") . qq[
  return result;
}
] : qq[
$rettype$name($proto)
{
  debug("suppressing $name");
  return 0;
}
];
      }
    }
  }

  my($so, $do, $cc, $ld, $libs) =
      ("so", ".o", "gcc -fPIC", "gcc -shared", "-ldl");
  eval q{
    use Config;
    $so = $Config{"dlext"} or die;
    $do = $Config{"_o"} or die;
    $libs = "" unless $Config{"libs"} =~ /-ldl\b/;
    $cc = "$Config{cc} $Config{cccdlflags}";
    $ld = "$Config{ld} $Config{lddlflags}";
    $cc .= " -Wall -Werror" if $Config{ccname} eq "gcc" && strictpreload;
  };

  writefile(path($helperdir, "dummy.c"), "void ____toast_dummy_4u38291(){}\n");
  writefile(path($helperdir, "rewrite.c"), $code);

  return path($helperdir, "rewrite.$so")
      if optcdrun($helperdir, "$cc -c dummy.c -o dummy$do")
      && optcdrun($helperdir, "$ld dummy$do -o rewrite.$so")
      && optcdrun($helperdir, "$cc -c rewrite.c -o rewrite$do")
      && optcdrun($helperdir, "$ld rewrite$do -o rewrite.$so.helper $libs");

  error("unable to compile with strictpreload enabled") if strictpreload;
  explain("unable to compile; strictpreload disabled, continuing");
  return undef;
}

sub helphome($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;

  my($makehome) = path($helperdir, "home");
  my($installhome) = path($helperdir, "home.helper");
  md($makehome, $installhome);

  my($makedir) = makedir($srcdir);
  my($scriptdir) = path($installhome, "bin");
  my($script) = path($scriptdir, "installkernel");
  my($kbase) = "vmlinuz";
  my($mbase) = "System.map";
  my($kernel) = path($rootdir, "boot", $kbase);
  my($map) = path($rootdir, "boot", $mbase);

  md($scriptdir);
  writescript($script, qq[#!/bin/sh
# script to be run by Linux kernel Makefile install target
# $genby
set -e
set -x
cat \$2 > $kernel
cp \$3 $map
ln -s $kbase $kernel-\$1
ln -s $mbase $map-\$1
]);

  return $makehome;
}

sub inithelpers($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;
  my(%env) = %ENV;

  md($helperdir);

  helprewrite($srcdir, $rootdir, $helperdir, $_, false)
      for (qw[mkdir rmdir touch cp rm ln install chmod test ranlib gzip
      xmlcatalog pkg-config gcc], "[");
  helprewrite($srcdir, $rootdir, $helperdir, $_, true) for (qw[mv]);
  helpnop($helperdir, $_) for (qw[chown chgrp ldconfig install-info mknod]);
  helphspkg($rootdir, $helperdir, $_) for (qw[ghc-pkg]);
  helpccache($rootdir, $helperdir, $_) for (qw[cc gcc g++]);
  $env{PATH} = "$helperdir:$env{PATH}";

  my($preload) = helplib($srcdir, $rootdir, $helperdir);
  if($preload)
  {
    if(exists($env{LD_PRELOAD}) && length($env{LD_PRELOAD}))
    {
      $env{LD_PRELOAD} .= " $preload";
    }
    else
    {
      $env{LD_PRELOAD} = $preload;
    }
  }

  $env{HOME} = helphome($srcdir, $rootdir, $helperdir);

  %env;
}

sub armhelpers($)
{
  my($helperdir) = @@_;
  my(@@files) = absls($helperdir);
  /\.helper$/ ? mv($_, $`) : mv($_, "$_.stub") foreach sort(@@files);
}

sub makefile($)
{
  my($dir) = @@_;
  for(qw[GNUmakefile makefile Makefile])
  {
    my($file) = path($dir, $_);
    return $file if -r($file);
  }
  return false;
}

sub splitwords($)
{
  my($s) = @@_;
  $s =~ s/^\s+//;
  my(@@words);
  while($s =~ s/^"((\\.|[^"])*)"//s || $s =~ s/^'((\\.|[^'])*)'//s ||
      $s =~ s/^((\\.|\S)+)//s)
  {
    push(@@words, $1);
    $s =~ s/^\s+//;
  }
  error("unbalanced quotes") unless $s eq "";
  return @@words;
}

sub cdrunconf($@@)
{
  my($dir, @@prog) = @@_;
  cdrun($dir, @@prog, splitwords(confappend));
}

sub configure($$)
{
  my($dir, $prefix) = @@_;

  # Haskell Cabal (http://www.haskell.org/cabal/)
  # Must be checked for before "configure" due to the following craziness:
  # http://haskell.org/ghc/docs/6.4/html/Cabal/authors.html#system-dependent
  for("Setup.hs", "Setup.lhs")
  {
    if(-r(path($dir, $_)))
    {
      cdrun($dir, qw(ghc-pkg list)); # work around ~/.ghc bug in ghc-pkg 6.4 (?)
      cdrunconf($dir, "runghc", $_, "configure", "--prefix=$prefix",
          "--with-hc-pkg=ghc-pkg");
      writefile
      (
        path($dir, "Makefile"),
        "# $genby\n\n",
        "all:\n\trunghc $_ build\n\n",
        "install:\n\trunghc $_ copy --copy-prefix=\$(DESTDIR)\n",
        qq{\tout="`runghc $_ register 2>&1`"; echo "\$\$out"; [ \$\$? = 0 -o },
        qq{"\$\$out" = "$_: Package contains no library to register" ]\n},
      );
      return $dir;
    }
  }

  # find a configure script
  my($cfg);
  #            autoconf  Perl          openssl elm       libmng     pmk
  for $cfg (qw[configure configure.gnu config  Configure autogen.sh pmkcfg.sh])
  {
    my($confprog) = path($dir, $cfg);
    next if -d($confprog);
    next unless -x($confprog) || (-r($confprog) && $confprog =~ /\.sh$/);

    my($self) = false;
    my($builddir) = false;
    my($bogus) = false;
    my($twowordprefix) = false;
    my($noprefix) = false;
    my($mozilla) = false;
    my(%confopts);

    my($opensslcfg) = path($dir, "Configure");
    if(reconfigure && $cfg eq "config" && -x($opensslcfg))
    {
      whilefile
      {
        !($confopts{"shared"} ||= /^# \[no-\]shared\s/);
      } $opensslcfg;
    }

    patch
    {
      $self ||= /this is toast 89a72ef9c34e1fd4927afa36c9be8b15/;
      $twowordprefix ||= /^\s*prefix=\$2; shift;;$/; # ocaml
      $twowordprefix ||= /  --prefix dir  /; # doxygen
      $builddir ||= /error: you must configure in a separate build/; # glibc
      $builddir||=m!\. \$srcdir/build-tools/scripts/configure-top !;#arch/tla
      $builddir ||= /Building in the source directory is not support/; # gcc 4
      $bogus ||= /There is no .+configure.+ script .+Instead/i; # libpng
      $bogus ||= /configure is no longer used - just type /i; # cdrtools
      s/(^\s*)read\s+(acceptance)(\s*$)/$1$2=yes$3/; # qt license
      s/^if test ! -t 0; /if false; /; # elm
      $noprefix = $confopts{"-d"} = 1 if /^\s*-d\) shift; fastread='y/; # elm
      $noprefix ||= /elif \[ x.sysname = x \]; then/; # isc dhcp
      if(reconfigure)
      {
        s/^\s*AUTOTHREAD=no\s+\#+ leave off for now/\#$&/; # qt multithreaded
        $mozilla = $1 if /(--enable-default-toolkit)=TK/;
        my($opt); # glibc; libjpeg; tetex; others?
        for $opt ("enable-add-ons", # glibc
            "enable-shared", # various
            "with-shared", # ncurses
            "disable-multiplatform") # tetex
        {
          $confopts{"--$opt"} ||= / \Q--$opt\E\b($|[^-])/;
        }
        $confopts{$1} = 1 if /"configure (-\S+)"; by default a static/;#zlib
      }
    } $confprog;
    $noprefix ||= -x(path($dir, "installnetpbm")); # netpbm 10.19
    if($mozilla)
    {
      local($^W) = false; # suppress misguided exec failure warning
      $confopts{"$mozilla=gtk2"} ||= system(qw(pkg-config gtk+)) == 0;
    }

    my(@@confcmd) = ("./$cfg", "--prefix=$prefix");
    if(!$self)
    {
      next if $bogus;
      @@confcmd = ("./$cfg", "--prefix", $prefix) if $twowordprefix;
      @@confcmd = ("./$cfg") if $noprefix;
      push(@@confcmd, sort(grep($confopts{$_}, keys(%confopts))));
      unshift(@@confcmd, "sh") unless -x($confprog);
      if($builddir)
      {
        $confcmd[0] = "../$cfg";
        $dir = path($dir, "$myname-build.d");
        md($dir);
      }
      elsif($cfg eq "configure.gnu")
      {
        # force perl to install files it thinks are already installed
        # (5.8.2 and later support DESTDIR and should no longer need this)
        optpatch { s/^use File::Compare;$/sub compare(\$\$){1}; #$genby/ }
            path($dir, "installperl");
      }
    }

    my($amhelper) = path($dir, "install-sh");
    if(-l($amhelper) && !-r($amhelper)) # e.g. sgml-common/0.6.3
    {
      optcdrun($dir, "aclocal");
      optcdrun($dir, "automake", "-acf");
      optcdrun($dir, "autoconf", "-f");
    }

    cdrunconf($dir, @@confcmd);
    return $dir;
  }

  # Construct a Makefile to invoke setup.py on behalf of various Python source
  # packages (e.g. BitTorrent, Cython):
  if(-r(path($dir, "setup.py")))
  {
    $dir = path($dir, "setup.py.toast.d");
    md($dir);
    writefile
    (
      path($dir, "Makefile"),
      "# $genby\n\n",
      "all:\n\tcd .. && python setup.py build\n\n",
      "install:\n\tcd .. && python setup.py install " .
          "--prefix=\Q$prefix\E --root=\$(DESTDIR)\n",
    );
    return $dir;
  }

  for(qw[build_unix build.unix]) # e.g. Sleepycat DB and nvi, respectively
  {
    my($bubuilddir) = path($dir, $_);
    my($buconfprog) = path($dir, "dist", "configure");
    return $bubuilddir if -d($bubuilddir) && -x($buconfprog) &&
        cdrunconf($bubuilddir, "../dist/configure", "--prefix=$prefix");
  }

  # configure script might be hidden in a "source" subdirectory (samba, tcl/tk)
  for(qw[source src unix])
  {
    my($subdir) = path($dir, $_);
    my($confprog) = path($subdir, "configure");
    return &configure($subdir, $prefix) if -x($confprog);
  }

  # if this XFree86, we have to set ProjectRoot in xc/config/cf/site.def...
  optpatch { s!(\#\s*define\s+ProjectRoot\s+)(/usr/X\S+)!$1$prefix!; }
      path($dir, qw[config cf site.def]);

  # if there's a Makefile, just use that
  return $dir if makefile($dir);

  # OK, how about an Imakefile?
  my($imf) = path($dir, "Imakefile");
  if(-r($imf))
  {
    my($xaw3d); # cajole standalone Xaw3d build
    patch
    {
      $xaw3d = 0 if $xaw3d && s/^XCOMM\s+//;
      $xaw3d = 1 if !defined($xaw3d) && /^XCOMM When.*outside an X11 source t/;
    } $imf;
    if(defined($xaw3d))
    {
      md(path($dir, "X11"));
      ln("..", path($dir, "X11", lastitem(unpath($dir))));
    }
    cdrunconf($dir, "xmkmf");
    return $dir;
  }

  # perl modules have a Makefile.PL script that spits out a Makefile
  my($mfpl) = path($dir, "Makefile.PL");
  return $dir if -r($mfpl) && cdrunconf($dir, "perl", $mfpl);

  # pmk is some kind of newfangled autoconf replacement
  my($pmkfile) = path($dir, "pmkfile");
  return $dir if -r($pmkfile) && cdrunconf($dir, "pmk");

  # qmake is a similar tool that comes with Qt
  my(@@profiles) = grep(/\.pro$/i, ls($dir));
  return $dir if scalar(@@profiles)==1&& cdrunconf($dir, "qmake", $profiles[0]);

  # Write a custom Makefile for glibc with add-ons and/or kernel headers.
  my($glibcdir, $hdrdir, @@addons);
  my($glibcok) = whiledir
  {
    push(@@addons, $_);
    my($abs) = path($dir, $_);
    return false if !-d($abs) || -l($abs);
    if(-r(path($abs, qw[include linux kernel.h])))
    {
      $hdrdir = $abs;
      pop(@@addons);
      return true;
    }
    my($cfg) = path($abs, "configure");
    if(-r($cfg))
    {
      return true if whilefile { /^\s*(\#|exit|$)/ } $cfg;
      return false if $glibcdir;
      $glibcdir = $abs;
      pop(@@addons);
    }
    true;
  } $dir;
  if($glibcok && (@@addons || $hdrdir) && $glibcdir)
  {
    mv(path($dir, $_), path($glibcdir, $_)) foreach @@addons;
    my($makedir) = path($glibcdir, "$myname-build.d");
    md($makedir);

    if($hdrdir)
    {
      cdrun($hdrdir, qw[make include/linux/version.h]);
      optcdrun($hdrdir, qw[make include/asm]) || # 2.6.x
          cdrun($hdrdir, qw[make symlinks]); # 2.4.x
    }

    my($emdir) = shellescape($makedir);
    my($ehdir) = defined($hdrdir) ? (shellescape($hdrdir)) : ();
    my($mftext) = "# $genby\n\nall:\n" .
        "\tyes '' | make -C $ehdir oldconfig dep\n" . # mtools, LVM2...
        "\t\$(MAKE) -C $emdir\n\n" .
        "install:\n\t\$(MAKE) -C $emdir install\n";
    my($inclist) = "include/linux include/asm/. include/asm-generic";
    $mftext .= "\t\(cd $ehdir && tar c $inclist) | (cd \$(DESTDIR) && tar x)\n"
        if $ehdir;
    writefile(path($dir, "Makefile"), $mftext);

    my(%confopts) = ("--prefix=$prefix" => 1);
    $confopts{"--with-headers=$hdrdir/include"} = 1 if $hdrdir;
    my($cfg) = path($glibcdir, "configure");
    patch
    {
      $confopts{$1} = 1 if /(--(enable-add-ons|with-tls))\b/;
    } $cfg if reconfigure;
    cdrunconf($makedir, qw(sh ../configure), sort(keys(%confopts)));

    return $dir;
  }

  # Write a custom Makefile for Sun J2SDK (grumble grumble).
  if(-x(path($dir, qw[jre bin java])))
  {
    my($mftext) = "# $genby" . q{

all:
  for i in "" `find . -name '*.pack'`; do [ -n "$$i" ] && \
    lib/unpack $$i "`dirname $$i`/`basename $$i .pack`.jar"; rm -f $$i; done

install:
  tar c */ | (cd $(DESTDIR)/usr && tar x)
};
    $mftext =~ s/^  /\t/gm;
    writefile(path($dir, "Makefile"), $mftext);
    return $dir;
  }

  # Maybe there's just an install script of some kind that we need to run.
  # Create an appropriate Makefile.
  for(qw[install.sh INSTALL install.pl vmware-install.pl])
  {
    my($script) = path($dir, $_);
    if(-x($script))
    {
      my(@@cmd) = "./$_";
      my($isscript, $useprefix, $prefixenvvar);
      patch
      {
        $isscript ||= /^#!/;
        $useprefix ||= /--prefix=/;
        s/\bOutputLicense\b/true/g unless /\(/; # acroread
        $prefixenvvar = $1 if /\b(InstallDir)\b/; # acroread
        s/not is_root\(\)/0/; # vmware
      } $script;
      next unless $isscript;
      unshift(@@cmd, "$prefixenvvar=$prefix") if defined($prefixenvvar);
      push(@@cmd, "--prefix=$prefix") if $useprefix;
      writefile(path($dir, "Makefile"),
          "# $genby\n\nall:\n\ttrue\n\ninstall:\n\t@@cmd\n");
      return $dir;
    }
  }

  # SCons replaces make entirely; wrap it in a Makefile (e.g. klick)
  if(-r(path($dir, "SConstruct")))
  {
    writefile
    (
      path($dir, "Makefile"),
      "# $genby\n\n",
      "all:\n\tscons\n\n",
      "install:\n\tscons install\n", # not sure how to pass in DESTDIR....
    );
    return $dir;
  }

  # some packages (e.g. htmltidy) expect us to locate and run yet another
  # shell script that generates the real configure script that generates....
  for(grep(-r(path($dir, $_)), "build/gnuauto/setup.sh"))
  {
    cdrun($dir, "sh", $_);
    return &configure($dir, $prefix) if -x(path($dir, "configure"));
  }

  # look for Unixish or OS-specific Makefile in a subdir and mv it here
  # e.g. zip -> unix/Makefile; libpng -> scripts/makefile.linux
  # note that this rule would incorrectly grab a spurious subdirectory
  # Makefile from glibc+linuxthreads or j2sdk 1.5 if the above rules didn't
  # come first
  return $dir unless dfs
  (
    $dir,
    sub { true },
    sub
    {
      my($rel) = @@_;
      return true unless $rel =~ /makefile/i;
      return true unless $rel =~ /$^O|\bunix/i;
      mv($_, path($dir, "Makefile"));
      return false;
    },
    sub { true }
  );

  # try looking in promisingly-named subdirectories
  -d && return &configure($_, $prefix) foreach map(path($dir, $_), qw[src]);

  # construct a Makefile for various intransigent binary packages
  my(%file2dir);
  %file2dir = () unless whiledir
  {
    my($name) = @@_;
    local($_) = path($dir, $name);
    return false if !-f;
    return $file2dir{$name} = "/usr/lib/netscape/plugins"
        if $name =~ /flashplayer\.(xpt|so)$/; # flash player 6
    return $file2dir{$name} = "/bin"
        if $name =~ /^[a-z]+$/ && -x && -B; # upx
    return $file2dir{$name} = "/man/man1"
        if $name =~ /^[a-z]+\.1$/ && !-x && -T;
    $name =~ /readme|flashplayer-installer|^[A-Z]+$|\.(doc|html?)$/i;
  } $dir;
  if(%file2dir)
  {
    my($mftext) = "# $genby\nPREFIX=$prefix\nall:\n\ttrue\n\ninstall:\n";
    for(sort(keys(%file2dir)))
    {
      my($d) = $file2dir{$_};
      $mftext .= "\tmkdir -p $d\n\tcp $_ \$(DESTDIR)\$(PREFIX)$d\n";
    }
    writefile(path($dir, "Makefile"), $mftext);
    return $dir;
  }

  # getting desperate now -- try to construct a Makefile from thin air
  my(@@prog, @@sources, @@man);
  dfs
  (
    $dir,
    sub { true },
    sub
    {
      my($file) = @@_;
      if(/\.c$/)
      {
        push(@@sources, $file);
        push(@@prog, stripext(basename($_)))
            if grep { /\bmain\b/ } readfile($_);
      }
      push(@@man, $file) if /\.1$/ || ($file =~ s/\.man$/.1/);
      true;
    },
    sub { true }
  );

  # give up if our still-hypothetical Makefile is looking too implausible
  error("can't figure out how to compile in $dir")
      unless scalar(@@prog) == 1 && @@sources && scalar(@@sources) < 100;

  my($mftext) = qq[# $genby

PREFIX=$prefix
BINDIR=\$(PREFIX)/bin
MANDIR=\$(PREFIX)/man/man1

@@prog: @@sources

install: @@prog
\tcp @@prog \$(BINDIR)
];
  $mftext .= "\tcp @@man \$(MANDIR)\n" if @@man;

  writefile(path($dir, "Makefile"), $mftext);
  return $dir;
}

sub make($)
{
  my($dir) = @@_;
  my($mf) = makefile($dir) || error("no Makefile found");

  my($abort) = false;
  my($ok) = true;
  my($systype) = false;
  my($lk) = false; # blatant special case for older Linux kernels
  my($xf86) = false; # blatant special case for XFree86
  my($please) = ""; # blatant special case for xdaliclock
  my($figlet, $ocaml); # further eponymous special case
  my($menuconfig); # busybox, uClibc
  my($silentoldconfig); # newer linux kernels

  explain("examining $mf...");
  patch
  {
    $systype ||= /You must specify the system which you want to compil/;#mpg123
    $systype ||= /If you're not sure about the characteristics of your /;#unzip
    $systype ||= /^\t\@@echo 'Choose target:'$/; # plugger 5.0
    $lk ||= /^do-it-all:.*\bvmlinux\b/;
    $xf86 ||= /Please use make World/i;
    $ocaml ||= /^\# For users who don't read the INSTALL file$/; #thanks ocaml!
    $please = $1 if /  please make one of: "([^"]+)"/;
    $abort ||= /^all:[^\#]*\binstall\b/; # all implies install (e.g. man-pages)
    s/^DEFAULTFONTDIR = fonts$/# $&/ if $figlet;
    $figlet ||= m!^DEFAULTFONTDIR = /usr.*/figlet$!;
    $menuconfig ||= m!^all: menuconfig$!;
    $silentoldconfig ||= /Makefile silentoldconfig$/;
    s!(^PERL\s*=\s*)(/usr/.*/perl)($)!$1 . (-x($2) ? $2 : which("perl")) . $3!e
        if reconfigure; # psutils/p17
  } $mf;

  return false if $abort;
  my(@@prog) = "make";
  my(@@targets);
  @@targets = $^O if $systype;
  @@targets = qw[oldconfig dep bzImage] if $lk;
  @@targets = qw[oldconfig all] if $menuconfig || $silentoldconfig;
  @@targets = "World" if $xf86;
  @@targets = qw[world opt] if $ocaml;
  @@targets = $please if $please;

  if(($lk || $silentoldconfig) && reconfigure)
  {
    my($in) = path("/proc", "config.gz");
    my($out) = path($dir, ".config");
    optrun("gunzip < " . shellescape($in) . " > " . shellescape($out))
        if -r($in) && !-e($out)
  }

  my(@@args) = splitwords(makeappend);
  return cdrun($dir, @@prog, @@args) unless @@targets;
  cdrun($dir, @@prog, $_, @@args) foreach @@targets;
  return true;
}

sub tracecdrun($@@)
{
  my($dir, @@prog) = @@_;
  return cdrun($dir, @@prog) unless debugrewrite;
  my(@@trace) = qw[strace -s 256 -f -F -o make.install.trace];
  @@trace = qw[ktrace -i -f make.install.trace] if $^O =~ /bsd/i;
  push(@@trace, "sh", "-c") if scalar(@@prog) == 1;
  cdrun($dir, @@trace, @@prog);
  run("cat", path($dir, "make.install.trace"));
  error("trace complete; aborting");
}

sub install($$)
{
  my($makedir, $rootdir) = @@_;

  local($ENV{DESTDIR}) = $rootdir; # not always on command line due to libtiff
  announce("export", "$_=$ENV{$_}") for (qw[DESTDIR]);
  return tracecdrun($makedir, installcmd) if installcmd ne "";

  my($mf) = makefile($makedir) || error("can't figure out how to install");
  local($ENV{ROOT}) = $rootdir; # lilo
  local($ENV{install_root}) = $rootdir;
  local($ENV{PREFIX}) = $rootdir; # airhook v2
  announce("export", "$_=$ENV{$_}") for (qw[ROOT install_root PREFIX]);
  my(@@targets) = "install";
  my($man, $dev, $subdir, $netpbm, $usedestdir, $nodestdir, $useinstallprefix,
      $cdrtools, $e2fsprogs, $modules);
  whilefile
  {
    $man ||= /^install\.man:/;
    $dev ||= /^install-dev:/;
    $subdir = $1 if /  to install the X version: "cd (\w+);/; # xdaliclock
    $netpbm ||= /^\t\@@echo "  make package pkgdir=DIR"$/;
    $usedestdir ||= /\b(DESTDIR|Makefile\.in)\b/; # atop, glibc; not libtiff!
    $nodestdir ||= m!^\s*DESTDIR\s*=[^#]*/bin\s*$!; # figlet
    $useinstallprefix ||= m!INSTALL_PREFIX is for package builders!; # openssl
    $cdrtools ||= / Due to a bug in SunPRO make we need special rules /;
    $e2fsprogs ||= /^\t.* e2fsck .* ; then \$\(MAKE\) install-libs ; fi/;
    $modules ||= /^modules_install: _modinst_/; # linux 2.6.x
    true
  } $mf;
  my($cf) = path($makedir, ".config");
  $modules &&= whilefile { !/ CONFIG_MODULES is not/ } $cf if -r($cf);
  $netpbm &&= -x(path($makedir, "installnetpbm")) && path($makedir, "pkg");
  return &install(path($makedir, $subdir), $rootdir) if $subdir;
  push(@@targets, "install.man") if $man && reconfigure; # e.g. XFree86
  push(@@targets, "install-dev") if $dev && reconfigure; # e.g. bitlbee 1.2
  push(@@targets, "install-libs") if $e2fsprogs && reconfigure;
  @@targets = ("package", "pkgdir=$netpbm") if $netpbm;
  @@targets = "upgrade" if -r(path($makedir, "postfix-install")); # postfix
  push(@@targets, "DESTDIR=$rootdir") if $usedestdir && !$nodestdir;
  push(@@targets, "install_root=$rootdir") if $usedestdir; # glibc
  push(@@targets, "PREFIX=$rootdir") if $usedestdir; # busybox
  push(@@targets, "INSTALL_PREFIX=$rootdir") if $useinstallprefix; # openssl
  push(@@targets, "INS_BASE=$rootdir") if $cdrtools;
  push(@@targets, "RUN_QUERY_LOADER_TEST=true", "RUN_QUERY_IMMODULES_TEST=true")
      if -d(path($makedir, "gdk-pixbuf")); # gtk+
  push(@@targets, "modules_install", "INSTALL_MOD_PATH=$rootdir") if $modules;
  -r and safechmod(getmode($_) | 0111, $_) for map(path($makedir, $_),
      qw(install.sh install-sh)); # e.g. ht 2.0.18 under OS X
  tracecdrun($makedir, "make", @@targets);
  run("sh", "-c", "cp -R '$netpbm'/*/ '$rootdir'") if $netpbm;
}

sub stddirs()
{
  my(@@result) =
  (
    qw[bin boot etc include info lib libexec man share src var],
    map(path("man", "man$_"), 1..9), path(qw[var spool]),
    path(qw[etc rc.d]), map(path("etc", "rc.d", "rc$_.d"), 0..6), # vmware
    path(qw[var run]), # hotplug/2004_01_05
    path(qw[share aclocal]), # librep/0.16.1
    "hspkg", # holding area for Haskell package files; see sub helphspkg()
  );
  sort(@@result);
}

sub stdlinks()
{
  (
    "usr" => ".",
    "local" => ".",
    "X11R6" => ".",
    "sbin" => "bin",
    "games" => "bin",
    "share/man" => "../man",
    "share/info" => "../info",
  );
}

sub rootlinks() { stdlinks }

sub mkrootdir($$)
{
  my($rootdir, $armdir) = @@_;
  md($rootdir);
  mdp(path($rootdir, $_)) foreach stddirs;
  my(%link) = rootlinks;
  ln($link{$_}, path($rootdir, $_)) foreach keys(%link);

  # make $rootdir/$rootdir and $rootdir/$armdir point back at $rootdir,
  # without running afoul of Cygwin's 10-symlink limit:
  (mdp(path($rootdir, unpath(dirname($_)))),
      optrelln($rootdir, path($rootdir, unpath($_)))) for ($armdir, $rootdir);

  my(@@inc) = @@INC; # don't modify @@INC!
  s!^/!! and mdp(path($rootdir, $_)) for @@inc; # PDFlib-Lite/7.0.3
}

sub mkxmlcatalog($@@)
{
  my($name, @@contents) = @@_;
  writefile($name, qq[<?xml version="1.0"?>
<!DOCTYPE catalog PUBLIC "-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN" "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd">
<catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog">\n],
      map("  $_\n", @@contents), "</catalog>\n");
}

sub compiledata($$)
{
  my($srcdir, $rootdir) = @@_;
  my(@@installdir);
  return false unless compilecmd eq "" && installcmd eq "";

  # docbook-xml, maybe other things too?
  my($cat) = path($srcdir, "catalog.xml");
  if(-r($cat))
  {
    my($name, $version, $dup);
    patch
    {
      ($name, $version) = (lc($1), $2) if m!//DTD (\w+) XML V([\d\.]+)//!i;
      $dup .= $_ if $dup;
      $dup = "$1.1.2/$2" if reconfigure &&
          m!(<public publicId="-//OASIS//DTD DocBook XML V4).*(/EN".*)!s;
      ($dup, $_) = (undef, "$_$dup") if $dup && />/;
    } $cat;
    @@installdir = (qw(share xml), $name, $version) if $version;
  }

  # docbook-xsl
  my(@@ls) = ls($srcdir);
  if(!@@installdir && scalar(@@ls) == 1 && $ls[0] =~ /^docbook-xsl-/)
  {
    $srcdir = path($srcdir, $ls[0]);
    @@installdir = qw(share xml docbook-xsl);
    my($cat) = path($srcdir, "catalog.xml");
    my($rewritePrefix) = path(armdir, @@installdir);
    mkxmlcatalog($cat, qq[<rewriteURI uriStartString="http://docbook.sourceforge.net/release/xsl/current" rewritePrefix="$rewritePrefix"/>]) unless -r($cat);
  }

  return false unless @@installdir;
  my($dir) = $rootdir;
  for(@@installdir)
  {
    md($dir);
    $dir = path($dir, $_);
  }
  return mv($srcdir, $dir);
}

sub compilebin($$)
{
  my($srcdir, $rootdir) = @@_;
  return false unless compilecmd eq "" && installcmd eq "";
  return false if -d(path($srcdir, "xc")); # Xaw3d
  my($one);
  my($ok);
  abswhiledir
  (
    sub
    {
      $one = $one ? 0 : $_ unless defined($one);
      $ok ||= m!/(usr|bin|etc|lib|sbin|firefox)$!;
      -d
    },
    $srcdir
  ) && ($ok ? mv($srcdir, $rootdir) : ($one && &compilebin($one, $rootdir)));
}

sub compilehelp($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;
  my($makedir) = makedir($srcdir);

  my(%initenv) = inithelpers($srcdir, $rootdir, $helperdir);
  return false unless %initenv;

  defined($ENV{$_}) && $ENV{$_} eq $initenv{$_} ||
      announce("export", "$_=$initenv{$_}") foreach keys(%initenv);
  local(%ENV) = %initenv;

  if(compilecmd ne "")
  {
    cdrun($makedir, compilecmd);
  }
  else
  {
    $makedir = configure($makedir, armdir);
    make($makedir);
  }
  mkrootdir($rootdir, armdir);
  armhelpers($helperdir);
  install($makedir, $rootdir);

  !defined($ENV{$_}) ? announce("unset", $_) :
      ($ENV{$_} eq $initenv{$_} || announce("export", "$_=$ENV{$_}"))
      foreach keys(%initenv);

  return true;
}

sub fixbrokenrootlink($)
{
  # stdlinks fool XFree86 and busybox into creating broken symlinks; fix them!
  my($link) = @@_;
  my($dest) = readlink($link);
  defined($dest) || error("not a link: $link");
  explain("found broken symlink: $link -> $dest");
  while($dest =~ s!\.\./!! && !-e($link))
  {
    rm($link);
    ln($dest, $link);
  }
  rm($link) unless -e($link);
  true;
}

sub fixrootfile($)
{
  my($file) = @@_;
  return -e($file) ? true : fixbrokenrootlink($file) if -l($file);
  safechmod(-x($file) ? 0555 : 0444, $file);
}

sub polishrootdir($$)
{
  my($rootdir, $armdir) = @@_;

  my(%link) = rootlinks;
  -l && rm($_) foreach map { path($rootdir, $_) }
      (keys(%link), path(unpath($rootdir)), path(unpath($armdir)));

  optrmall(path($rootdir, "info", "dir"));

  my($total, %count) = 0;
  dfs
  (
    $rootdir,
    sub { $count{$_} = $total; true },
    sub { fixrootfile($_); ++$total },
    sub { $count{$_} < $total ? safechmod(protect ? 0555 : 0755, $_) : rd($_) }
  );
  $total || error("no files found in $rootdir");

  # XFree86 4.3.0 libGL.so needs this due to some kind of bug/interaction,
  # as do some binary packages:
  my($libdir) = path($rootdir, "lib");
  if(fixliblinks && -d($libdir))
  {
    my(%liblinks);
    fordir
    {
      return unless /^(lib.*\.so)((\.[\d]+)+)$/;
      my($base, $ext) = ($1, $2);
      return if exists($liblinks{$base}) && length($liblinks{$base}) > length;
      $liblinks{$base} = $_;
      for $ext (split(/\./, $ext))
      {
        next unless $ext;
        $base .= ".$ext";
        next if $_ eq $base;
        $liblinks{$base} = $_;
      }
    } $libdir;
    my($mode) = getmode($libdir);
    for(sort(keys(%liblinks)))
    {
      my($from, $to) = ($liblinks{$_}, path($libdir, $_));
      if(!-e($to) && !-l($to))
      {
        safechmod(0777, $libdir);
        ln($from, $to);
      }
    }
    safechmod($mode, $libdir);
  }
}

sub compile($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;
  compiledata($srcdir, $rootdir) ||
      compilebin($srcdir, $rootdir) ||
      compilehelp($srcdir, $rootdir, $helperdir);
  polishrootdir($rootdir, armdir);
}

sub clean(@@)
{
  whilebuild
  {
    my($name, $version, $build) = @@_;
    my($builddir) = pkgpath($name, $version, $build);
    return rmall($builddir) if isbroken($name, $version, $build);
    return true unless isbuilt($name, $version, $build);
    my($srcdir) = path($builddir, srcdir);
    my($helperdir) = path($builddir, helperdir);
    optrmall($srcdir, $helperdir);
  } @@_;

  return true;
}

sub purge(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  $build && error;

  for $name (allnames($name))
  {
    for $version (allversions($name, $version))
    {
      my($archivedir) = path(pkgpath($name, $version), archivedir);
      optrmall($archivedir);
    }
  }

  return true;
}

sub rebuild(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  $build && error;

  ($name, $version) = get(@@_) if !isstored($name, $version);
  defined($name) || error;
  defined($version) || error;

  clean($name, $version) if autoclean;

  local(%ENV) = %ENV;
  if(ccache)
  {
    my($storecachedir) = path(storedir, "ccache");
    my($cachedir);
    if(exists($ENV{"CCACHE_DIR"}))
    {
      $cachedir = $ENV{"CCACHE_DIR"};
    }
    elsif(superuser)
    {
      optmd($cachedir = $storecachedir);
    }
    elsif(exists($ENV{"HOME"}) && -d($ENV{"HOME"}))
    {
      $cachedir = path($ENV{"HOME"}, ".ccache");
    }

    chownnonroot($cachedir) if superuser && !belongstononroot($cachedir) &&
        optsamefile($cachedir, $storecachedir);

    $ENV{"CCACHE_DIR"} = $cachedir;
    announce("export", "CCACHE_DIR=$cachedir");
  }

  my($verdir) = pkgpath($name, $version);
  my(@@allbuilds) = allbuilds($name, $version);
  $build = @@allbuilds ? max(@@allbuilds) : 0;
  my($errmsg, $builddir) = true;
  while($errmsg)
  {
    $build++;
    $builddir = path($verdir, $build);
    $errmsg = mkdir($builddir, 0777) ? false : $!;
    error("mkdir $builddir: $errmsg") if $errmsg && !-d($builddir);
  }
  announce("mkdir", $builddir);
  chownnonroot($builddir);

  local(*CHILD);
  my($pid);
  if(!($pid = open(CHILD, "-|"))) # child
  {
    defined($pid) || error("fork: $!");

    my(@@times) = gettimes;

    open(STDERR, ">&STDOUT") || error("dup stdout: $!");
    verbosify;
    benice;
    dropprivs;
    showprebuildinfo($name, $version, $build);
    yes;
    setbuildenv if autoenv;

    my($archivedir) = path($verdir, archivedir);
    my($srcdir) = path($builddir, srcdir);
    my($helperdir) = path($builddir, helperdir);
    my($rootdir) = path($builddir, rootdir);
    my($armdirlink) = path($builddir, armdirlink);

    ln(armdir, $armdirlink);
    md($srcdir);
    extract($archivedir, $srcdir);
    compile($srcdir, $rootdir, $helperdir);

    showtimedeltas(@@times);
    exit(0);
  }

  $SIG{INT} = "IGNORE";
  my($tmplogname) = addtmp(path($builddir, buildlog));
  local(*LOG);
  safeopen(*LOG, ">", $tmplogname);

  while(<CHILD>)
  {
    print LOG $_;
    chomp;
    say("  $_\n");
  }

  my($success) = close(CHILD);
  $SIG{INT} = "DEFAULT";
  my($msg) = "child returned $?";
  close(LOG) || error("close $tmplogname for write: $!");

  if($success && superuser)
  {
    announce("chown", "-Rh", "root:root", $builddir);
    dfs
    (
      $builddir,
      sub { chown(0, 0, $_) || ($success = !($msg = "chown $_: $!")) },
      sub
      {
        if(!-l)
        {
          return chown(0, 0, $_) || ($success = !($msg = "chown $_: $!"))
        }
        else
        {
          my($source) = readlink;
          error("readlink $_: $!") unless defined($source);
          return (unlink || ($success = !($msg = "unlink $_: $!"))) &&
              (symlink($source, $_) ||
              ($success = !($msg = "symlink $source $_: $!")));
        }
      },
      sub { true }
    );
  }

  my($logname) = path($builddir, $success ? buildlog : brokenlog);
  mv($tmplogname, $logname);
  explain('build failed; use "toast bug" to send a bug report') if !$success;
  $success || error($msg);

  clean($name, $version, $build) if autoclean;
  purge($name, $version) if autopurge;
  arm($name, $version, $build) if autoarm && isarmedmatch($name, $version);

  if(autodemolish || autoremove)
  {
    my($aversion, $abuild);
    for $aversion (allversions($name, crossversion ? undef : $version))
    {
      if(autodemolish)
      {
        for $abuild (allbuilds($name, $aversion))
        {
          next if $aversion eq $version && $abuild == $build;
          next if skipmismatched && ismismatched($name, $aversion, $abuild);
          next if !autodisarm && isarmed($name, $aversion, $abuild);
          demolish($name, $aversion, $abuild);
        }
      }
      if(autoremove)
      {
        next if $aversion eq $version;
        next if !autodisarm && isarmed($name, $aversion);
        remove($name, $aversion);
      }
    }
  }

  ($name, $version, $build);
}

sub build(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  $build && error;
  $build = defined($version) ? latestbuilt($name, $version) : undef;
  return $build ? ($name, $version, $build) : rebuild(@@_);
}

##############################################################################

sub displace($)
{
  local($_) = @@_;
  if(-e || -l)
  {
    error("refusing to displace directory: $_") if -d && !-l;
    my($offname) = addoff($_);
    &displace($offname);
    mv($_, $offname);
  }
  $_;
}

sub isempty($)
{
  my($dir) = @@_;
  my($result) = true;
  whiledir { $result = false } $dir;
  $result;
}

BEGIN
{
  my(%locks);

  sub lock($)
  {
    my($path) = @@_;
    error("$path already locked") if $locks{$path};
    local(*LOCK);
    safeopen(*LOCK, "<", $path);
    $locks{$path} = *LOCK{IO};
    return unless useflock;
    if(!flock(LOCK, 6)) # LOCK_EX | LOCK_NB
    {
      explain("waiting for lock on $path");
      flock(LOCK, 2) || error("flock $path: $!"); # LOCK_EX
    }
  }

  sub unlock($)
  {
    my($path) = @@_;
    my($lock) = $locks{$path};
    error("$path not locked") unless $lock;
    flock($lock, 8) || error("unlock $path: $!") if useflock; # LOCK_UN
    close($lock) || error("close $path: $!");
    delete($locks{$path});
  }
}

sub rebuildinfodir($)
{
  my($armdir) = @@_;
  my($dir) = path($armdir, "info");
  return true unless -d($dir);

  my($dirfile) = path($dir, "dir");

  # remove old links left by previous version of toast:
  my($oldfile) = addoff($dirfile);
  while(-e($oldfile) || -l($oldfile))
  {
    rm($oldfile);
    $oldfile = addoff($oldfile);
  }

  my($mode) = getmode($dir);
  my($prog) = infodir && optwhich("install-info");
  my($dpkg);  # dpkg's install-info wants to write to /var/backups....
  whilefile { !/\0/ && !($dpkg = /Ian Jackson/) } $prog;

  if(!$prog || $dpkg)
  {
    if(-e($dirfile) || -l($dirfile))
    {
      safechmod(0777, $dir);
      rm($dirfile);
    }
  }
  else
  {
    my($tmpdir) = addtmp($dirfile);
    if(-e($tmpdir) || -l($tmpdir))
    {
      safechmod(0777, $dir);
      rmall($tmpdir);
    }
    my($tmpsuffix) = tmpsuffix;
    my($offsuffix) = offsuffix;
    abswhiledir
    {
      return true if m!(/dir|\Q$tmpsuffix\E|\Q$offsuffix\E|-\d+(\.info)?)$!;
      safechmod(0777, $dir);
      optmd($tmpdir);
      optrun("install-info", "--info-dir=$tmpdir", $_);
      true;
    } $dir;
    my($tmpfile) = path($tmpdir, "dir");
    mv($tmpfile, $dirfile) if -e($tmpfile);
    optrmall($tmpdir);
  }

  safechmod($mode, $dir);
}

sub rebuildxmlcatalog(@@)
{
  my($armdir) = @@_;
  my($etcdir) = path($armdir, "etc");
  my($xmldir) = path($etcdir, "xml");
  my($master) = path($xmldir, "toast-xml-catalog");
  my(@@subcats);

  if(xmlcatalog)
  {
    @@subcats = -d($xmldir) ? grep(m!/catalog[^/]*$!, absls($xmldir)) : ();
    my($dir) = path($armdir, qw[share xml]);
    dfs
    (
      $dir,
      sub { true },
      sub { push(@@subcats, $_) if m!/catalog.xml$!; true },
      sub { true },
    ) if -d($dir);
  }

  return -e($master) || -l($master) ? rm($master) : true unless @@subcats;

  for(grep(!-d, $etcdir, $xmldir))
  {
    my($parent) = dirname($_);
    my($mode) = getmode($parent);
    safechmod(0777, $parent);
    md($_);
    safechmod($mode, $parent);
  }

  my($mode) = getmode($xmldir);
  safechmod(0777, $xmldir);
  safechmod(0666, $master) if -e($master);
  mkxmlcatalog($master, map(qq[<nextCatalog catalog="$_"/>], sort(@@subcats)));
  safechmod($mode, $xmldir);

  if(protect)
  {
    safechmod(0444, $master);
    safechmod(0555, $_) for($xmldir, $etcdir, $armdir);
  }
}

sub rebuildhspkg($)
{
  my($armdir) = @@_;

  my($dir) = path($armdir, "hspkg");
  my(@@pkgs);
  @@pkgs = absls($dir) if hspkg and -d($dir);

  my($etcdir) = path($armdir, "etc");
  my($file) = path($etcdir, "toast-hs-package.conf");
  return -e($file) || -l($file) ? rm($file) : true unless @@pkgs;

  if(!-d($etcdir))
  {
    my($mode) = getmode($armdir);
    safechmod(0777, $armdir);
    md(path($etcdir));
    safechmod($mode, $armdir);
  }

  my($mode) = getmode($etcdir);
  safechmod(0777, $etcdir);
  safechmod(0666, $file) if -e($file);
  writefile($file, "[]\n");
  optrun("ghc-pkg", "--force", "-f", $file, "update", $_) for(@@pkgs);
  optrmall("$file.old");
  safechmod($mode, $etcdir);

  if(protect)
  {
    safechmod(0444, $file);
    safechmod(0555, $_) for($etcdir, $armdir);
  }
}

sub arm(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  ($name, $version, $build) = build(@@_) unless $build;

  return ($name, $version, $build) if isarmed($name, $version, $build);

  optmd(armdir);
  lock(armdir);

  my($mode) = (protect ? 0555 : 0777) & ~umask;
  if(getmode(armdir) != $mode)
  {
    dfs
    (
      armdir,
      sub { safechmod($mode, $_) },
      sub { true },
      sub { true }
    );
  }

  my(%link) = stdlinks;
  for(keys(%link))
  {
    my($abs) = path(armdir, $_);
    if(!-e($abs) && !-l($abs))
    {
      my($dir) = dirname($abs);
      if(!-d($dir))
      {
        my($parent) = dirname($dir);
        safechmod(0777, $parent);
        md($dir);
        safechmod($mode, $parent);
      }
      safechmod(0777, $dir);
      ln($link{$_}, $abs);
      safechmod($mode, $dir);
    }
  }

  $build || error;
  my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
  dfs
  (
    $rootdir,
    sub
    {
      my($dir) = optpath(armdir, $_[0]);
      if(!-d($dir))
      {
        safechmod(0777, dirname($dir)) if defined($_[0]);
        md($dir);
      }
      return true;
    },
    sub
    {
      my($target) = optpath(armdir, $_[0]);
      safechmod(0777, dirname($target));
      displace($target);
      relative ? relln($_, $target) : ln($_, $target);
    },
    sub { safechmod($mode, optpath(armdir, $_[0])) }
  );

  rebuildinfodir(armdir);
  rebuildxmlcatalog(armdir);
  rebuildhspkg(armdir);
  run(postarmprog) if postarmprog;

  unlock(armdir);

  if(autodisarm)
  {
    my($aversion, $abuild);
    for $aversion (allversions($name, crossversion ? undef : $version))
    {
      for $abuild (allbuilds($name, $aversion))
      {
        disarm($name, $aversion, $abuild)
            unless $aversion eq $version && $abuild == $build;
      }
    }
  }

  ($name, $version, $build);
}

sub disarm(@@)
{
  my(@@nvb) = @@_; # see nvb comment below

  my(@@armdirs) = allarmdirs;
  my($i, $armdir, $anychanged);
  for $armdir (@@armdirs)
  {
    lock($armdir);
    my($changed);

    whilebuild
    {
      my($name, $version, $build) = @@_;

      my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
      my(@@dirmodes);
      -d($rootdir) && dfs  # ignore broken packages
      (
        $rootdir,
        sub
        {
          my($rel) = @@_;
          my($armsubdir) = optpath($armdir, $rel);
          if(-d($armsubdir) && !-l($armsubdir))
          {
            push(@@dirmodes, getmode($armsubdir));
          }
          return true;
        },
        sub
        {
          my($rel) = @@_;
          my($armfile) = path($armdir, $rel);
          while(-e($armfile) || -l($armfile))
          {
            if(optsamefile($armfile, $_))
            {
              safechmod(0777, dirname($armfile));
              rm($armfile);
              my($off);
              while(-e($off = addoff($armfile)) || -l($off))
              {
                mv($off, $armfile);
                $armfile = $off;
              }
              return $changed = true;
            }
            $armfile = addoff($armfile);
          }
          return true;
        },
        sub
        {
          my($rel) = @@_;
          my($armsubdir) = optpath($armdir, $rel);
          if(-d($armsubdir) && !-l($armsubdir))
          {
            my($mode) = pop(@@dirmodes);
            return safechmod($mode, $armsubdir) unless isempty($armsubdir);
            safechmod(0777, dirname($armsubdir)) if @@dirmodes;
            rd($armsubdir);
          }
          return true;
        }
      );
      error if @@dirmodes;
      return true;
    } @@nvb; # can't replace @@nvb with ($n, $v, $b) due to perl 5.6.1 bug (?)

    rebuildinfodir($armdir) if $changed;
    rebuildxmlcatalog($armdir) if $changed;
    rebuildhspkg($armdir) if $changed;
    $anychanged ||= $changed;
    run(postarmprog) if ++$i == scalar(@@armdirs) && $anychanged && postarmprog;
    unlock($armdir);
  }

  return true;
}

##############################################################################

sub findnewerpkg($$$@@)
{
  my($name, $version, $build, @@urls) = @@_;
  error unless defined($name);
  error unless defined($version);
  error if defined($build);

  @@urls = pkgurls($name, $version) unless @@urls;
  error unless @@urls;

  # Look for new version numbers that start with a digit and that don't
  # contain dashes (as in "zsh-4.0.6-doc.tar.gz"),
  # unless the original version number lacked those properties.
  my($verchar) = $version =~ /-/ ? '.' : '[^\-]';
  my($verpat) = $version =~ /^\d/ ? "\\d$verchar*" : "$verchar+";

  my(%linkmap, %candidates, @@newurls);
  my($hasver) = false;
  for(@@urls)
  {
    if(/^(cvs.*)\#\Q$version\E$/)
    {
      my($newurl) = cleanurl($1);
      my(undef, $newv) = guessnv($newurl);
      push(@@newurls, $newurl);
      $candidates{$newv} = $hasver = true;
      next;
    }
    m!^((https?|ftp|file)://[^\?]+/)([^\?/]*)(\?.*)?$!i ||
        error("bad URL for upgrade: $_");
    my($dirname, $basename, $query) = undeftoempty($1, $3, $4);
    if($basename !~ /^(.*)\Q$version\E(.*)$/)
    {
      push(@@newurls, $_); # URL has no version number; use as-is
    }
    else
    {
      $hasver = true;
      my($pre, $post) = ($1, $2);
      $linkmap{$dirname} = [linksfromurl($dirname)]
          unless exists($linkmap{$dirname});
      my(@@links) = @@{$linkmap{$dirname}};
      my(%vermap);
      for(@@links)
      {
        if(m!/\Q$pre\E($verpat)\Q$post\E(\?.*)?$!)
        {
          $vermap{$1} = $_;
          $candidates{$1} = 1;
        }
      }
      push(@@newurls, \%vermap);
    }
  }

  return &findnewerpkg($name, $version, $build, @@urls)
      if !$hasver && $version =~ s/-toast\d+$//;

  my($pkgname) = pkgname($name, $version);
  error("URLs for $pkgname don't seem version-specific") unless $hasver;

  my(@@result);
  for(sort cmpab keys(%candidates))
  {
    my($candidate) = $_;
    my($ok) = true;
    my(@@curls) = @@newurls;
    for(@@curls)
    {
      next unless ref;
      my(%vermap) = %$_;
      if(!exists($vermap{$candidate}))
      {
        $ok = false;
        last;
      }
      $_ = $vermap{$candidate};
    }
    push(@@result, [$name, $candidate, undef, @@curls]) if $ok;
  }

  error("can't find consistent URLs for $pkgname") unless @@result;
  return @@result;
}

sub find(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  error unless defined($name);
  error if defined($build);

  my(@@pkgs) = defined($version) && (@@urls || isadded($name, $version))
      ? findnewerpkg($name, $version, $build, @@urls)
      : findnewpkg($name, $version);

  error unless @@pkgs;
  $name = ${$pkgs[0]}[0];
  $name eq ${$pkgs[$_]}[0] or error for 0..$#pkgs;

  if(defined($version))
  {
    my(@@filtered);
    for(@@pkgs){
      my(undef, $pkg_ver) = @@$_;
      push(@@filtered, $_) if undeftoempty($pkg_ver) eq $version;
    }
    @@pkgs = @@filtered if @@filtered;
  }

  say("\n");

  print("$name\n");
  for(@@pkgs)
  {
    (undef, $version, undef, @@urls) = @@$_;
    $version = "unknown" unless defined($version);
    print("  version $version: found\n");
    print("    urls:\n");
    print("      $_\n") for(@@urls);
  }

  return true;
}

sub upgrade(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  error if defined($build);

  my(@@pkgs) =
      reverse(choose($version, findnewerpkg($name, $version, $build, @@urls)));
  my(@@cmdargs) = @@{$pkgs[0]};
  my($newver) = $cmdargs[1];

  my($pkgname) = pkgname($name, $version);
  return ($name, $version, $build, @@urls)
      if interactive && $version eq $newver;
  error("$pkgname appears to be the latest available version")
      if $version eq $newver;
  my(@@sortvers) = sort cmpab ($version, $newver);
  error("only found older versions of $pkgname")
      if $sortvers[1] eq $version && !interactive;

  if(autoarm && isarmedmatch($name, $version))
  {
    return arm(@@cmdargs);
  }
  elsif(isbuiltmatch($name, $version))
  {
    return build(@@cmdargs);
  }
  elsif(isstored($name, $version))
  {
    return get(@@cmdargs);
  }
  else
  {
    return add(@@cmdargs);
  }
}

##############################################################################

sub ensuredisarmed($;$$)
{
  my($name, $version, $build) = @@_;
  return true unless isarmed($name, $version, $build);
  error(pkgname($name, $version, $build) . " is armed") unless autodisarm;
  disarm($name, $version, $build);
}

##############################################################################

sub remove(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  $name || error;
  ensuredisarmed($name, $version, $build);
  rmall(pkgpath($name, $version, $build));
}

sub demolish(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  whilebuild { remove(@@_) } @@_;
}

##############################################################################

sub printopts($;$)
{
  my($name, $version) = @@_;
  return true unless showopts;
  my($indent) = defined($version) ? "  " : "";
  my($opts) = loadopts($name, $version);
  return unless %{$opts};
  print("$indent  options:\n");
  for(sort(keys(%{$opts})))
  {
    my($value) = $opts->{$_};
    print("$indent    --" .  (!isboolopt($_) ? "$_=" . quote($value) :
        $value ? "$_" : "no$_") . "\n");
  }
}

sub status(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  my($result) = true;

  my(@@armdirs) = allarmdirs;

  for $name (allnames($name))
  {
    print("$name\n");
    printopts($name);

    for $version (allversions($name, $version))
    {
      print("  version $version",
          isstored($name, $version) ? ": stored\n" : "\n");

      if(showurls || @@urls)
      {
        my(@@haveurls) = pkgurls($name, $version);
        my($mismatch) = !@@urls || samelist(@@haveurls, @@urls)
            ? "" : " differ from those specified";
        $result = false if $mismatch;
        if(showurls || $mismatch)
        {
          print("    urls$mismatch:\n");
          print("      $_\n") foreach @@haveurls;
        }
      }

      printopts($name, $version);

      for $build (allbuilds($name, $version, $build))
      {
        my($status, @@notes, @@armedin);
        my($normalarmdir) = armdir;
        if(isbroken($name, $version, $build))
        {
          $status = "broken";
        }
        elsif(!isbuilt($name, $version, $build))
        {
          $status = "building";
        }
        else
        {
          push(@@notes, "not clean") unless isclean($name, $version, $build);
          my($mismatched) = ismismatched($name, $version, $build);
          for($mismatched ? allarmdirs($name, $version, $build) : @@armdirs)
          {
            push(@@armedin, $_) if isbuildarmedin($_, $name, $version, $build);
          }
          if($mismatched)
          {
            $status = "mismatched";
            my($armdirlink) =
                path(pkgpath($name, $version, $build), armdirlink);
            my($builtfor) = readlink($armdirlink);
            push(@@notes, "built for $builtfor") if defined($builtfor);
            push(@@notes, "armed") if @@armedin;
            $normalarmdir = $armdirlink;
          }
          elsif(@@armedin)
          {
            $status = "armed";
          }
          else
          {
            $status = "built";
          }
        }
        my($notetext) = @@notes ? " (" . join("; ", @@notes) . ")" : "";
        print("    build $build: $status$notetext\n");
        if(@@armedin && (scalar(@@armedin) > 1 ||
            !optsamefile($armedin[0], $normalarmdir)))
        {
          print("      armed in:\n");
          print("        $_\n") for @@armedin;
        }
      }
    }
  }

  return $result;
}

##############################################################################

sub edit(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  error unless defined($name);
  error if defined($build);

  ($name, $version) = get($name, $version, $build, @@urls)
      unless defined($version) && isstored($name, $version);
  error unless defined($name);
  error unless defined($version);

  my($suffix) = "-$myname";
  my($oldversion) = $version =~ /^(.*)(\Q$suffix\E\d+)$/ ? $1 : $version;
  error unless defined($oldversion);
  error(pkgname($name, $oldversion) . " is no longer stored")
      unless isstored($name, $oldversion);

  my($oldverdir) = pkgpath($name, $oldversion);
  my($oldarchivedir) = path($oldverdir, archivedir);

  my($verdir) = pkgpath($name, $version);
  my($archivedir) = path($verdir, archivedir);

  my($num) = 1;
  my($newversion, $newverdir);
  while(true)
  {
    $newversion = $oldversion . $suffix . $num;
    $newverdir = pkgpath($name, $newversion);
    last if mkdir($newverdir, 0777);
    error("mkdir $newverdir: $!") unless -d($newverdir);
    $num++;
  }
  announce("mkdir", $newverdir);

  my($newarchivedir) = path($newverdir, archivedir);
  my($editdir) = path($newverdir, editdir);
  my($olddir) = path($editdir, "old");
  my($newdir) = path($editdir, "new");
  my($patchfilename) = "edit.patch";
  my($patchfile) = path($editdir, $patchfilename);
  md($editdir, $olddir, $newdir);

  chownnonroot($olddir, $newdir);

  local(*PATCH);
  safeopen(*PATCH, ">", $patchfile);
  my($pid) = fork;
  error("fork: $!") unless defined($pid);

  if(!$pid) # child
  {
    dropprivs;
    extract($oldarchivedir, $olddir);
    extract($archivedir, $newdir);
    my($prog) = length(editprog) ? editprog :
        exists($ENV{SHELL}) ? $ENV{SHELL} : "/bin/sh";
    cdrun(makedir($newdir), $prog);

    local(*DIFF, $_);
    openprog(*DIFF, "diff", "-urN", $olddir, $newdir);
    while(<DIFF>)
    {
      s!^(\+\+\+|---) (\Q$olddir\E|\Q$newdir\E)/!$1 !;
      print PATCH $_;
    }
    close(DIFF); # ignore error
    close(PATCH) or error("close $patchfile: $!");

    exit(0);
    error;
  }

  my($errmsg);
  waitpid($pid, 0) or error("waitpid $pid: $!");
  $errmsg ||= "subprocess returned $?" unless $? == 0;
  close(PATCH) or error("close $patchfile: $!");
  $errmsg ||= "no changes found" unless -s($patchfile);
  if($errmsg)
  {
    rmall($newverdir);
    error($errmsg);
  }
  rmall($olddir, $newdir);

  my(@@newurls) = pkgurls($name, $oldversion);
  push(@@newurls, fileurl($patchfile));
  setpkgurls($name, $newversion, @@newurls);

  md($newarchivedir);
  fordir { ln(path($oldarchivedir, $_), path($newarchivedir, $_)) }
      $oldarchivedir;
  ln($patchfile, path($newarchivedir, $patchfilename));

  return build($name, $newversion, undef, @@newurls);
}

##############################################################################

sub rename(@@)
{
  my($sname, $sversion, $sbuild, $dname, $dversion, $dbuild) = @@_;

  defined($sname) == defined($dname) || error;
  defined($sversion) == defined($dversion) || error;
  defined($sbuild) == defined($dbuild) || error;
  defined($sname) || error;
  defined($sbuild) && !defined($sversion) && error;

  my($sdir) = pkgpath($sname, $sversion, $sbuild);
  my($ddir) = pkgpath($dname, $dversion, $dbuild);

  -d($sdir) || error(pkgname($sname, $sversion, $sbuild) . " does not exist");
  -d($ddir) && error(pkgname($dname, $dversion, $dbuild) . " already exists");
  isarmed($sname, $sversion, $sbuild) &&
      error(pkgname($sname, $sversion, $sbuild) . " is armed");

  my($namedir) = pkgpath($dname);
  optmd($namedir) unless $ddir eq $namedir;
  my($versiondir) = pkgpath($dname, $dversion);
  optmd($versiondir) unless $ddir eq $versiondir;
  mv($sdir, $ddir);

  my($oldnamedir) = pkgpath($sname);
  rmdir($oldnamedir) && announce("rmdir", $oldnamedir);

  return !defined($dversion) ? ($dname) :
      !defined($dbuild) ? ($dname, $dversion) :
      ($dname, $dversion, $dbuild);
}

##############################################################################

sub change(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  error unless defined($name);
  error unless defined($version);
  error if defined($build);
  error unless @@urls;

  setpkgurls($name, $version, @@urls);
  ($name, $version);
}

##############################################################################

sub bug(@@)
{
  my($name, $version, $build, @@urls) = @@_;

  my(%logs);
  for $name (allnames($name))
  {
    for $version (allversions($name, $version))
    {
      for $build (allbuilds($name, $version, $build))
      {
        my($log) = isbroken($name, $version, $build);
        $logs{$log} = getmtime($log) if $log;
      }
    }
  }

  return true unless %logs;
  my(@@logs) = sort { $logs{$b} <=> $logs{$a} } keys(%logs);
  my($path) = $logs[0];

  explain("sending $path");
  my($result) = httppost($bugurl, join('', readfile($path)));
  $result =~ s/\s*$//;
  error("server error: $result") unless $result eq "ok";
  return true;
}

##############################################################################

BEGIN
{
  my($checkresult);

  sub failcheck(@@)
  {
    print(join(": ", @@_) . "\n");
    $checkresult = false;
    return true;
  }

  sub checkbuild($$$)
  {
    my($name, $version, $build) = @@_;
    my($path) = pkgpath($name, $version, $build);

    return failcheck($path, "not a directory") unless -d($path);

    # @@todo check various

    fordir
    {
      /^(src|root|helpers|build\.log\.tmp|build\.log|broken\.log)$/ ||
          failcheck(path($path, $_));
    } $path;
  }

  sub checkversion($$)
  {
    my($name, $version) = @@_;
    my($path) = pkgpath($name, $version);

    failcheck($path, "invalid version number") unless validversion($version);
    return failcheck($path, "not a directory") unless -d($path);

    my($urlfile) = path($path, urlfile);
    # @@todo check urlfile

    my($archivedir) = path($path, archivedir);
    # @@todo check archivedir

    fordir
    {
      validbuild($_) ? checkbuild($name, $version, $_) :
          /^(archive|url)(\.tmp)?$/ ||
          failcheck(path($path, $_));
    } $path;
  }

  sub checkname($)
  {
    my($name) = @@_;
    my($path) = pkgpath($name);

    failcheck($path, "invalid package name") unless validname($name);
    return failcheck($path, "not a directory") unless -d($path);

    fordir
    {
      s/^v// ? checkversion($name, $_) : failcheck(path($path, $_));
    } $path;
  }

  sub checkall()
  {
    my($path) = pkgpath;

    return failcheck($path, "not found") unless -e($path);
    return failcheck($path, "not a directory") unless -d(_);
    # @@todo check permissions

    fordir { checkname($_) } $path;
  }

  sub check(@@)
  {
    my($name, $version, $build) = @@_;

    $checkresult = true;

    defined($build) ? checkbuild($name, $version, $build) :
        defined($version) ? checkversion($name, $version) :
        defined($name) ? checkname($name) :
        checkall;

    my($msg) = "$myname check ";
    $msg .= $checkresult ? "passed" : "failed";
    $msg .= ": " . pkgname($name, $version, $build) if defined($name);
    print("$msg\n");

    return $checkresult;
  }
}

##############################################################################

sub selfopen(*)
{
  local(*SCRIPT) = @@_;
  my($package, $file) = caller(0);
  safeopen(*SCRIPT, "<", $file);
}

sub depodify($)
{
  local($_) = @@_;
  s/I\<([^\>]+)\>/\*$1\*/g;
  s/C\<([^\>]+)\>/\`$1\'/g;
  s/[A-Z]\<|\>//g;
  s/^=(over|back).*\r?\n?//gm;
  s/^=\w+\s+//gm;
  s/\n\n\n+/\n\n/g;
  $_;
}

sub help(@@)
{
  my(@@topics) = @@_;
  @@topics = ("commands") unless @@topics;

  print << "EOF";

$myname version $myversion -- $myurl
$mycopyright
$myname comes with ABSOLUTELY NO WARRANTY; for details run "$myname license".

EOF

  local(*SCRIPT, $_);
  selfopen(*SCRIPT);

  my($usage);
  while(<SCRIPT>) { last if /^=head1 SYNOPSIS$/ }
  while(<SCRIPT>)
  {
    last if /^=/;
    $usage .= $_;
  }
  $usage =~ /^\s*(\S.*\S)\s*$/ || error;
  $usage = depodify("usage:  $1\n\n");

  my(@@items, @@cmds, @@opts, %head, %body);
  for(1..2)
  {
    while(<SCRIPT>) { last if /^=head\d (commands|options)$/i }
    while(<SCRIPT>)
    {
      last if /^=(back|cut)/;
      if(/^=item .*\Q$myname\E (\w+)/)
      {
        @@items = ($1);
        $head{$1} .= $_;
        push(@@cmds, $1) unless $body{$1};
      }
      elsif(/^=item \S*-(\w+)(.*)/)
      {
        @@items = ($1);
        push(@@opts, $1) unless $body{$1};
        my($rest) = $2;
        push(@@items, $1) while $rest =~ /-(\w+)/g;
        my($item);
        for $item (@@items)
        {
          $head{$item} .= $_;
        }
      }
      else
      {
        my($item);
        for $item (@@items)
        {
          $body{$item} .= $_;
        }
      }
    }
  }
  close(SCRIPT) || error;

  $head{"commands"} = "${usage}where *COMMAND* is one of the following " .
      "words:\n\n";
  my($maxcmdlen) = max(map { length } @@cmds);
  for(@@cmds)
  {
    $body{$_} =~ /\w[^\.]+\./ || error;
    my($spaces) = " " x ($maxcmdlen - length);
    $body{"commands"} .= "  $_  $spaces$&\n";
  }
  $body{"commands"} .= "\nFor help on a specific command: " .
      "  $myname help *COMMAND*\n";
  $body{"commands"} .= "For a list of available options:" .
      "  $myname help options\n\n";

  $head{"options"} = "${usage}where *OPTION* is one of the following:\n\n";
  for(@@opts)
  {
    $body{"options"} =~ s/\n$/ |\n/ if $body{"options"};
    $body{"options"} .= "  " . depodify($head{$_});
  }
  $body{"options"} .= qq{\nFor help on --*OPTNAME*:  "$myname help *OPTNAME*"}
      . "  (leave out the dashes)\n\n";

  print(exists($head{$_}) ? depodify("$head{$_}$body{$_}") :
      qq{Topic not found: "$_" -- try "$myname help".\n\n}) for (@@topics);
  return true;
}

##############################################################################

sub findmanparser(@@)
{
  for(@@_)
  {
    /^[\w\:]+$/ || error("bad parser: $_");
    my($parser) = eval("use IO::Handle; use Pod::$_; Pod::$_->new()");
    return $parser if $parser;
  }
  return false;
}

sub fakeman(;$)
{
  my($out) = @@_;
  local(*SCRIPT, $_);
  selfopen(*SCRIPT);
  my($pod);
  while(<SCRIPT>)
  {
    $pod .= $_ if $pod || /^=\w+/;
    last if /^=cut/;
  }
  close(SCRIPT) || error;
  my($old) = $out ? select($out) || error : false;
  print(depodify($pod));
  select($old) || error if $old;
  return true;
}

sub tryman($;$)
{
  my($parser, $pager) = @@_;

  my($out);
  local(*PAGER);
  if($pager)
  {
    return false unless open(PAGER, "| $pager");
    $out = \*PAGER;
  }
  local(*SCRIPT);
  selfopen(*SCRIPT);
  $parser ? $parser->parse_from_filehandle(*SCRIPT, $out) : fakeman($out);
  close(PAGER) if $out;
  close(SCRIPT) || error;
  return true;
}

sub man()
{
  return tryman(findmanparser("Text")) || error unless -t(STDOUT);
  my($parser) = findmanparser(qw(Text::Overstrike Text::Termcap Text));
  exists($ENV{$_}) && tryman($parser, $ENV{$_}) && return true
      foreach qw(MANPAGER PAGER);
  tryman($parser, $_) && return true foreach ("less -ir", "more", "");
  error;
}

##############################################################################

sub license();

sub cmd_license()
{
  print license;
}

##############################################################################

sub cmd_version()
{
  print "$myname $myversion\n";
}

##############################################################################

sub urlescapechar($)
{
  my($char) = @@_;
  my($hex) = hex(ord($char));
  $hex = "0$hex" if length($hex) == 1;
  "\%$hex";
}

sub cleanurl($)
{
  my($url) = @@_;
  $url =~ s/ /\+/g;
  $url =~ s/[^\!-\~]/urlescapechar($&)/ge;
  $url .= "/" if $url =~ m!^\w+://[^/]+$!;
  $url =~ s!^(ftp://[^/:]+):21/!$1/!; # wget emits redundant ftp port no.
  $url .= "#" . time() if $url =~ /^cvs/ && $url !~ /\#\d+$/;
  return $url;
}

sub fileurl($)
{
  my($file) = @@_;
  $file = abspath($file);
  $file =~ s/[\%]/urlescapechar($&)/ge;
  return cleanurl("file://localhost$file");
}

sub pkgname($;$$)
{
  my($name, $version, $build) = @@_;
  error unless defined($name);
  my($result) = "$name";
  $result .= " version $version" if defined($version);
  $result .= " build $build" if defined($build);
  $result;
}

##############################################################################

sub findpkg($$)
{
  my($name, $version) = emptytoundef(@@_);

  return () unless defined($name);
  return ($name, $version)
      if defined($version) ? isversion($name, $version) : isname($name);
  return () unless ignorecase;

  ($name, $version) = (lc($name), defined($version) ? lc($version) : undef);
  my($n, $v);

  for $n (allnames)
  {
    if(lc($n) eq $name)
    {
      return ($n) unless defined($version);
      for $v (allversions($n))
      {
        return ($n, $v) if lc($v) eq $version;
      }
    }
  }

  return ();
}

##############################################################################

sub parse(@@)
{
  my(@@args) = @@_;
  my(@@result) = ();
  while(@@args)
  {
    local($_) = shift(@@args);
    my($name, $version, $build, @@urls, $nourls, $multi, $split);

    if($_ ne "[" && m!^([^:/\.]*)(/([^:/]+)(/([1-9]\d*))?)?(:?)$!)
    {
      my($oname, $oversion);
      ($oname, $oversion, $build, $nourls) = ($1, $3, $5, !$6);
      ($name, $version) = findpkg($oname, $oversion);
      if(!$nourls)
      {
        defined($oversion) || error("missing version number: \"$_\"");
        defined($build) && error("unexpected build number: \"$_\"");
        @@args || error("expected file or URL after \"$_\"");
        $_ = shift(@@args);
      }
      elsif(defined($oversion) && !defined($version))
      {
        ($nourls, $name, $oname) = false if -r && !-d;
      }
      else
      {
        !defined($build) || isbuild($name, $version, $build) ||
            error("no such build: ", pkgname($name, $version, $build));
      }
      ($name, $version) = ($oname, $oversion) unless defined($name);
    }

    if(!$nourls)
    {
      if(s/^\[//)
      {
        $multi = true unless s/\]$//;
        if($_ eq "")
        {
          ($multi && @@args) || error("expected file after \"[\"");
          $_ = shift(@@args);
        }
      }

      while($multi || !@@urls)
      {
        if(s/\]$//)
        {
          $multi = false;
          last unless $_ ne "";
        }

        my($url);
        if(/^[\w\+]+:./)
        {
          $url = cleanurl($_);
          if(expand && $url =~ m!/$!)
          {
            my(@@expansion) = grep(lookslikepkgurl($_, $name, $version),
                linksfromurl($url));

            # filter out less desirable links, e.g. LVM2.0-stable.tgz
            # lilo-2.6.binary.tar.gz, zsh-4.2.1-doc.tar.bz2
            my(@@filtered) =
                grep(!/\b(latest|stable|binary|doc)\b/i, @@expansion);
            @@expansion = @@filtered if @@filtered;

            # filter out older versions of duplicated packages
            my(%bestver);
            for(@@expansion)
            {
              my($n, $v) = guessnv($_);
              $bestver{$n} = $v if defined($n) && defined($v) &&
                  (!defined($bestver{$n}) ||
                  (sort cmpab ($bestver{$n}, $v))[1] eq $v);
            }
            @@expansion = grep
            {
              my($n, $v) = guessnv($_);
              defined($n) && defined($v) && $bestver{$n} eq $v;
            } @@expansion;

            # filter out foo.tar.gz if foo.tar.bz2 is also present
            my(%expansion);
            $expansion{$_} = true for @@expansion;
            @@expansion = grep
            {
              my($xform) = $_;
              !($xform =~ s/\.\w+(\.g?z)?$/.tar.bz2/i && $expansion{$xform});
            } @@expansion;

            error("unable to expand $url") unless @@expansion;

            $url = shift(@@expansion);
            if(@@expansion)
            {
              if(defined($name) && !$multi)
              {
                $multi = true;
                push(@@expansion, "]");
              }
              unshift(@@args, @@expansion);
            }
          }
        }
        else
        {
          (-r && !-d) || error("unable to read file: $_");
          $url = fileurl($_);
        }
        push(@@urls, $url);

        if($multi)
        {
          @@args || error("expected \"]\" after \"$_\"");
          $_ = shift(@@args);
        }
      }

      @@urls || error("expected at least one file between \"[\" and \"]\"");
      ($name, $version) = guessnv(@@urls) unless defined($name);
    }

    push(@@result, [$name, $version, $build, @@urls]);
  }

  return @@result;
}

sub cmd_parse(@@)
{
  my(@@args) = @@_;
  my(@@pkgs) = parse(@@args);
  print("parsed ", scalar(@@args), " word(s) into ",
      scalar(@@pkgs), " package(s)\n");
  my($index) = 0;
  for(@@pkgs)
  {
    my($name, $version, $build, @@urls) = @@$_;
    print("package ", ++$index, ":\n");
    print(defined($name) ? "  name: $name\n" : "  no name\n");
    print(defined($version) ? "  version: $version\n" : "  no version\n");
    print(defined($build) ? "  build: $build\n" : "  no build\n");
    if(!@@urls)
    {
      print("  no urls\n");
    }
    else
    {
      print("  urls:\n");
      print("    $_\n") for @@urls;
    }
  }
  true;
}

##############################################################################

sub rejectall(@@)
{
  @@_ && error("unexpected argument: $_[0]");
  [];
}

sub allowall(@@)
{
  my(@@args) = @@_;
  \@@args;
}

sub rejectempty(@@)
{
  @@_ || error("arguments expected");
  @@_;
}

sub allowempty(@@)
{
  @@_ ? @@_ : [];
}

sub rejectmissing(@@)
{
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    error("no such package: ", pkgname($name, $version))
        unless defined($version) ? isversion($name, $version) : isname($name);
  }
  @@_;
}

sub rejectbuilds(@@)
{
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $build && error("unexpected build number: ",
        pkgname($name, $version, $build));
  }
  @@_;
}

sub requirename(@@)
{
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    defined($name) || error("unable to guess package name from urls: @@urls");
  }
  @@_;
}

sub requireurls(@@)
{
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    @@urls || error("filename or URL expected for " .
        pkgname($name, $version, $build));
  }
  @@_;
}

sub uselatestversion(@@)
{
  my(@@result);
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $version = latestversion($name, $version) if isname($name);
    push(@@result, [$name, $version, $build, @@urls]);
  }
  @@result;
}

sub emptytoall(@@)
{
  return @@_ ? @@_ : map([$_], allnames);
}

##############################################################################

sub parse_find(@@) { requirename(uselatestversion(emptytoall(rejectbuilds(parse(@@_))))); }
sub parse_add(@@) { rejectempty(parse(@@_)); }
sub parse_get(@@) { uselatestversion(emptytoall(rejectbuilds(parse(@@_)))); }
sub parse_build(@@) { uselatestversion(emptytoall(rejectbuilds(parse(@@_)))); }
sub parse_arm(@@) { uselatestversion(emptytoall(parse(@@_))); }
sub parse_rebuild(@@) { uselatestversion(emptytoall(rejectbuilds(parse(@@_)))); }
sub parse_upgrade(@@) { rejectmissing(uselatestversion(emptytoall(rejectbuilds(parse(@@_))))); }
sub parse_disarm(@@) { rejectempty(rejectmissing(parse(@@_))); }
sub parse_clean(@@) { allowempty(rejectmissing(parse(@@_))); }
sub parse_demolish(@@) { rejectempty(rejectmissing(parse(@@_))); }
sub parse_purge(@@) { rejectempty(rejectmissing(rejectbuilds(parse(@@_)))); }
sub parse_remove(@@) { rejectempty(rejectmissing(parse(@@_))); }
sub parse_edit(@@) { rejectempty(uselatestversion(rejectbuilds(parse(@@_)))); }
sub parse_rename(@@);
sub parse_change(@@) { requireurls(rejectempty(rejectmissing(uselatestversion(rejectbuilds(parse(@@_)))))); }
sub parse_status(@@) { allowempty(rejectmissing(parse(@@_))); }
sub parse_bug(@@) { allowempty(rejectmissing(parse(@@_))); }
sub parse_check(@@) { rejectall(@@_); }
sub parse_env(@@) { rejectall(@@_); }
sub parse_help(@@) { allowall(@@_); }
sub parse_man(@@) { rejectall(@@_); }

##############################################################################

sub parse_rename(@@)
{
  my(@@src) = @@_;
  my($dest) = pop(@@src);
  @@src || error("at least two arguments required for rename");

  $dest =~ m!^([^:/\.]*)/?([^:/]*)/?([1-9]\d*)?$! ||
      error("bad destination: $dest");
  my(@@destnvb) = emptytoundef($1, $2, $3);

  my(@@result);
  local($_);
  for(@@src)
  {
    m!^([^:/\.]+)(/([^:/]+)(/([1-9]\d*))?)?$! || error("bad source: $_");

    my($sname, $sversion, $sbuild) = emptytoundef($1, $3, $5);
    my($dname, $dversion, $dbuild) = @@destnvb;
    $dname = $sname unless defined($dname);
    $dversion = $sversion unless defined($dversion);
    $dbuild = $sbuild unless defined($dbuild);

    defined($sversion) == defined($dversion) ||
        error("missing source version: $_ -> $dest");
    defined($sbuild) == defined($dbuild) ||
        error("missing source build: $_ -> $dest");
    !defined($sbuild) || $sname eq $dname && $sversion eq $dversion ||
        error("illegal build move: $_ -> $dest");

    push(@@result, [$sname, $sversion, $sbuild, $dname, $dversion, $dbuild]);
  }

  return @@result;
}

##############################################################################

sub getsub($)
{
  my($subname) = @@_;
  my($result) = $subname =~ /^\w+$/ && checkedeval("\\&$subname");
  $result if defined(&$result);
}

##############################################################################

sub badcmd(@@)
{
  return &cmd(defaultcmd, @@_) if defaultcmd ne "help" && iscmd(defaultcmd);
  my($cmd) = @@_;
  select(STDERR);
  help;
  error("bad defaultcmd: " . defaultcmd) if defaultcmd ne "help";
  error("no such command: $cmd") if defined($cmd);
  error("command expected");
}

sub iscmd($)
{
  my($cmd) = @@_;
  !!(getsub("cmd_$cmd") || getsub("parse_$cmd"));
}

sub parseopts(@@)
{
  my($opt, $cmd, @@result);
  while(($opt = shift))
  {
    if($opt eq "--")
    {
      push(@@result, @@_);
      last;
    }
    elsif($opt !~ /^-/)
    {
      push(@@result, $opt);
      next;
    }

    $opt = "--help" if $opt =~ /^--?[h\?]$/i;
    if($opt =~ /^--?(\w+)=(.*)$/)
    {
      setopt(lc($1), $2);
    }
    elsif($opt =~ /^--?no(\w+)$/i)
    {
      setopt(lc($1), false);
    }
    elsif($opt =~ /^--?(\w+)$/)
    {
      my($name, $val) = (lc($1), @@_);
      if(iscmd($name))
      {
        error("conflicting command options: $cmd and $name")
            if $cmd && $cmd ne $name;
        $cmd = $name;
      }
      else
      {
        checkoptname($name);
        if(isboolopt($name) && !(defined($val) && isboolean($val)))
        {
          setopt($name, true);
        }
        elsif(!defined($val))
        {
          error("option $name requires an argument");
        }
        elsif($val =~ /^-/)
        {
          error("option $name requires an argument; found \"$val\" instead");
        }
        else
        {
          setopt($name, $val);
          shift;
        }
      }
    }
    else
    {
      error("unable to parse option: \"$opt\"");
    }
  }

  unshift(@@result, $cmd) if $cmd;
  return @@result;
}

sub cmd(@@)
{
  my($cmd, @@args) = @@_;
  setactivepkg();
  return badcmd unless defined($cmd);
  $cmd = lc($cmd);
  my($cmdsub) = getsub("cmd_$cmd");
  return &$cmdsub(@@args) if $cmdsub;
  my($parser) = getsub("parse_$cmd");
  return badcmd(@@_) unless $parser;
  my($doer) = getsub($cmd);
  my($result) = true;
  my($pid) = $$;
  for(&$parser(@@args))
  {
    my($name, $version) = @@$_;
    setactivepkg($name, $version);
    $result = false unless eval { &$doer(@@$_) };
    my($err) = $@@;
    setactivepkg();
    if($err)
    {
      die($err) if $$ != $pid;
      print STDERR "$@@\n";
      return false if stoponerror;
    }
  }
  return $result;
}

sub cmdline(@@)
{
  my(@@argv) = @@_;
  return help unless @@argv;
  return cmd(parseopts(@@argv));
}

##############################################################################

sub main(@@)
{
  $| = 1;
  my($result) = cmdline(@@_) ? 0 : 1;
  close(STDOUT) || error("close stdout: $!");
  exit($result);
}

##############################################################################

sub selfconfigure(@@)
{
  verbosify;

  my($prefix) = "/usr";
  my($arg);
  while(defined($arg = shift))
  {
    if($arg =~ /^--?prefix$/i)
    {
      $prefix = shift;
      error("expected argument for $arg") unless defined($prefix);
      next;
    }
    elsif($arg =~ /--?prefix=(.+)$/i)
    {
      $prefix = $1;
    }
    else
    {
      print STDERR "warning: ignoring argument $arg\n";
    }
  }

  explain("prefix is $prefix");

  my($mypackage, $mysource) = caller(0);

  writefile("Makefile", "# $genby\n", qq[
mysource = $mysource
myname = $myname
myversion = $myversion
prefix = $prefix
], map { my($l) = $_; $l =~ s/^ +/\t/gm; $l } q[
bindir = $(prefix)/bin
mandir = $(prefix)/man
man1dir = $(mandir)/man1

DESTDIR =

CP = cp
MKINSTALLDIRS = mkdir -p
POD2MAN = pod2man

prog = $(myname)
manpage = $(myname).1
targets = $(prog) $(manpage)
tarball = $(myname)-$(myversion).tar.gz

all: $(prog) $(manpage)

$(prog): $(mysource)
  $(CP) $(prog) $(mysource)

$(manpage): $(prog)
  $(POD2MAN) $(prog) > $(manpage) || rm -f $(manpage)

$(tarball): $(prog)
  ./$(prog) tarself < $(prog) > $(tarball) || rm -f $(tarball)

install: $(prog) $(manpage)
  $(MKINSTALLDIRS) $(DESTDIR)$(bindir) $(DESTDIR)$(man1dir)
  $(CP) $(prog) $(DESTDIR)$(bindir)
  $(CP) $(manpage) $(DESTDIR)$(man1dir) || true

dist: $(tarball)
]);
}

##############################################################################

sub strip0(@@) { my(@@args) = @@_; s/^0+$/0/ || s/^0+// for @@args; @@args; }

sub mytime()
{
  $mytimestamp =~ m|^(\d+)/(\d+)/(\d+) (\d+):(\d+):(\d+)$| || error;
  my($yr, $mo, $day, $hr, $min, $sec) = strip0($1, $2-1, $3, $4, $5, $6);
  checkedeval("use Time::Local; timegm($sec,$min,$hr,$day,$mo,$yr)") || error;
}

sub tar(;$$)
{
  my($name, $contents) = @@_;
  $contents = "" unless defined($contents);
  return pack("x512") unless defined($name) && $name ne "";
  my($magic, $uid, $gid, $user, $group, $mtime, $target) =
      ("ustar  ", 0, 0, "root", "root", mytime, "");
  my($isdir) = $name =~ m|/$|;
  my($islink) = $name =~ s/\@@$//;
  my($isex) = $name =~ s/\*$//;
  my($mode) = $isdir ? 040755 : $isex ? 0100755 : $islink ? 0120777 : 0100644;
  my($type) = $isdir ? 5 : $islink ? 2 : 0;
  ($target, $contents) = ($contents, "") if $islink;
  my($size) = length($contents);
  my($pad) = "\x00" x ((512 - ($size % 512)) % 512);
  $type = " $type";
  $_ = sprintf("%07o", $_) for($mode, $uid, $gid);
  $_ = sprintf("%011o", $_) for($size, $mtime);
  my($presum, $postsum) =
      (pack("Z100 Z8 Z8 Z8 Z12 Z12", $name, $mode, $uid, $gid, $size, $mtime),
      pack("a2 Z100 Z8 Z32 Z32 x183", $type, $target, $magic, $user, $group));
  my($sum) = sprintf("%06o\x00", unpack("%32C*", "$presum       $postsum"));
  return $presum . $sum . $postsum . $contents . $pad;
}

sub cmd_tarself(@@)
{
  error('try "make dist" instead') if @@_ || -t(STDIN) || -t(STDOUT);

  my($namever) = "$myname-$myversion";
  my($tarfile) = "$namever.tar";

  local(*TAR2GZIP);
  my($pid) = open(TAR2GZIP, "|-");
  defined($pid) || error("fork: $!");
  if($pid)
  {
    my($contents) = join('', (<STDIN>));
    binmode(TAR2GZIP) || error("binmode: $!"); # perl 5.8.0 utf8 bug
    print TAR2GZIP
        tar("$namever/"),
        tar("$namever/$myname*", $contents),
        tar("$namever/configure@@", $myname),
        tar("$namever/COPYING", license),
        tar;
    close(TAR2GZIP) && !$? or error("gzip filter subprocess returned $?");
  }
  else
  {
    local(*GZIP);
    open(GZIP, "gzip -c -9 |") || error("spawn gzip: $!");
    binmode(GZIP) || error("binmode: $!"); # perl 5.8.0 utf8 bug
    my($header);
    read(GZIP, $header, 10) == 10 || error;
    my($id, $cm, $flg, $mtime, $xfl, $os) = unpack("a2 C C L C C", $header);
    $flg == 0 || error("unexpected gzip flags");
    $flg |= 0x18; # FNAME + FCOMMENT
    $mtime = mytime;
    print(pack("a2 C C L C C Z* Z*",
        $id, $cm, $flg, $mtime, $xfl, $os, $tarfile, $myname), (<GZIP>));
    close(GZIP) && !$? or error("gzip returned $?");
    exit(0);
  }
}

##############################################################################

sub license()
{
  return << '--- END GNU GPL ---'; # the GNU GPL starts here:

		    GNU GENERAL PUBLIC LICENSE
		       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

		       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

--- END GNU GPL ---
}

##############################################################################

$0 =~ /\bconfigure$/i ? selfconfigure(@@ARGV) : main(@@ARGV);

##############################################################################

=head1 NAME

toast - packageless package manager for Unix systems and non-root users

=head1 SYNOPSIS

B<toast> S<[ I<OPTION> ... ]> S<[ I<COMMAND> ]> S<[ I<ARGUMENT> ... ]>

=head1 DESCRIPTION

B<toast> is a simple, self-contained tool for downloading, building,
installing, cleanly uninstalling, and managing software packages.
Unprivileged users can use it to install software in their home
directories.  System administrators can use it to temporarily or
permanently install software system-wide in a customizable location.
Unlike traditional package-management systems, B<toast> works directly
with software distributed as source code rather than requiring precompiled
binary packages from a central authority (though it can use those too).

=head2 Purpose

B<toast> is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

B<toast> is designed to be used in any of three ways:

=over 4

=item 1.

Installing and managing software in a non-root user's home directory.
Need to grab something recent or obscure in a hurry?  You don't need
to bug your distribution's maintainers or the IT department at work,
and you don't need to build it or even find and download it yourself;
B<toast arm FOO> does it all.

=item 2.

Installing and managing software packages as root, in parallel to those
installed by a conventional package manager.  For instance, I can install
the latest OpenSSH client system-wide (in C</usr/local>) with B<sudo
toast arm openssh>, then cleanly remove it after my distribution or
vendor releases an official package with B<sudo toast remove openssh>.

=item 3.

Installing and managing all software for an entire Unix system; that is,
using B<toast> as the one true package manager for the system.  Not a
common use case, to be sure, but isn't it nice to know that the tool
you're using is up to the task?

=back

=head2 Requirements

B<toast> itself has been known to work with Perl 5.005_03 through 5.8.x
under Linux, FreeBSD, Solaris, MacOS X, and Cygwin, without relying on
the presence or absence of any Perl modules or other tools.  Perl is
available for download at C<http://www.cpan.org/src/stable.tar.gz>.
Although it isn't required, B<toast get> works better if you have
GNU wget; you can use C<toast arm wget> to download and install it if
necessary.  Additional requirements for B<toast build> vary according
to the package being built.

=head2 Setup

To have the latest version of B<toast> download and install itself in your
home directory, run one of the following commands as a non-root user.
(See below for instructions to install as root.)  The first command
requires GNU wget.  The second relies on the GET utility that comes
with the LWP Perl module.  The third command is broken over three lines,
though your shell should let you paste it exactly as written; it relies
only on Perl with no modules at all.

  wget -O- http://toastball.net/toast/toast|perl -x - arm toast

  GET http://toastball.net/toast/toast|perl -x - arm toast

  perl -e 'socket(S,2,1,0)&&connect(S,pack("Sna4x8",2,80,gethostbyname(
      $h="toastball.net")||die("dns")))&&syswrite(S,"GET /toast/toast "
      ."HTTP/1.0\nHost: $h\n\n")&&open(STDIN,"<&S")&&exec($^X,qw(-x -
      arm toast))||die($!)'

Of course, if you already have a previous version of B<toast> up and
running, just type C<toast upgrade toast>.  If B<toast> is installed
system-wide, but you want to install the latest version in your home
directory, try C<toast arm toast>.

B<toast> should now have installed itself and everything it
needs under C<I<$HOME>/.toast>.  You'll probably need to add
C<I<$HOME>/.toast/armed/bin> to your C<PATH> environment variable in order
to be able to use B<toast> and any other packages it installs.  You can
adjust C<PATH> (and a few other useful variables) with this command:

  eval $($HOME/.toast/armed/bin/toast env)

It probably makes sense to add the above command to your C<.zshenv> or
C<.profile> or whatnot, so that your environment variables will be set
up automatically whenever you log in.  For more information, run C<toast
help env>, or just C<toast env> to see what variables would be set.

Before using B<toast> to install itself as root, it is recommended (but
not required) that you create a C<toast> user for building packages,
or create a configuration file specifying an alternate username (C<fred>
in this example):

  echo 'username=fred' >> /etc/toast.conf

If you skip this step, B<toast> will search for an unused UID and GID,
which could conceivably cause security warnings or other problems.

If you want to use directories other than C</toast> for the package
repository and C</usr/local> for symlinks to armed packages, now would
be a good time to specify those as well, since relocating armed packages
can be tricky and time-consuming:

  echo 'storedir=/path/to/use/to/store/files' >> /etc/toast.conf
  echo 'armdir=/place/to/put/symlinks/to/armed/packages' >> /etc/toast.conf

Once the C<toast> user and/or C</etc/toast.conf> configuration file has
been created, just execute as root one of the same three download/install
commands given above for non-root users.  When using the default B<armdir>
location of C</usr/local>, you probably won't need to bother with the
B<toast env> stuff described above, but when using another location,
you may wish to put some variation on the B<toast env> command given
above in C</etc/profile> or something.

The above procedure is by no means required in order to install or
use B<toast>.  Both the uncompressed B<toast> script and an official
compressed tarball distribution containing B<toast> are available for
download at C<http://www.toastball.net/toast/>. The unmodified B<toast>
script can be copied to and run from any location, and you can use
B<toast man> to view the man page without having to install it first.
The default option settings should be sensible, and any necessary
directories will be created as needed.

A GNU-like C<configure> program (OK, symbolic link) is also provided
with the official B<toast> distribution for your convenience.  You can
supply an alternate installation directory prefix with C<./configure
--prefix=foo>, or keep the default prefix of C</usr> by running
C<./configure> without arguments.  Then run C<make>, become root if
necessary, and run C<make install>, which will install both the B<toast>
program and a man page.  C<DESTDIR> also works as expected.  Sadly,
B<toast>'s C<configure> script does not support most of the other
command-line options and features of B<configure> scripts produced by
the real GNU autoconf.

=head2 Commands

=over 4

=item S<B<toast find> I<PACKAGE> ...>

Locates URLs from which a package could be downloaded.  This command does
not write to the disk at all.  The output format is similar to that of
B<toast status>, but all information comes from the network rather than
the on-disk package database.  If a given package has not been added and
no URLs were specified on the command line, B<toast find> looks for an
exact name match on the web sites specified by the B<findsites> option;
otherwise it attempts to list the directory or directories to which the
package's URL(s) belong.  If an explicit version number is given, only
that version is listed; otherwise all versions are listed from oldest
to newest.

=item S<B<toast add> I<PACKAGE> ...>

Adds new packages to the repository by storing URLs.  Use this command to
store package file locations without actually downloading anything.  Each
I<PACKAGE> must specify at least one URL or file unless the B<autofind>
option is enabled.  Absolute and relative pathnames are automatically
translated into file URLs.  If the given package has already been added,
the command merely compares the given URLs against those already stored
and gives an error if they don't match; use B<toast remove> or B<toast
change> to specify new URLs for an existing package.

=item S<B<toast get> [ I<PACKAGE> ...]>

Ensures that the given packages have been downloaded.  Implies B<toast
add>.  If no arguments are given, acts on the latest version of every
existing package.  After this command completes successfully, other
commands will be able to operate on the package without downloading
any additional files from the network.  If a given package is already
C<stored>, the existing downloaded files are silently preserved; use
B<toast purge> to force them to be downloaded afresh.  If GNU B<wget>
is installed, B<toast get> will use it to fetch C<http>, C<https>, and
C<ftp> URLs; otherwise, if LWP is installed, B<toast get> will use the
B<GET> utility to fetch those types of URLs; otherwise B<toast get>
will try to fetch C<http> and C<ftp> URLs itself using rudimentary
built-in routines.  B<toast get> always handles C<file> URLs itself.
If B<ssh> is available, B<toast get> can use it to fetch (non-standard)
URLs of the form C<ssh://[username@@]hostname/absolute/path/to/file>.
If B<cvs> is available, B<toast get> can also handle (even less standard)
URLs of the form C<cvsroot[+ssh]:$CVSROOT/module[#unixtime]>; note that
$CVSROOT often starts with a colon, resulting in two colons in a row.
If B<git> is available, B<toast get> can handle similar non-standard
URLs of the form C<git:repository[#commit]>; this feature is experimental
and details of its behavior remain subject to change.

=item S<B<toast build> [ I<PACKAGE> ...]>

Ensures that the given packages are compiled and ready.  If no arguments
are given, acts on the latest version of every existing package.
Packages that already have at least one C<built> or C<armed> build (as
reported by B<toast status>) are skipped by this command without causing
an error; use B<toast rebuild> to force such packages to be rebuilt.
Building may involve implicitly invoking B<toast get>, decompressing and
extracting archives, applying patch files, compiling a new build of the
package and installing it in a build-specific directory tree.  Supported
archive formats include compress, gzip, bzip2, zip, rpm, deb, cpio,
tar, shar, patch, and most combinations of the above.  You don't need to
have RPM installed to extract .rpm files; cpio should usually suffice.
Similarly, only tar should be required to extract .deb files.  Note that
toast completely ignores dependencies and other meta-information in .rpm
and .deb files; only the raw binaries are extracted and used.  Archives
should contain either precompiled binaries or source code, which will
be identified and/or built according to heuristics too mind-numbing to
describe completely; in the case of source files, a C<configure> script,
C<Makefile> or similar is often required.  Many options can influence
this command's behavior; see the options reference for full details.

=item S<B<toast arm> [ I<BUILD> | I<PACKAGE> ...]>

Installs symbolic links to allow builds to be used.  This is perhaps the
most frequently used B<toast> command.  It is normally required before
programs compiled by B<toast build> or B<toast rebuild> can be run.  If no
arguments are given, acts on the latest version of every existing package.
If no explicit build number is supplied for a given package, B<toast
build> is implied, and the latest C<built> or C<armed> build is armed.
If a build to be armed is already in the C<armed> state, this command
has no effect.  The B<armdir> option controls where the symbolic links to
the files in each armed build will be installed; the default location is
C</usr/local> (for root) or C<I<$HOME>/.toast/armed> (for everyone else).
Non-root users might want to add C<I<$HOME>/.toast/armed/bin> to the
C<I<$PATH>> environment variable to make it easier to run armed packages.
Existing links to other builds are moved out of the way if necessary,
and the corresponding builds are still considered to be armed.

=item S<B<toast rebuild> [ I<PACKAGE> ...]>

Forces packages to be built or rebuilt.  If no arguments are given,
acts on the latest version of every existing package.  A new build
will be created as if by B<toast build> for every package given, even
if the package has already been successfully built.  Each package can
have any number of independent builds.  Builds for a given package are
automatically assigned sequential numbers starting from 1.  Many options
can influence this command's behavior; see the options reference for
complete details.

=item S<B<toast upgrade> [ I<PACKAGE> ...]>

Checks for a later version of an existing package.  If no arguments are
given, this command acts on the latest version of every existing package.
The existing package's URLs are used as a starting point to locate the
new version.  If the filename component of a given URL doesn't appear to
contain the package's version number, that URL will be left unmodified
for the new version; otherwise, the directory portion of the URL will
be immediately downloaded and searched for a similar URL containing a
higher version number.  The command fails if no URLs would change or if
no single consistent newer version for all version-containing URLs can be
found; otherwise, the highest eligible version is used for all modified
URLs and the package itself.  The command performs an implicit B<add>,
B<get>, B<build> or B<arm> on the extrapolated URLs so as to match the
state of the given existing version, except that an implicit B<arm>
will become an implicit B<build> if the B<autoarm> option is disabled.

=item S<B<toast disarm> I<BUILD> | I<PACKAGE> ...>

Deletes symlinks created by B<toast arm>.  This works by removing
symbolic links to the given build and replacing any links that had been
moved out of the way.  No error occurs if no such links exist.  If no
build number is given, all C<armed> builds, including C<mismatched>
builds reported to be C<armed>, are disarmed.  If the package version
number is also omitted, all C<armed> builds belonging to packages with
the given name are disarmed.  Disarming a build always removes links from
the I<ARMDIR> specified by the B<armdir> option at the time the package
was built, the I<ARMDIR> currently specified by the B<armdir> option,
and any I<ALTARMDIRS> currently specified by the B<altarmdirs> option.
Disarming a build only removes hard or symbolic links to the actual
build files stored in I<STOREDIR>.

=item S<B<toast clean> [ I<BUILD> | I<PACKAGE> ...]>

Removes intermediate files and broken builds.  If no arguments are
given, all builds are cleaned.  If no explicit version and/or build
number is given, all matching versions and/or builds are cleaned.
Cleaning a broken build removes the build entirely; otherwise only
files that are not required by B<toast arm> are removed from the build.
These typically consist of files created directly by B<toast> as part
of the build environment, extracted source files, and intermediate files
created by the package itself during compilation.  Some kinds of binary
packages that do not involve intermediate files never require cleaning,
and B<toast build> and B<toast build> may automatically perform this
step if the B<autoclean> option is enabled.  Builds that are still in
the C<building> state (as reported by B<toast status>) are silently
ignored by this command.

=item S<B<toast demolish> I<BUILD> | I<PACKAGE> ...>

Deletes one or more builds.  If no version and/or build number is
given, all matching builds are disarmed.  If one of the builds to be
demolished is currently armed and the B<autodisarm> option is disabled,
B<toast demolish> reports an error and no builds are deleted; otherwise,
B<toast disarm> is implied.  Demolishing a package reverses the effects
of B<toast build> or B<toast rebuild> (and, optionally, B<toast arm>),
but never those of B<toast get> or B<toast add>.

=item S<B<toast purge> I<PACKAGE> ...>

Deletes files downloaded by B<toast get>.  Deletes toast's local copy of
the original archive used to build the given package or set of packages.
Existing builds are not affected by this command, but creating a new
build will implicitly reinvoke B<toast get>.  If the B<autopurge> option
is enabled, B<toast build> or B<toast rebuild> may implicitly invoke
this command.

=item S<B<toast remove> I<BUILD> | I<PACKAGE> ...>

Deletes a build, a package, or a set of packages.  Removing a build has
the same effect as B<toast demolish>.  Removing a package deletes all
of its builds and additionally reverses the effects of B<toast get> and
B<toast add>.  If any of the builds to be deleted is currently armed,
and the B<autodisarm> option is disabled, B<toast remove> reports an
error and nothing is removed; otherwise B<toast disarm> is implied.

=item S<B<toast rename> I<PACKAGE> ... I<NEWNAME>>

Renames an existing package or set of packages.  The package or packages
must already exist.  I<NEWNAME> uses the same syntax used to refer to
an existing package or build, except that the destination package must
not already exist and must contain the same number of slash characters as
I<PACKAGE>.  This command can also be used to renumber builds.  Currently,
armed packages or builds must be disarmed before they can be renamed.

=item S<B<toast change> I<PACKAGE> ...>

Changes the stored URLs for an existing package or packages.  Use with
caution!  Each package must already exist, and at least one URL must be
given explicitly for each.  The URL or URLs previously stored for each
package by B<toast add> will be discarded and replaced by the given URL
or URLs.  No further action is taken; in particular, neither B<toast get>
nor B<toast purge> is implied.  Note that it is often simpler and safer to
remove and then re-create a package than it would be to use this command.

=item S<B<toast status> [ I<BUILD> | I<PACKAGE> ] ...>

Displays information about packages and builds.  If invoked without
arguments, displays information about all packages and builds.  A package
is marked as C<stored> only if the original files have been downloaded by
B<toast get> and haven't been deleted by C<toast purge>.  The package URLs
may also be listed; see the B<showurls> option.  Every package has zero
or more builds, each of which is either C<building> (if B<toast build>
or B<toast rebuild> is still running), C<broken> (if it failed), C<built>
(if it succeeded), or C<armed> (by B<toast arm>).  In the last two cases,
the build will be marked C<(not clean)> if intermediate files created
by B<toast build> have not yet been removed by C<toast clean>.

=item S<B<toast bug> [ I<BUILD> | I<PACKAGE> ] ...>

Sends a bug report about a broken build.  Use this command to let
me know when you think B<toast> ought to be able to build a package,
but it isn't working.  If you would like to hear back from me about
your bug report, or if there's anything else you think I should know,
email me at C<toast-bugs@@toastball.net>.  If invoked without arguments,
sends build output from the most recent broken build; otherwise, sends
build output from the most recent broken build for each argument.  Build
output for each broken build is stored in a file called B<broken.log>
somewhere under I<STOREDIR>; each file contains full output from the
build subprocess (the indented lines printed by B<toast build> unless
the B<quiet> option is in force).

=item S<B<toast env>>

Prints shell commands to make armed packages usable.  This command is
normally invoked with C<eval $(toast env)> from a shell initialization
file such as C<.zshenv> or C<.profile>.  This will add I<ALTARMDIR>C</bin>
to the front of C<PATH> for each I<ALTARMDIR>, in order.  (By default,
I<ALTARMDIR> is the same as I<ARMDIR>, which usually defaults to
C<~/.toast/armed>; this is the directory that contains a merged view of
all armed packages.)  If a particular I<ALTARMDIR>C</bin> already appears
anywhere in C<PATH>, it will remain in its current position instead
of being added or moved to the front of B<PATH>.  Other environment
variables are similarly affected: C<MANPATH> (used to find man pages),
C<INFOPATH> (used by GNU info), C<CPATH> (used by gcc to find include
files), C<PKG_CONFIG_PATH> (used by pkg-config to find C<.pc> files),
C<XML_CATALOG_FILES> (used by DocBook and other tools to locate XML
catalogs), C<LIBRARY_PATH> (used by GNU ld to find libraries), and
C<LD_LIBRARY_PATH> (which has the same effect as C<LIBRARY_PATH> and
additionally affects all shared library loading at run time; see B<toast
help libvar> for less drastic alternatives).  Note that if C<MANPATH>
in particular is unset, B<toast env> will run C<man -w> to try to get
the default value; if this causes problems, it may help to ensure that
C<MANPATH> is set before invoking B<toast env>.  This command assumes
a Bourne-like shell -- zsh and bash will work, tcsh won't.  None of
this is likely to be necessary if I<ARMDIR> is C</usr> or C</usr/local>
(the default when running as root).

=item S<B<toast help> [ I<TOPIC> ] ...>

Summarizes usage information from the B<toast> man page.  If invoked
without arguments, displays a one-line summary of every command.
If invoked with an argument, displays a longer summary of the given topic,
which may be a command name, an option name, C<commands> or C<options>.
If B<toast> itself is invoked without any arguments, B<toast help>
is assumed.  Note that most information displayed by this command is
taken directly from a subset of the B<toast> man page.

=item S<B<toast man>>

Displays the complete B<toast> man page.  You're either reading the man
page now, or reading something that was derived from it (such as the
output of B<toast help>).  This command is supposed to behave about the
same way C<man toast> would, but it doesn't require the C<man> program or
the C<toast> man page to be installed.  If standard output is a tty, the
man page is formatted using C<Pod::Text::Overstrike>, C<Pod::Termcap>,
C<Pod::Text> or the rudimentary internal formatting routine used
by B<toast help>, and the formatted page is piped to C<$MANPAGER>,
C<$PAGER>, C<less -ir>, or C<more>, or dumped directly to the terminal
as a last resort.  If output is redirected to a file or pipe, the man
page is rendered as plain text using C<Pod::Text> if available or the
internal routine otherwise.  If you want more control over the output,
try feeding the C<toast> script itself to S<C<pod2text>>, C<pod2html>,
C<pod2man>, or C<pod2latex>, all of which are command-line utilities
that accepts lots of exciting switches and things and that come bundled
with recent versions of Perl.

=back

=head2 Arguments

Most commands take one or more arguments denoting packages or builds.
Such arguments usually follow one or more of the forms below.  Note that
not all commands accept all of these forms; in fact, some commands
(like B<toast help>) accept none of them.

=over 4

=item I<NAME>[B</>I<VERSION>]

This syntax can be used to refer to an existing package.  If the
package does not exist and the B<autofind> option is set, it will be
located automatically; if B<VERSION> is omitted, the latest available
version will be used.  If B<NAME> matches a previously-added package and
B<VERSION> is omitted, the latest existing version is used, except when
the documentation for the command specifically says that it affects all
versions or operates on sets of packages, in which case all versions
are affected.  Examples: C<wget>, C<gcc/3.2.2>, C<openssl/0.9.7b>

=item I<NAME>B</>I<VERSION>B</>I<BUILDNUM>

This syntax is used to refer to an existing build of an existing package.
Builds are numbered consecutively starting from 1.  Many commands don't
accept individual builds as arguments; the usage information for those
commands that do accept builds always uses the term I<BUILD> explicitlly.
Examples: C<xdaliclock/2.19/1>, C<glibc/2.3.2/4>.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] I<URL>>

This syntax is most often used to implicitly add a new package by
URL, though many commands also allow it to be used to refer to an
existing package.  If the package name and version are omitted,
they will be guessed based on the filename portion of the URL; if
the package already exists, it will be found only if the guessed
name and version match those used to add it.  An error will occur
if the given package exists but has different URLs.  Examples:
C<ftp://alpha.gnu.org/gnu/tar/tar-1.13.25.tar.gz>, S<C<ps/3.1.8:
http://procps.sf.net/procps-3.1.8.tar.gz>>.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] I<PATH>>

This syntax can be used to add a new package from a local file.
The given path is automatically translated into an absolute file URL.
Unlike a file URL, the path will be checked as soon as it is parsed
to ensure that it refers to a readable file; if it does not, a fatal
parse error will occur and the entire command will not be invoked,
even if previous arguments were parsed without error, the package
already exists, or the B<stoponerror> option is disabled.  Examples:
S<C<myprog/0.1test: myprog.zip>>, C</home/anandam/gdb-5.3.tar.gz>,
C<../../mnt/ain/ain/opt/stow/xplanet/xplanet-1.0.1.tar.gz>.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] B<[> I<URL> | I<PATH> ... B<]>>

This syntax can be used to add a package that requires multiple URLs
and/or local files by grouping them between literal square brackets.
As with the previous two forms, the name and version number may be
omitted, in which case they will be guessed from the given filenames.
If the filenames are very dissimilar, only the first will be
used to guess the package name and version number.  Otherwise,
the order of URLs and/or paths is not significant.  Examples: C<[
http://www.kernel.org/pub/linux/kernel/v2.4/linux-2.4.20.tar.bz2
linux-2.4.20-config.tgz ssh://vulture/home/matt/linux-2.4.20.patch ]>,
S<C<[ http://ftp.gnu.org/gnu/glibc/glibc-{,linuxthreads-}2.3.2.tar.bz2 ]>>,
S<C<XFree86/4.3.0: [ X430src-[1-7].tgz ]>>.  (The last two examples
respectively involve brace and glob expansion performed by your shell).

=back

Every command that accepts a I<PACKAGE> argument will accept several
I<PACKAGE> arguments in sequence, so multiple files or URLs will always
be treated as distinct packages unless they are explicitly grouped into
a single package using square brackets as shown above.  For instance,
S<C<toast add *>> puts each file in the current directory in its own
package, while S<C<toast add [ * ]>> tries to combine them all into a
single package.

=head2 Options

=over 4

=item B<--storedir=>I<STOREDIR>

Defines the root of the directory tree B<toast> uses to store and build
all packages.  I<STOREDIR> must be given as an absolute path or a fatal
error will result.  B<toast add> and commands that explicitly invoke it
will create I<STOREDIR> if it doesn't already exist.  Default: C</toast>
if invoked by root, C<I<$HOME>/.toast> otherwise.

=item B<--armdir=>I<ARMDIR>

Defines the directory under which B<toast arm> creates symlinks to
compiled package files in I<STOREDIR>.  B<toast build> also tries to use
this value as a prefix when compiling most packages.  With few exceptions,
I<ARMDIR> should point to the same directory when arming a given package
that was used when building that package.  If I<ARMDIR> is not given as
an absolute path, it is taken to be relative to I<STOREDIR>.  I<ARMDIR>
and should probably not contain I<STOREDIR>, and should probably not be
contained by I<STOREDIR> either unless I<ARMDIR> is C<armed>, though these
restrictions are not enforced.  It's usually a good idea for I<ARMDIR>
to be C</usr> or C</usr/local> if feasible, since some broken packages
may not work if installed in a different location.  Default: C</usr/local>
if invoked by root, C<armed> otherwise.

=item B<--altarmdirs=>I<ALTARMDIR>[:I<ALTARMDIR>]...

Optionally specifies one or more colon-separated directories to use
instead of or in addition to the I<ARMDIR> given by the B<armdir> option.
An empty list or an empty list item stands for the current value of
I<ARMDIR>.  Commands that check to see if a package is already armed look
for links back into I<STOREDIR> in the current I<ARMDIR> and all current
I<ALTARMDIRS>, as well as the I<ARMDIR> stored by B<toast build> when the
package was built.  B<toast disarm> additionally removes any such links
it finds.  B<toast env> is the only command that uses I<ALTARMDIR>s but
ignores I<ARMDIR>.  The reverse is true of B<toast build>, which uses
and stores I<ARMDIR> only, ignoring I<ALTARMDIRS>.  Note that B<toast>
will never write to any I<ALTARMDIR> except for I<ARMDIR> unless the
I<ALTARMDIR> actually contains hard or symbolic links to files in
I<STOREDIR>.  Default: empty list (equivalent to listing I<ARMDIR> alone).

=item B<--username=>I<USER>

When invoked as root, B<toast build> will unpack, compile, and install
packages under I<USER>'s UID and GID as returned by C<getpwnam(3)>.
Note that any additional groups (such as those in C</etc/groups>) will
be ignored, as will I<USER>'s password, home directory, shell, and so on.
Default: C<toast>.

=item B<--fallbackuid=>I<UID>

If B<toast> is invoked as root and needs to do something as a non-root
user, it normally runs as the user given by the B<username> option.
However, if no such user exists, B<toast> will search for an unused
UID to use instead, starting at I<UID>.  Use 0 to disable this feature.
Default: C<23>.

=item B<--nice=>I<N>

If I<N> is a nonzero integer, the build subprocess spawned by B<toast
build> will silently attempt to adjust its sheduling priority ("niceness")
by the given delta.  In keeping with wacky Unix tradition, positive I<N>
causes the build process to run at a lower priority, while negative I<N>
denotes a higher priority.  Negative I<N> works only when B<toast> is
invoked as root.  Usually I<N> ought to be between 20 and -20, but other
values might be useful if B<toast> is invoked on a strange platform or at
an unusual initial priority.  Note that B<toast> will not fail or even
warn if I<N> is non-numeric, or too small, or if the priority cannot
be adjusted for any other reason, except that if I<N> is too large,
it will be silently demoted to the largest useful value.  Default: 10.

=item B<--postarmprog=>I<PROG>

If I<PROG> is non-empty, B<toast arm> and B<toast disarm> will execute
it immediately after arming or disarming one or more packages.  I<PROG>
can contain multiple words and/or shell metacharacters and will be parsed
and executed according to Perl's usual conventions, so it can actually
refer to more than one program.  If I<PROG> returns non-zero (failure),
the command will also fail.  Default: C</sbin/ldconfig> if invoked by
root, empty string otherwise.

=item B<--defaultcmd=>I<COMMAND>

Sets an implicit command to be assumed if B<toast> is invoked with
at least one command-line option or argument but no explicit command.
I<COMMAND> may be the name of any valid toast command.  As a special
case, the value C<help> causes B<toast> to print an error message and
a list of valid commands if no explicit command is given.  Note that
invoking B<toast> without command-line options or arguments is always
equivalent to running B<toast help>, regardless of this option's setting.
Default: C<help>.

=item B<--stickyopts=>I<OPTNAMES>

Sets the list of per-package command-line options implicitly stored
in B<storedir> for automatic re-use by later invocations of B<toast>.
I<OPTNAMES> is either a whitespace- and/or punctuation-separated list
of option names.  The word C<all> may also appear on the list; it
stands for the names of all options except for the B<stickyopts> option
itself.  The empty list is allowed.  Case is not significant.  Note that
B<stickyopts> only determines which options are stored (or removed from
storage); it can not be used to prevent previously stored options from
being implicitly loaded and re-used.  B<toast> will implicitly store
an option listed in I<OPTNAMES> only if it is specifically mentioned
on the command line; options read from the environment or from files on
disk are never implicitly stored.  If the value explicitly given on the
command line is the same value that would otherwise have been used if
no command-line options had been given and no per-package options were
stored, and that option is already stored, the option is removed from
storage instead of being stored.  If B<crossversion> is enabled, this
option writes to a file that applies equally to all same-name packages,
regardless of version number; otherwise, this option writes to a different
file that applies only to a single package name and version number taken
together.  Values stored in the more specific file (name and version)
always override values stored in the less-specific file (name only).
Default: C<reconfigure confappend makeappend compilecmd installcmd>.

=item B<--findsites=>I<SITELIST>

Set the list of web sites or other locations searched by B<toast
find> for packages that have not already been added.  I<SITELIST> is a
space-separated list of URLs and/or special words taken from the following
list: C<freshmeat>, C<googlecode>, C<sourceforge>, C<gnu>, C<cpan>, or
C<all> (which stands for all of the preceding words in the order given).
The C<*> character will be replaced by the name of the package to find
wherever it occurs.  If you want a literal C<*> character, too bad.
Default: C<all>.

=item B<--httpproxy=>I<URL>

If I<URL> is non-empty, B<toast get> will use the given URL as the
proxy server for C<http> and C<https> URLs.  When using B<wget> or
B<GET>, the given URL will be exported in the C<http_proxy> environment
variable without further checking if non-empty.  When using built-in
HTTP, the proxy URL should be of the form C<I<hostname>:I<port>> or
C<http://I<hostname>:I<port>/>; other forms may also work.  Note that
using an empty URL will not cause C<http_proxy> to be removed from the
environment of B<wget> or B<GET>.  The proxy string is not exported
during B<toast build>.  Default: the current value of the C<http_proxy>
environment variable, or the empty string if that variable is not set.

=item B<--ftpproxy=>I<URL>

The B<ftpproxy> option is just like the B<httpproxy> option, but applies
to C<ftp> URLs.  Note that this really refers to an FTP-to-HTTP gateway,
rather than a true FTP proxy server.  Default: the current value of the
B<ftp_proxy> environment variable, or the empty string if that variable
is not set.

=item B<--confappend=>I<ARGS>

Specifies additional arguments for B<toast build> to pass to a package's
C<configure> script or equivalent, if any.  This should never be necessary
in order to build a package correctly (if it is, use B<toast bug> to send
me a bug report!), but it can be awfully handy at times.  The I<ARGS>
string is treated as a list of space-separated words, each of which may
be optionally quoted with single or double quotes with backslash acting
as an escape character; the resulting words are added to the end of the
command line.  Note that by default, this option's value may be saved
with the package and reused by future invocations of B<toast>; see the
B<stickyopts> option for details.  Default: empty string.

=item B<--makeappend=>I<ARGS>

The B<makeappend> option is just like the B<confappend> option except
that it applies to the C<make> command or commands (if any) invoked
by B<toast build>.  As with B<confappend>, use of this option should
never be necessary; if you find a package that won't build without it,
please send me a bug report!  Default: empty string.

=item B<--compilecmd=>I<CMD>

Specifies an alternate shell command to compile (but not install)
a package.  See the B<installcmd> option for further discussion of
what this option does and does not do.  If I<CMD> is the empty string,
B<toast build> uses built-in heuristics to figure out what to do based
on the package contents.  Otherwise, it will execute I<CMD> as a shell
command according to Perl's usual conventions, which is to say that
I<CMD> may contain multiple words, shell metacharacters, and so on.
I<CMD> will be invoked from the top-level source directory, unless that
directory contains nothing but a single subdirectory, in which case
B<toast> will change to that directory first, repeating if necessary.
A reasonable value for I<CMD> might look something like C<./configure &&
make>; a similarly reasonable value for the B<installcmd> option might
be C<make install>.  You probably wouldn't want to specify exactly those
commands, of course, since B<toast> could figure those out on its own; if
it tries something fancier instead, the B<noreconfigure> option might do
what you want.  These options are intended to make it easier to customize
specific packages; if you encounter a package that won't compile at all
without them, I'd appreciate a bug report.  If all you really need is to
pass an extra argument or two to a C<configure> script or set a C<make>
variable, consider using B<confappend> or B<makeappend> instead.  Default:
empty string (compile automatically).

=item B<--installcmd=>I<CMD>

Specifies an alternate shell command to install a compiled package.
This option is analogous to the B<compilecmd> option; see that option's
description for important details.  B<toast build> always installs a
package in a separate step immediately after successfully compiling
it.  The compilation step must not attempt to write to any directory
outside the source directory (with a few exceptions, such as C</tmp>
and C</dev/null>).  Before invoking the install command, B<toast build>
will set a special environment variable, C<DESTDIR>, to the path of a
private directory tree (containing subdirectories such as C<bin> and
C<lib>) under which the package should install itself.  In principle,
the install step should write only to C<DESTDIR>.  If the install step
attempts to write outside of C<DESTDIR>, the source directory, or a few
other exceptional filesystem locations, B<toast> may attempt to redirect
the write to C<DESTDIR> using a variety of means including (but not
limited to) that described under the B<preload> option.  Because these
rewriting mechanisms can sometimes be prone to failure, it's best to
restrict actions taken during the install step to the minimum required.
Default: empty string (install automatically).

=item S<B<--quiet> | B<--noquiet>>

When B<quiet> is enabled, most commands will produce output only on
failure.  Some commands, such as B<toast status>, are not affected by
this flag.  Default: disabled.

=item S<B<--expand> | B<--noexpand>>

When B<expand> is enabled, any URL ending in a slash encountered
while parsing the command line that will be treated as a pointer to a
directory listing whose contents are to be fetched, parsed, filtered, and
interpolated into the command line.  The filtering heuristic scans for
links that seem likely to be package URLs, without actually retrieving
anything other than the single directory URL given.  If a package name
and/or version number are given on the command line, those are taken
into account by the filter.  Use square brackets on the command line or
specify an explicit name or version number to force all of the resulting
URLs to be grouped into a single package, or omit brackets and name to
let B<toast> decide for itself whether and how to group the new URLs
into packages.  If B<expand> is disabled, URLs ending in slashes will not
receive any special treatment, and B<toast> will never attempt to fetch
anything from the network while it is still parsing the command line.
Default: enabled.

=item S<B<--autofind> | B<--noautofind>>

When B<autofind> is enabled, B<toast add> and other commands will
automatically look up package URLs as if by B<toast find> when none
have been added previously or given explicitly.  If no version number
is given either, the latest version found will be used.  Default: enabled.

=item S<B<--autochange> | B<--noautochange>>

When B<autochange> is enabled, B<toast get> may replace the URLs stored by
B<toast add> with the actual URLs of the files it downloaded.  When it is
disabled, URLs stored by B<toast add> will never change without warning.
This only matters in cases where the URL stored by B<toast add> actually
points to an HTML page or FTP directory, which used to happen all the time
back when the B<toast find> heuristic was more naive and the B<expand>
option didn't exist.  Enabling this option now seems more likely to
cause problems than to solve them.  Default: disabled.

=item S<B<--autorename> | B<--noautorename>>

When B<autorename> is enabled, B<toast get> may try to use information
gained after downloading files to attempt to guess a new name for any
implicitly added package for which no name and/or version number was
specified on the command line or could be guessed from the URLs given.
If B<autochange> is also enabled, new URLs are first used to try to
guess a new name; if this fails, the contents of the downloaded files
are examined.  If either method results in a new name being guessed,
the package is renamed automatically as if by B<toast rename>, and
any further processing continues under the new name.  If B<autorename>
is disabled, packages with unguessed or partially guessed names always
keep the unique names automatically assigned by B<toast add> based on
URLs alone (version number will be C<unknown> optionally followed by
a serial number for uniqueness; name may have been guessed or may also
be C<unknown>).  Default: enabled.

=item S<B<--autoenv> | B<--noautoenv>>

When B<autoenv> is enabled, B<toast> will automatically export the
environment variable settings printed by B<toast env> to any programs
invoked while building a package.  This may help the package being built
to locate other armed packages on which it depends.  Default: enabled.

=item S<B<--autoclean> | B<--noautoclean>>

When B<autoclean> is enabled, commands that create a new build for a
package (such as B<toast rebuild>) implicitly remove any pre-existing
broken builds from that package before creating the new build; also,
whenever a new build succeeds, it is implicitly cleaned as if by B<toast
clean>.  Note that newly created broken builds will not be immediately
cleaned or removed, even if this option is enabled, so as to make it
easier to diagnose build problems.  Default: enabled.

=item S<B<--autopurge> | B<--noautopurge>>

When B<autopurge> is enabled, an implicit B<toast purge> will be performed
on a package as soon as it is successfully built.  Default: disabled.

=item S<B<--autoarm> | B<--noautoarm>>

When B<autoarm> is enabled, B<toast upgrade> and B<toast rebuild> perform
an implicit B<toast arm> on every newly created non-broken build whose
package already contains another armed build.  Default: enabled.

=item S<B<--autodisarm> | B<--noautodisarm>>

When B<autodisarm> is enabled, B<toast arm>, B<toast demolish> and
B<toast remove> each perform an implicit B<toast disarm> on their armed
arguments or, in the case of B<toast arm>, on all builds belonging to
the same package as its arguments, or to any package with the same name
as its arguments if B<crossversion> is enabled.  Default: enabled.

=item S<B<--autodemolish> | B<--noautodemolish>>

When B<autodemolish> is enabled, B<toast rebuild> performs an implicit
B<toast demolish> on every other build belonging to the same package as
a newly-created, non-broken build.  If B<crossversion> is also enabled,
other packages with the same name will also be demolished.  Default:
enabled.

=item S<B<--autoremove> | B<--noautoremove>>

When both B<autoremove> and B<crossversion> are enabled, every time a
command creates a new non-broken build, it will also perform an implicit
B<toast remove> on every other package with the same name as the package
containing a newly-created, non-broken build.  If B<crossversion> is
disabled, this option has no effect.  Default: disabled.

=item S<B<--crossversion> | B<--nocrossversion>>

When B<crossversion> is enabled, the B<autodisarm>, B<autodemolish>,
B<autoremove> and B<stickyopts> options will extend their effects to other
packages with the same name when appropriate.  See the descriptions of
those options for details.  Default: disabled.

=item S<B<--skipmismatched> | B<--noskipmismatched>>

When B<skipmismatched> is enabled, some operations will ignore any
pre-existing build that was built with a value of B<armdir> different
than the current one and is therefore reported as C<mismatched> by
B<toast status>.  Specifically, B<toast build> will ignore mismatched
builds when deciding whether or not to create a new build; B<toast
upgrade> will ignore mismatched builds when deciding whether to build or
arm the new version; and the B<autodemolish> option will not demolish
mismatched builds.  All other checks are unaffected by this option.
For example, B<toast remove> will never remove an armed build without
completely disarming it first, even if thie build is mismatched and this
option is enabled.  When B<skipmismatched> is disabled, mismatched builds
are never treated specially.  Default: enabled.

=item S<B<--ccache> | B<--noccache>>

When B<ccache> is enabled and a program called C<ccache> is present,
B<toast build> and B<toast rebuild> will try to use it to speed up
compilation of C/C++ programs.  Read about ccache at ccache.samba.org;
install it with C<toast arm ccache>.  If invoked as root, the cache
directory defaults to the C<ccache> subdirectory of B<storedir>; for
non-root users, the default is C<I<$HOME>/ccache>.  The location can
always be overridden by setting the C<CCACHE_DIR> environment variable.
If ccache is not installed, this option has no effect.  Disabling this
option prevents toast from taking any special steps to take advantage of
ccache, but it does not guarantee that ccache will not be used, though
it may prevent it from finding a user's home directory.  Default: enabled.

=item S<B<--preload> | B<--nopreload>>

When B<preload> is enabled, B<toast build> will attempt to compile a
shared library for use with C<LD_PRELOAD> during the C<make install>
phase.  This library may help some packages install themselves into the
correct location.  If B<preload> is disabled, B<toast build> will skip
this step.  Note that this may cause some packages to build incorrectly
in some situations.  To build the shared library only if a suitable
C compiler is present, leave this option enabled, but disable the
B<strictpreload> option.  Default: enabled.

=item S<B<--strictpreload> | B<--nostrictpreload>>

When B<strictpreload> is enabled, failure to build the shared library
described under the B<preload> option is treated as a fatal error.
When B<strictpreload> is disabled, a compile error while attempting
to build the shared library causes B<toast build> to behave as if the
B<preload> option were disabled.  This may allow B<toast build> to succeed
in the absence of a suitable C compiler, but it may allow some packages
to build incorrectly in some situations.  Default: enabled under Linux,
disabled elsewhere.

=item S<B<--useflock> | B<--nouseflock>>

When B<useflock> is enabled, some commands (such as B<toast arm>)
may try to use Perl's built-in flock() to prevent multiple concurrent
invocations of B<toast> from modifying the repository in ways that might
corrupt it.  Disabling this option is probably not a good idea, but may
be necessary in some environments.  Note that Perl's flock() will not
necessarily use C's flock() routine; see the Perl manual for details.
Note also that B<toast>'s locking strategy probably isn't foolproof,
especially under NFS.  Default: disabled under Cygwin, enabled elsewhere.

=item S<B<--reconfigure> | B<--noreconfigure>>

When B<reconfigure> is enabled, B<toast build> may attempt to pass extra
arguments to a package's C<configure> script (such as B<--enable-shared>)
and/or C<Makefile> (such as B<install.man>) in order to build or install
extra files that the package itself might not build or install by default.
This produces improved results for many specific packages (such as QT
and XFree86), and may make subsequent packages more likely to build, but
it can sometimes break things (usually in a straightforward way), or it
may be undesirable for other reasons.  If B<reconfigure> is disabled,
B<toast build> does not try to do anything beyond the minimum steps
required to correctly build and install whatever files the package builds
and installs by default.  Note that by default, this option's value may
be saved with the package and reused by future invocations of B<toast>;
see the B<stickyopts> option for details.  Default: enabled.

=item S<B<--fixliblinks> | B<--nofixliblinks>>

When B<fixliblinks> is enabled, B<toast build> may create symbolic links
to shared libraries whose names contain version numbers and follow a
certain naming convention.  For example, when built under Linux with
the B<reconfigure> option enabled, zlib version 1.2.1 creates a shared
library called C<libz.so.1.2.1> along with two symbolic links that
point back to that file: C<libz.so> (required to link new packages with
the shared library) and C<libz.so.1> (required to run programs linked
with the shared library).  When this option is enabled, B<toast build>
will create a third link called C<libz.so.1.2>, which happens to be
completely useless, but if the other two links had been missing for
whatever reason, it would have created them as well.  Binary packages
that contain shared libraries are especially likely to benefit from
this behavior.  Default: enabled.

=item S<B<--interactive> | B<--nointeractive>>

When B<interactive> is enabled, B<toast upgrade> will display a list of
candidates (the same information as B<toast find>, but presented in a
different form) and prompt the user to choose one of them.  If B<autofind>
is enabled, B<toast add> and other commands do the same thing.  Note that
if only one candidate is found, that candidate will be used automatically,
without prompting.  Default: disabled.

=item S<B<--stoponerror> | B<--nostoponerror>>

When B<stoponerror> is enabled, B<toast> aborts and returns failure as
soon as any error occurs.  If B<stoponerror> is disabled, only the
processing of the current command argument is aborted; any subsequent
arguments will still be processed, but B<toast> still issues an error
message and returns failure after processing the last argument, even if
the last argument was processed successfully.  Note that certain types
of errors, such as errors parsing the command line, will always cause
B<toast> to abort completely, before processing the first argument,
regardless of this setting.  Default: enabled.

=item S<B<--ignorecase> | B<--noignorecase>>

If B<ignorecase> is enabled, package names and version numbers given on
the command line are always case-sensitive.  If B<ignorecase> is disabled,
package names and version numbers that refer to existing packages are
treated as if they were case-insensitive only when failing to do so would
cause an error.  Note that case is always preserved in URLs and when
explicitly naming new packages.  Note also that it is always legal for
two distinct packages to have names and/or version numbers that differ
only in case, and that such packages are never treated as if they were
related, even if B<crossversion> is enabled.  Default: enabled.

=item S<B<--showurls> | B<--noshowurls>>

When B<showurls> is enabled, B<toast status> always displays the stored
URLs associated with each displayed package.  If B<showurls> is disabled,
B<toast status> only displays a package's URLs if a different list of URLs
for that package was given explicitly on the command line.  Default:
enabled.

=item S<B<--showopts> | B<--noshowopts>>

When B<showopts> is enabled, B<toast status> always displays any stored
options associated with each displayed package.  If B<showopts> is
disabled, B<toast status> never displays this information.  Default:
enabled.

=item B<--libvar=>I<VAR>

Optionally tells B<toast env> to set an additional variable I<VAR>
that points into the C<lib> subdirectory of each I<ALTARMDIR>.
You would typically set this to the empty string, C<LD_RUN_PATH>,
or C<LD_LIBRARY_PATH>.  C<LD_RUN_PATH> typically instructs ld to
compile the current I<ALTARMDIR>s into any newly-built programs, such
that those programs will search those directories for shared libraries.
C<LD_LIBRARY_PATH> has a more radical effect: in addition to influencing
ld, it essentially instructs all dynamically linked programs to search
the I<ALTARMDIR>s for shared libraries.  (This often works, but can
cause terrible problems if you use toast to build a library that is
sufficiently similar to a pre-existing library installed in one of the
default locations.)  If I<VAR> is the empty string, B<toast env> sets
neither variable.  Note that B<toast env> always sets the relatively
uncontroversial C<LIBRARY_PATH> environment variable, which will at least
allow ld to find both shared and static libraries in I<ALTARMDIR>s at
compile time.  Default: C<LD_LIBRARY_PATH>.

=item S<B<--infodir> | B<--noinfodir>>

When B<infodir> is enabled, B<toast arm> and B<toast disarm> will create a
file in B<armdir> called C<info/dir>; if the file already exists, it will
be replaced with an updated version.  When this option is set, B<toast
env> sets C<INFODIR> to point to this file, so that the "info" command can
display a list of installed info pages.  If B<infodir> is disabled or the
C<install-info> program is missing or broken (e.g. the fake install-info
command bundled with dpkg), B<toast arm> and B<toast disarm> will delete
the C<info/dir> file, if present, instead of rebuilding it, which will
likely prevent the C<info> command from giving you a correctly-populated
menu when invoked without arguments, though it should still work fine
when invoked with a program name as an argument.  Default: enabled.

=item S<B<--xmlcatalog> | B<--noxmlcatalog>>

When B<xmlcatalog> is enabled, B<toast arm> and B<toast disarm> will
maintain a catalog file in B<armdir> called C<etc/xml/toast-xml-catalog>,
whose presence and contents depend on the contents of B<armdir>'s
C<share/xml> and C<etc/xml> subdirectories.  If the catalog already
exists, it may be overwritten or deleted.  The B<toast env> command will
set C<XML_CATALOG_FILES> to point to this file when this option is set,
which helps things like DocBook operate correctly.  If B<xmlcatalog>
is disabled, B<toast arm> and B<toast disarm> will delete the
C<toast-xml-catalog> file, if present, instead of rebuilding it.
Default: enabled.

=item S<B<--hspkg> | B<--nohspkg>>

When B<hspkg> is enabled, B<toast build> will attempt to intercept
information about Haskell packages registered with C<ghc-pkg> and store
it in strangely-named files in a special C<hspkg> subdirectory; B<toast
arm> and B<toast disarm> will rebuild a Haskell package database in
B<armdir> called C<etc/xml/toast-hs-package.conf>, whose presence and
contents depend on the contents of B<armdir>'s C<hspkg> subdirectory;
and B<toast env> will add this package database to the C<GHC_PACKAGE_PATH>
environment variable used by GHC 6.6 and later.  If B<hspkg> is disabled,
B<toast build> will not attempt to intercept calls to C<ghc-pkg>, which
may prevent Haskell libraries from building at all, at least with GHC
6.6 and earlier; and B<toast arm> and B<toast disarm> will delete the
C<toast-hs-package.conf> file, if present, instead of rebuilding it.
Essentially untested.  Default: disabled.

=item S<B<--protect> | B<--noprotect>>

If B<protect> is enabled, B<toast build> will make some of the directories
it creates in B<storedir> read-only, and B<toast arm> will attempt
to ensure that B<armdir> and all of its subdirectories are read-only,
changing existing modes if necessary.  If B<protect> is disabled, B<toast
build> will create read-write directories in storedir (though existing
subdirectories will be unaffected), and B<toast arm> will make B<armdir>
and its subdirectories read-write, assuming the current umask allows it.
This option never affects the permissions of files or symbolic links.
Default: disabled.

=item S<B<--relative>> | B<--norelative>>

If B<relative> is enabled, symbolic links created by B<toast arm>
will use canonical relative paths computed from the actual layout of
the filesystem when the command runs.  If B<relative> is disabled,
the target of each symbolic link will start with the absolute path to
B<storedir>, exactly as given on the command line (or configuration file
or whatnot), even if the resulting path is not canonical.  A "canonical
path" means a path that follows the "real" filesystem layout without going
through any links.  Both methods should work just fine except in unusual
situations, so feel free to use whichever setting you think looks nicer.
This option only affects newly-created links, never existing links, even
when an existing link is moved to change the stacking order of a package.
Default: disabled.

=item S<B<--debugrewrite> | B<--nodebugrewrite>>

If B<debugrewrite> is enabled, B<toast build> will always generate broken
builds.  The builds will contain extra debugging information that can be
used to help diagnose problems involving packages that build correctly
outside of B<toast>, but refuse to build or build incorrect files due
to bugs in B<toast>'s path-rewriting mechanism.  This option currently
requires that the C<strace> program be available (or C<ktrace> for *BSD).
Default: disabled.

=back

Each option's value is taken from the first of the following sources
that assigns it a value:

=over 4

=item 1.

The command line.  All options support standard B<-->I<NAME>B<=>I<VALUE>
and S<B<-->I<NAME> I<VALUE>> syntax.  For boolean options, I<VALUE> can
be B<true>, B<yes>, B<on>, B<enabled>, or B<1> to enable the option or
B<false>, B<no>, B<off>, B<disabled>, or B<0> to disable it.  Alternately,
B<-->I<NAME> can be used to enable a boolean option or B<--no>I<NAME>
to disable it.  In all cases, the leading double dash (B<-->) may
be replaced by a single dash (B<->), and I<NAME> is case-insensitive
(as is the B<no> prefix used to disable boolean options).  I<VALUE>
is case-sensitive, except for boolean options.

=item 2.

Package-specific configuration files.  If they exist at all, these
files are normally created and updated by B<toast>.  Package-specific
configuration files can live in two different places: the first applies
to a specific package with a given name and version number, the second
applies to all packages with the given name.  If both files exist, both
are checked in that order, and the first one to supply a value for the
option in question wins.  See the B<stickyopts> option for details.

=item 3.

The environment.  If option I<NAME> is not given a value on the command
line, will be read from the environment variable B<TOAST_>I<NAME> (all
uppercase) if it exists.  Note that environment variables whose names
contain lowercase letters will be silently ignored!  In the case of a
boolean option, one of the explicit values listed in item 1 must be given.

=item 4.

The main configuration file.  If option I<NAME> has not been assigned a value
through any of the above methods, its value will be taken from a line of
the form I<NAME>B<=>I<VALUE> in the configuration file, if such a line
exists.  I<NAME> is case-insensitive in this context.  Any whitespace
before or after I<NAME> or I<VALUE> will be ignored, as will any blank
line, any line containing only whitespace, and any line with B<#> as its
first non-whitespace character.  B<toast> looks for its configuration
file in C<I<$HOME>/.toast/conf>, C</toast/conf>, C</etc/toast.conf>,
and C</usr/local/etc/toast.conf>; if any of those files exist, only the
first is used.  (Here, C<I<$HOME>> specifically represents the value of
the C<HOME> environment variable.)  If a configuration file exists but
cannot be read or has invalid syntax, an invalid I<NAME>, or an illegal
I<VALUE> for a boolean option (an explicit value must be given; see item
1 for allowed forms), B<toast> will normally give an error message at
startup and refuse to execute any commands.

=item 5.

The built-in default value.  See the full list of options elsewhere in
this document for the specific default value used for each option.

=back

Any I<COMMAND> can also be written as if it were a command-line option by
preceding it with one or two dashes.  For example, S<B<toast --help>> and
S<B<toast help>> mean the same thing.  Commands do not behave like options
in the environment or the configuration file, but see the B<defaultcmd>
option above for an alternative.

=head1 ENVIRONMENT

Environment variables whose names start with C<TOAST_> may be interpreted
as option settings as described above.  In addition, various standard
environment variables such as C<PATH>, C<LD_LIBRARY_PATH>, C<CFLAGS>
and others may directly or indirectly influence B<toast>'s behavior,
especially when building new packages.

=head1 FILES

By default, when invoked by a non-root user, B<toast> writes only to
the C<I<$HOME>/.toast> directory, which will be created automatically
if needed.

=head1 AVAILABILITY

B<toast> may be downloaded from C<http://toastball.net/toast/> under
the terms of the GNU GPL.

=head1 BUGS

Please report any bugs, unexpected behavior, unsurprising but
inconvenient failures, feature requests, comments, and so on to
C<toast-bugs@@toastball.net>.  You can also use B<toast bug> to report
problems with specific packages that refuse to build.

Known bugs:

  - autofind hangs in httphead() when going through tinyproxy?
  - gtk+ doesn't seem to build properly when it is already armed
  - opera and sleepycat db refuse to build when already armed
  - gimp will load plugins from other armed versions despite .off suffix
  - antiword 0.35 and unison 0.9.20 end up in armdir/helpers/home/bin/
  - "toast upgrade gcc" doesn't work (ftp site has a subdir per version)
  - find fails for: sleepycat db, gcc, latex, GNU arch (?), ogle
  - autofind chooses "libraries only" version of xfig
  - build fails for: jikes, sirc, netcat, lcab, gv, bittorrent, xmlcatmgr
  - build (w/ --preload) fails for python 2.5.2 if ~/.toast is a symlink
  - "toast edit" leaves things in an odd state if you hang up on it
  - "toast rename" is more case-sensitive than it ought to be
  - "toast get" prevents wget from truncating output if transfer restarts
  - "toast get" should support resuming, but doesn't
  - "toast get" no longer displays progress under many circumstances
  - "toast env" doesn't set PYTHONPATH
  - "toast build linux" may fail during install phase w/o --nopreload
  - "toast remove" leaves cruft behind after removing last package
  - "toast status mail::spamassassin" is too case-sensitive
  - "--stickyopts=crossversion" suffers from chicken-and-egg problem

Wish list:

  - purge inaccessible dirs from env upon setting toast UID? (6/3/07)
  - deal better with missing gcc: clearer error msg? (email 7/21/04)
  - error messages that explain command usage (gale 2004-05-06 17:08:20)
  - convenient way to specify storedir, etc. during first time setup
  - work around lack of getenv(), mkdir(), etc. in microperl...?
  - "toast upgrade" w/o args should imply --nostoponerror or something
  - "toast arm" should move armed packages to top of stacking order
  - "toast status" should give information about stacking order
  - "toast rename" should rename armed packages by rewriting symlinks
  - "toast clean" should optionally remove old versions/builds
  - add "toast check": verify storedir and armdir integrity (and fix?)
  - toast get could be more robust w/r/t failures and concurrency
  - configure packages to use alternate /etc, /var, etc. when possible
  - share rewriting code between command wrappers and shared library
  - come up with a better way to deal with gnome (guess dependencies?)
  - track runtime dependencies (e.g. ldd output); trigger auto rebuild
  - figure out where to go with "toast edit" (or document it as-is)
  - let the user give a hash for each explicit URL; verify hashes
  - find, download, and verify hashes, PGP signatures, etc.
  - store checksums after build for later tripwire-like verification
  - find a way to rebuild indices for apropos by default
  - allow package name/version as URL; expand w/ autofind iff missing
  - optionally have toast add imply change, then make get+build smarter
  - toast status should allow multiple storedirs
  - toast get should support cvs, svn (e.g. GNU Emacs, Xapian, Ruby)
  - add "toast confhelp" or something to run ./configure --help?
  - make lemonade somehow when given dpkg's install-info
  - have toast status show/sort by size/timestamp
  - add support for Ruby's install.rb
  - fold archives by URL and/or hash?
  - zsh completions!

Questions left unanswered by this documentation:

  - What are some realistic examples of toast commands?
  - How are storedir and armdir structured?
  - How does this tool differ from similar tools?
  - How can I address common problems not directly caused by toast?
  - How might I set up toast in a multi-architecture environment?

=head1 SEE ALSO

  /package       http://cr.yp.to/slashpackage/management.html
  Alien          http://kitenet.net/programs/alien/
  autopackage    http://autopackage.org/
  CheckInstall   http://asic-linux.com.mx/~izto/checkinstall
  Debian         http://www.debian.org/
  Encap          http://www.encap.org/
  fakeroot       http://packages.debian.org/stable/utils/fakeroot.html
  FreeBSD Ports  http://www.freebsd.org/ports/
  GAR            http://www.lnx-bbc.org/garchitecture.html
  GARStow        http://offog.org/code/garstow.html
  Gentoo         http://www.gentoo.org/
  GNU stow       http://www.gnu.org/software/stow/
  Graft          http://www.gormand.com.au/peters/tools/graft/graft.html
  LFS            http://www.linuxfromscratch.org/
  Linuxports     http://linuxports.sourceforge.net/
  RPM            http://www.rpm.org/
  Source Mage    http://www.sourcemage.org/
  spasm          http://www.linux.org/apps/AppId_6909.html

=head1 AUTHOR

Jacques Frechet

=head1 COPYRIGHT

This manual is part of B<toast>.  Copyright (C) 2003-2016 Jacques Frechet.

B<toast> is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

B<toast> is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with B<toast>.  If not, see C<http://www.gnu.org/licenses/>.

=cut

__END__
@


1.487
log
@support upgrading via HTTP/S [thanks to Lukas Bestle]
@
text
@d6 1
a6 1
# Copyright (C) 2003-2010 Jacques Frechet.                                   #
d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.486 2012/07/15 18:40:38 zaphod Exp zaphod $;
d48 1
a48 1
my($mycopyright) = "Copyright (C) 2003-2010 Jacques Frechet";
d4864 10
d8136 1
a8136 1
This manual is part of B<toast>.  Copyright (C) 2003-2010 Jacques Frechet.
@


1.486
log
@toast env now sets PKG_CONFIG_PATH
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.485 2012/07/13 06:19:37 zaphod Exp zaphod $;
d4793 1
a4793 1
    m!^((http|ftp|file)://[^\?]+/)([^\?/]*)(\?.*)?$!i ||
@


1.485
log
@add --libvar, which now defaults to LD_LIBRARY_PATH
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.484 2011/09/21 03:09:40 zaphod Exp zaphod $;
d1598 1
d1602 6
a1607 2
  my(@@dirs) = map(path($_, $subdir),
      uniq(map(m!^/! ? $_ : path(storedir, $_), @@adirs)));
d1640 2
d7243 3
a7245 2
files), C<XML_CATALOG_FILES> (used by DocBook and other tools to locate
XML catalogs), C<LIBRARY_PATH> (used by GNU ld to find libraries), and
@


1.484
log
@backticks are *so* 2004
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.483 2011/09/21 02:58:56 zaphod Exp zaphod $;
d295 1
d1634 1
a1636 1
  # there's also a LIBRARY_RUN_PATH or something that affects ld somehow...
d7237 10
a7246 8
XML catalogs), and C<LIBRARY_PATH> (used by GNU ld to find libraries;
not to be confused with C<LD_LIBRARY_PATH>, which also affects shared
library loading at run time).  Note that if C<MANPATH> in particular is
unset, B<toast env> will run C<man -w> to try to get the default value; if
this causes problems, it may help to ensure that C<MANPATH> is set before
invoking B<toast env>.  This command assumes a Bourne-like shell -- zsh
and bash will work, tcsh won't.  None of this is likely to be necessary if
I<ARMDIR> is C</usr> or C</usr/local> (the default when running as root).
d7832 19
@


1.483
log
@lie to make install about UID (e.g. goldenpod)
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.482 2011/09/14 00:31:57 zaphod Exp zaphod $;
d6946 1
a6946 1
  eval `$HOME/.toast/armed/bin/toast env`
d6948 4
a6951 5
(Note that those are backticks, not single quotes.)  It probably makes
sense to add the above command to your C<.zshenv> or C<.profile> or
whatnot, so that your environment variables will be set up automatically
whenever you log in.  For more information, run C<toast help env>,
or just C<toast env> to see what variables would be set.
d7225 19
a7243 20
normally invoked with C<eval `toast env`> (note the backticks) from a
shell initialization file such as C<.zshenv> or C<.profile>.  This will
add I<ALTARMDIR>C</bin> to the front of C<PATH> for each I<ALTARMDIR>, in
order.  (By default, I<ALTARMDIR> is the same as I<ARMDIR>, which usually
defaults to C<~/.toast/armed>; this is the directory that contains a
merged view of all armed packages.)  If a particular I<ALTARMDIR>C</bin>
already appears anywhere in C<PATH>, it will remain in its current
position instead of being added or moved to the front of B<PATH>.
Other environment variables are similarly affected: C<MANPATH> (used to
find man pages), C<INFOPATH> (used by GNU info), C<CPATH> (used by gcc
to find include files), C<XML_CATALOG_FILES> (used by DocBook and other
tools to locate XML catalogs), and C<LIBRARY_PATH> (used by GNU ld to
find libraries; not to be confused with C<LD_LIBRARY_PATH>, which also
affects shared library loading at run time).  Note that if C<MANPATH>
in particular is unset, B<toast env> will run C<man -w> to try to get
the default value; if this causes problems, it may help to ensure that
C<MANPATH> is set before invoking B<toast env>.  This command assumes
a Bourne-like shell -- zsh and bash will work, tcsh won't.  None of
this is likely to be necessary if I<ARMDIR> is C</usr> or C</usr/local>
(the default when running as root).
@


1.482
log
@fix "empty path component in  ccache"?
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.481 2011/09/02 00:55:44 zaphod Exp zaphod $;
d3217 2
@


1.481
log
@fix ccache wrapper path quoting issue?
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.480 2010/04/04 18:22:09 zaphod Exp zaphod $;
d1575 1
d1578 2
a1579 1
    my($path) = path($_, $prog);
d2997 1
a2997 6
  return true unless ccache;

  my($path) = $ENV{"PATH"};
  my($found);
  $found ||= -x(laxpath($_, "ccache")) for split(/:/, $path);
  return true unless $found;
d2999 1
a2999 1
  my $qpath = quote($path);
@


1.480
log
@fix OpenSolaris "Connection refused"?
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.479 2010/03/02 05:27:56 zaphod Exp zaphod $;
d3002 1
d3007 1
a3007 1
PATH=$path
@


1.479
log
@workaround for autotools bug (?)
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.478 2010/01/14 04:31:03 zaphod Exp zaphod $;
d944 11
a954 4
  my($host, $port, $ip) = @@_;
  $ip = gethostbyname($host) || error("gethostbyname $host: $!")
      unless defined($ip);
  socket(HANDLE, 2, 1, 0) || error("$!");
d956 1
a956 2
  connect(HANDLE, pack("Sna4x8", 2, $port, $ip)) ||
      error("connect $host:$port: $!");
d958 1
a958 1
  return $ip;
d985 1
a985 1
  print HANDLE $request || error("write to $host:$port: $!");
@


1.478
log
@fix "bad file descriptor" in GET
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.477 2010/01/13 04:24:48 zaphod Exp zaphod $;
d3948 2
@


1.477
log
@shutdown causing EBADF?
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.476 2010/01/11 03:41:49 zaphod Exp zaphod $;
d1009 1
d1016 1
a1016 2
    error("$url: $!") if $!;
    error("$url: unexpected EOF") unless defined($_);
a1024 1
    error("$url: $!") if $!;
@


1.476
log
@even more diagnostics
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.475 2010/01/11 03:29:06 zaphod Exp zaphod $;
a979 1
  shutdown(HANDLE, 1) || error("shutdown write $host:$port: $!");
@


1.475
log
@better diagnostic for empty HTTP response
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.474 2010/01/10 22:05:51 zaphod Exp zaphod $;
d1014 1
d1016 1
d1026 1
@


1.474
log
@add toast bug command
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.473 2010/01/10 02:43:08 zaphod Exp zaphod $;
d1015 1
@


1.473
log
@increment copyright year
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.472 2010/01/10 02:14:39 zaphod Exp zaphod $;
d47 1
d681 1
d955 1
a955 1
sub openhttp(*$;$;$)
d958 1
a958 1
  my($url, $method, $proxy) = @@_;
d961 1
a961 1
  explain("fetching $url");
d974 2
d977 1
a977 1
      "User-Agent: $uagent\r\nAccept: */*\r\n\r\n";
d980 1
d993 13
d2228 2
a2229 1
  return -f(path(pkgpath($name, $version, $build), brokenlog));
d4344 1
d5177 30
d5819 1
d7199 14
d7500 8
a7507 8
in order to build a package correctly (if it is, send me a bug report!),
but it can be awfully handy at times.  The I<ARGS> string is treated
as a list of space-separated words, each of which may be optionally
quoted with single or double quotes with backslash acting as an escape
character; the resulting words are added to the end of the command line.
Note that by default, this option's value may be saved with the package
and reused by future invocations of B<toast>; see the B<stickyopts>
option for details.  Default: empty string.
d7991 4
a7994 3
Please report any bugs, unexpected behavior, unsurprising but inconvenient
failures, feature requests, comments, and so on to C<toast-bugs> at the
hostname of the B<toast> distribution site, C<toastball.net>.
@


1.472
log
@correct line nos for perl built-in warnings
@
text
@d6 1
a6 1
# Copyright (C) 2003-2009 Jacques Frechet.                                   #
d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.471 2010/01/08 04:37:48 zaphod Exp zaphod $;
d47 1
a47 1
my($mycopyright) = "Copyright (C) 2003-2009 Jacques Frechet";
d8022 1
a8022 1
This manual is part of B<toast>.  Copyright (C) 2003-2009 Jacques Frechet.
@


1.471
log
@remove debug warnings added in 1.470
@
text
@d23 2
a24 1
&the_correct_line_number_for_this_line_is(23); # perl thinks this is line 2...
d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.470 2010/01/08 04:34:47 zaphod Exp zaphod $;
d53 1
a53 1
BEGIN
d55 2
a56 3
  my($linedelta, $filedelta);

  sub the_correct_line_number_for_this_line_is($)
d58 2
a59 18
    my($realline) = @@_;
    my($package, $file, $line) = caller(0);
    $linedelta = $realline - $line;
    $filedelta = $file;
  }

  sub trace(;$)
  {
    my($i, $out, $prev) = (shift || 1, "", "");
    while(my($package, $file, $line) = caller($i++))
    {
      $line += $linedelta if defined($linedelta) && $file eq $filedelta;
      $out .= ($prev eq $file ? "/" : $out ? "; $file: " : "$file: ") . $line;
      $prev = $file;
    }
    $out .= " (from #!perl line)" unless defined($linedelta);
    $out .= " v$myversion";
    return $out;
d61 2
@


1.470
log
@fix cygwin "too many levels of symbolic links" issue
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.469 2009/11/21 22:19:58 zaphod Exp zaphod $;
a3983 1
warning("XXX");
a3985 1
warning("YYY");
@


1.469
log
@update copyright year
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.468 2009/11/21 22:18:42 zaphod Exp zaphod $;
d3981 10
a3990 3
  my($p) = $rootdir;
  optrelln($rootdir, $p = path($p, $_)) for unpath($armdir), unpath($rootdir);
  s!^/!! and mdp(path($rootdir, $_)) for @@INC; # PDFlib-Lite/7.0.3
d4125 1
a4125 1
      (keys(%link), unpath($rootdir), unpath($armdir));
d6893 1
a6893 1
directory, try B<toast arm toast>.
@


1.468
log
@fix "insecure dependency" as root in karmic (perl 5.10.0?)
@
text
@d6 1
a6 1
# Copyright (C) 2003-2007 Jacques Frechet.                                   #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.467 2009/10/07 00:15:32 zaphod Exp zaphod $;
d46 1
a46 1
my($mycopyright) = "Copyright (C) 2003-2007 Jacques Frechet";
d8031 1
a8031 1
This manual is part of B<toast>.  Copyright (C) 2003-2007 Jacques Frechet.
@


1.467
log
@update description and fix whitespace (code is unchanged)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.466 2009/05/08 22:29:30 zaphod Exp zaphod $;
d1541 1
d1545 1
d1547 1
d1549 3
a1551 1
    ($<, $>) = ($uid, $uid);
d1554 1
@


1.466
log
@fix freshmeat.net lookup
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.465 2009/03/29 22:48:35 zaphod Exp zaphod $;
d1159 1
a1159 1
  
d1274 1
a1274 1
  
d1277 1
a1277 1
  if(!-d($to)) 
d2512 1
a2512 1
    ($cvi, $margin) = ($i, "0) ") 
d2961 1
a2961 1
 
d6186 1
a6186 1
 
d6619 1
a6619 1
  
d6794 1
a6794 1
toast - simple source-and-symlinks package manager for root and non-root users
d6803 7
a6809 5
installing, uninstalling and managing software packages.  Unlike
traditional package-management systems, B<toast> is primarily intended
to work directly with software distributed as source code, rather than
in some precompiled or specialized binary format, such as RPM.  Binary
packages are also supported.
d6824 5
a6828 5
Installing and managing software in the home directory of a non-root user
on a multi-user system.  For example, I like to be able to run valgrind,
xdaliclock, Opera, and a few other programs on the Linux cluster at work
without having to bother the IT department about installing or supporting
those packages.
d6832 5
a6836 7
Installing and managing software packages in parallel to those installed
by a conventional package manager.  For example, if I were maintaining a
computer system running some kind of mainstream Unix-like OS, it might be
convenient to be able to quickly install the latest OpenSSH from source
into C</usr/local> in order to work around a security vulnerability,
and then conveniently remove it once my vendor or distribution releases
an official package for that version.
d6841 3
a6843 2
using B<toast> as the one true package manager for the system.  This is
what I do on my (single-user) Linux box at home.
a6846 6
Use #1 seems to be by far the most common in practice.  As far as I know,
I'm the only one crazy enough to attempt #3, and no one bothers with #2.
In general, it's probably a good idea to use a real distribution (such
as Debian), and to use its native package management system whenever
possible, rather than using B<toast> to replace it or go behind its back.

d6896 4
a6899 4
To have B<toast> install itself as root under C</toast> with symlinks in
C</usr/local>, you should first either create a user called C<toast> whose
UID and GID will be used when building packages, or create a configuration
file specifying an alternate username (C<fred> in this example):
d6903 7
a6909 3
If you want to use directories other than C</toast> and C</usr/local>,
now would be a good time to specify those as well, since relocating
armed packages can be tricky and time-consuming:
d6929 1
a6929 1
directories will be created on demand.
d6937 4
a6940 3
program and a man page.  Sadly, B<toast>'s C<configure> script does
not support most of the other command-line options and features of
B<configure> scripts produced by the real GNU autoconf.
@


1.465
log
@install bare uncompressed scripts
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.464 2009/03/20 06:05:00 zaphod Exp zaphod $;
d2353 1
a2353 1
    "freshmeat" => "http://freshmeat.net/projects-xml/$lcname/$lcname.xml",
d2376 1
a2376 1
      if($url =~ m!^http://(freshmeat.net)/.*\.xml$!)
d2378 1
a2378 1
        local(*XML, $_);
d2380 3
a2382 3
        openurl(*XML, $url);
        my($notfound, %fmurl);
        while(<XML>)
d2384 6
a2389 3
          $notfound = /^Error: project not found/i ? 1 : 0
              if !defined($notfound);
          $fmurl{$1} = $2 while m!<url_(\w+)>([^<]+)</!g;
d2391 1
a2391 3
        close(XML) || error("unable to contact $sitename");

        error("no listing for package $name on $sitename") if $notfound;
d2393 3
a2395 3
        my($redirurl);
        $redirurl ||= $fmurl{$_} for qw(bz2 tgz zip deb rpm homepage);
        $redirurl || error("no suitable URL for package $name on $sitename");
d2397 1
a2397 1
        my($redirhead) = httphead($redirurl);
d2399 1
a2399 1
            error("unexpected response from $redirurl");
@


1.464
log
@use a well-behaved sourceforge mirror
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.463 2009/03/20 04:54:13 zaphod Exp zaphod $;
d1712 1
d2068 6
@


1.463
log
@search projects hosted by Google Code
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.462 2009/03/20 01:21:35 zaphod Exp zaphod $;
d2340 3
d2348 2
a2349 1
    "sourceforge" => "http://prdownloads.sourceforge.net/$lcname/",
@


1.462
log
@fix bug with --findsites and non-alphanumeric package names
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.461 2009/03/20 01:18:10 zaphod Exp zaphod $;
d2344 1
d7393 4
a7396 4
find> for packages that have not already been added.  I<SITELIST>
is a space-separated list of URLs and/or special words taken from the
following list: C<freshmeat>, C<sourceforge>, C<gnu>, C<cpan>, or C<all>
(which stands for all of the preceding words in the order given).
@


1.461
log
@fix first-time setup instructions
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.460 2008/08/22 18:38:56 zaphod Exp zaphod $;
d2354 1
a2354 1
  s/\*/\Q$name\E/g for @@findsites;
@


1.460
log
@try to help gcc work correctly when invoked during "make install"
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.459 2008/05/28 22:31:51 zaphod Exp zaphod $;
d6865 3
a6867 2
      "toastball.net")||die("dns")))&&syswrite(S,"GET /toast/toast\n")&&
      open(STDIN,"<&S")&&exec($^X,qw(-x - arm toast))||die($!)'
@


1.459
log
@experimental git support
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.458 2008/05/08 23:20:31 zaphod Exp zaphod $;
d3331 1
a3331 1
      xmlcatalog pkg-config], "[");
@


1.458
log
@prefer setup.py to a bare Makefile (e.g. Cython)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.457 2008/05/07 05:21:00 zaphod Exp zaphod $;
d1431 1
d2616 34
d2768 1
a2768 1
    if($newurl ne $_ && autochange)
d6975 3
@


1.457
log
@fix mkdir bug introduced in 1.456
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.456 2008/05/02 02:24:10 zaphod Exp zaphod $;
d3484 17
a3656 15
  # Construct a Makefile to invoke setup.py on behalf of certain Python source
  # packages (notably BitTorrent):
  if(-r(path($dir, "setup.py")))
  {
    writefile
    (
      path($dir, "Makefile"),
      "# $genby\n\n",
      "all:\n\tpython setup.py build\n\n",
      "install:\n\tpython setup.py install " .
          "--prefix=\Q$prefix\E --root=\$(DESTDIR)\n",
    );
    return $dir;
  }

@


1.456
log
@add rudimentary SCons support; fix PDFlib-Lite; remove dead code
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.455 2008/04/09 21:14:06 zaphod Exp zaphod $;
a629 10
sub mdp(@@)
{
  foreach(@@_)
  {
    my($dirname) = dirname($_);
    $dirname eq "/" || $dirname eq "." || -d($dirname) || &mdp($dirname);
  }
  md(@@_);
}

d645 10
@


1.455
log
@install bitlbee headers
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.454 2008/04/07 00:24:26 zaphod Exp zaphod $;
d630 10
a1159 6
  if(defined($newurl))
  {
    error($@@) unless $newurl;
    return $newurl;
  }

d3296 1
a3296 1
      xmlcatalog], "[");
d3655 13
d3922 1
a3922 1
  md(path($rootdir, $_)) foreach stddirs;
d3927 1
@


1.454
log
@add --compilecmd and --installcmd options
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.453 2008/03/31 19:14:18 zaphod Exp zaphod $;
d3835 1
a3835 1
  my($man, $subdir, $netpbm, $usedestdir, $nodestdir, $useinstallprefix,
d3840 1
d3856 1
@


1.453
log
@allow toast to install itself even if /home is unreadable
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.452 2008/03/20 01:29:53 zaphod Exp zaphod $;
d275 1
a275 1
    "stickyopts" => "reconfigure confappend makeappend",
d281 2
d3809 12
d3824 6
a3829 4
  my($mf) = makefile($makedir) || error("no Makefile found");
  my(@@trace);
  @@trace = qw[strace -s 256 -f -F -o make.install.trace] if debugrewrite;
  @@trace = qw[ktrace -i -f make.install.trace] if @@trace && $^O =~ /bsd/i;
a3830 1
  local($ENV{DESTDIR}) = $rootdir; # not always on command line due to libtiff
d3833 1
a3833 1
  announce("export", "$_=$ENV{$_}") for (qw[ROOT DESTDIR install_root PREFIX]);
d3866 2
a3867 4
  cdrun($makedir, @@trace, "make", @@targets);
  run(@@trace, "sh", "-c", "cp -R '$netpbm'/*/ '$rootdir'") if $netpbm;
  optrun("cat", path($makedir, "make.install.trace")) if debugrewrite;
  error("trace complete; aborting") if debugrewrite;
d3923 1
d3965 1
d3993 9
a4001 2
  $makedir = configure($makedir, armdir);
  make($makedir);
d7326 1
a7326 1
Default: C<reconfigure confappend makeappend>.
d7381 45
d7539 4
a7542 4
When B<crossversion> is enabled, the B<autodisarm>, B<autodemolish> and
B<autoremove> options will extend their effects to other packages with
the same name when appropriate.  See the descriptions of those options
for details.  Default: disabled.
d7880 1
d7899 1
@


1.452
log
@fix --preload segfault with glibc 2.3.4 and/or gcc 3.4.6 on x86_64
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.451 2008/03/16 05:23:06 zaphod Exp zaphod $;
d1286 1
@


1.451
log
@remove sticky boolean options correctly
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.450 2008/03/14 00:18:26 zaphod Exp zaphod $;
d3126 1
a3126 1
    wrap int open(const char *pathname, int flags, int mode);
d3151 1
a3151 1
    /^(wrap0?|suppress) (int |\w+ \*)(\w+)\((.*)\)$/ || error;
d3156 3
d3179 1
a3179 1
  $rettype(*next_$name)($proto) = dlsym(RTLD_NEXT, "$name");
d7802 1
@


1.450
log
@include lsb_release -a output in broken.log
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.449 2008/03/13 23:58:52 zaphod Exp zaphod $;
d406 1
a406 1
        if($new eq getglobalopt($_))
@


1.449
log
@yet more --debugrewrite verbosity and purported --preload thread-safety
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.448 2008/03/13 22:20:25 zaphod Exp zaphod $;
d1654 1
@


1.448
log
@rename make.install.[sk]trace to make.install.trace; include in broken.log
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.447 2008/03/13 22:04:18 zaphod Exp zaphod $;
a3172 2
static $rettype(*next_$name)($proto) = 0;

d3175 2
a3176 5
  if(!next_$name)
  {
    next_$name = dlsym(RTLD_NEXT, "$name");
  }

@


1.447
log
@add pid to --debugrewrite output
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.446 2008/03/10 22:16:03 zaphod Exp zaphod $;
d3812 2
a3813 2
  @@trace = qw[strace -s 256 -f -F -o make.install.strace] if debugrewrite;
  @@trace = qw[ktrace -i -f make.install.ktrace] if @@trace && $^O =~ /bsd/i;
d3853 1
@


1.446
log
@make --preload more thread-safe
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.445 2007/09/11 23:06:00 zaphod Exp zaphod $;
d2954 1
d2969 2
a2970 1
#define debug(fmt, args...) do { fprintf(DEBUG, "$myname: " fmt "\\n", ## args); fflush(DEBUG); } while(0)
@


1.445
log
@fixed --fallbackuid search bug
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.444 2007/08/21 21:18:45 zaphod Exp zaphod $;
d3097 1
a3097 1
static const char *rewrite(const char *pathname)
a3098 2
  static char buffers[2][BUFSIZE];
  static int whichbuf = 0;
a3107 2
    char *buffer = buffers[whichbuf];
    whichbuf ^= 1;
d3156 4
a3159 1
    my($newargs) = join(", ", map { /pathname/ ? "rewrite($_)" : $_ } @@alist);
d3186 1
@


1.444
log
@be less eager to grab random Makefiles
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.443 2007/07/08 21:53:25 zaphod Exp zaphod $;
d1505 2
a1506 2
      ++$uid;
      $uid = 1 if $uid == 65536;
@


1.443
log
@build Haskell Cabal packages that don't contain libraries
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.442 2007/07/01 20:50:29 zaphod Exp zaphod $;
a3605 20
  # look for Unixish or OS-specific Makefile in a subdir and mv it here
  # e.g. zip -> unix/Makefile; libpng -> scripts/makefile.linux
  # note that this rule would incorrectly grab a spurious subdirectory
  # Makefile from glibc+linuxthreads or j2sdk 1.5 if the above rules didn't
  # come first
  return $dir unless dfs
  (
    $dir,
    sub { true },
    sub
    {
      my($rel) = @@_;
      return true unless $rel =~ /makefile/i;
      return true unless $rel =~ /$^O|\bunix/i;
      mv($_, path($dir, "Makefile"));
      return false;
    },
    sub { true }
  );

d3655 20
@


1.442
log
@upgrade to GPL version 3
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.441 2007/06/04 23:32:59 zaphod Exp zaphod $;
d3372 2
a3373 1
        "\trunghc $_ register\n",
@


1.441
log
@fix conf write bug with sticky options on newly added packages;
add wish list item
@
text
@d6 2
a7 2
# Copyright (C) 2003-2006 Jacques Frechet.                                   #
# Note that this file contains Version 2 of the GNU General Public License,  #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.440 2006/12/29 22:47:10 zaphod Exp zaphod $;
d46 1
a46 1
my($mycopyright) = "Copyright (C) 2003-2006 Jacques Frechet";
d6011 1
d6013 1
a6013 1
		       Version 2, June 1991
d6015 1
a6015 2
 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
d6021 10
a6030 8
  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
d6036 8
a6043 8
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
d6046 32
a6077 21
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.
a6080 3

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
d6082 414
a6495 133
  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
d6498 56
a6553 3
  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
d6555 18
a6572 35
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.
d6574 4
a6577 2
  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
d6581 50
a6630 37
Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
d6633 1
a6633 1

d6642 1
a6642 1
convey the exclusion of warranty; and each file should have at least
d6648 1
a6648 1
    This program is free software; you can redistribute it and/or modify
d6650 1
a6650 1
    the Free Software Foundation; either version 2 of the License, or
d6659 1
a6659 3
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

d6663 2
a6664 2
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
d6666 2
a6667 2
    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
d6672 15
a6686 19
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
d7877 1
a7877 1
This manual is part of B<toast>.  Copyright (C) 2003-2006 Jacques Frechet.
d7881 1
a7881 1
Free Software Foundation; either version 2 of the License, or (at your
d7890 1
a7890 2
along with B<toast>; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
@


1.440
log
@change --hspkg behavior (untested, still disabled by default)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.439 2006/12/14 04:25:03 zaphod Exp zaphod $;
d419 1
a419 1
      if($changed)
d7475 1
@


1.439
log
@fix and document detector for dpkg's broken install-info
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.438 2006/12/14 02:02:42 zaphod Exp zaphod $;
d1606 1
a1606 1
  push(@@vars, newenvvar("GHC_PKG_PATH", $hspkgdir)) if hspkg;
a2903 56
wrapper="$rootdir/bin/ghc.wrapped"
cat > "$wrapper" << "EOF"
#!/bin/sh
exec perl -wx "$0" "$@@"
#!perl

$0 =~ m!([^/]+)$! or die;
my($me) = $1;

my($wrap) = $ENV{"TOAST_HS_WRAPPER"} || "";
$wrap .= ":" if $wrap;
$ENV{"TOAST_HS_WRAPPER"} = $wrap .= $0;

my(@@extra);
push(@@extra, ($me =~ /-pkg/ ? "-" : "") . "-package-conf", $_)
    for grep(-r, split(/:/, $ENV{"GHC_PKG_PATH"} || ""));

DIR: for(split(/:/, $ENV{"PATH"}))
{
  for("$_/$me.unwrapped", "$_/$me")
  {
    if(-x)
    {
      my(@@stats) = stat or die("stat $_: $!");
      my($skip);
      for $skip (split(/:/, $wrap))
      {
        my(@@skipstats) = stat($skip) or die("stat $skip: $!");
        next DIR if "$skipstats[0] $skipstats[1]" eq "$stats[0] $stats[1]";
      }
      if(exists($ENV{"TOAST_VERBOSE_HS_WRAPPER"}))
      {
        print("toast: not rewriting $0 @@ARGV\n") unless @@extra;
        print("toast: rewriting $0 @@ARGV -> $0 @@extra @@ARGV\n") if @@extra;
      }
      exec $_ ($0, @@extra, @@ARGV);
      die("exec $_ failed: $!");
    }
  }
}

die("can't find next $me in PATH");
EOF

chmod +x "$wrapper"
for i in ghc ghci ghc-pkg; do
  path="$rootdir/bin/$i"
  if [ -r "$path" -a ! -r "$path.unwrapped" ] && ! diff -q "$path" "$wrapper"
  then
    mv "$path" "$path.unwrapped"
  fi
  ln -sf ghc.wrapped "$rootdir/bin/$i"
done

[ "$*" = "--toast-install-wrapper-only" ] && exit 0

a4063 15
sub wraphaskell($$$)
{
  my($srcdir, $rootdir, $helperdir) = @@_;
  return true unless -x(path($rootdir, qw(bin ghc)));
  my($script) = path($helperdir, "ghc-pkg");
  if(!-x($script))
  {
    optmd($helperdir);
    helphspkg($rootdir, $helperdir, "wrap-ghc");
    $script = path($helperdir, "wrap-ghc");
    armhelpers($helperdir);
  }
  run($script, "--toast-install-wrapper-only");
}

a4069 1
  wraphaskell($srcdir, $rootdir, $helperdir) if hspkg;
d7301 1
a7301 1
which helpds things like DocBook operate correctly.  If B<xmlcatalog>
d7308 13
a7320 18
When B<hspkg> is enabled, B<toast build> will generate various terrible
wrapper scripts for ghc and related commands, and B<toast arm> and
B<toast disarm> will maintain a Haskell package database B<armdir> called
C<etc/xml/toast-hs-package.conf>, whose presence and contents depend on
the contents of B<armdir>'s C<hspkg> subdirectory, which in turn will be
automatically populated by a wrapper script whenever a Haskell library
built via B<toast build> tries to register itself in the package database.
If the package database already exists, it may be overwritten or deleted.
The B<toast env> command will set C<GHC_PKG_PATH> to point to this file
when this option is set, which will cause wrapper scripts installed with
ghc and/or Haskell libraries to insert a --package-conf argument into
the command lines of some of the appropriate programs.  This approach
has many flaws and is not unlikely to cause more problems than it solves.
If B<hspkg> is disabled, B<toast build> will not attempt to generate any
Haskell-specific wrapper scripts (which may prevent Haskell libraries
from building, at least with GHC 6.4); B<toast arm> and B<toast disarm>
will delete the C<toast-hs-package.conf> file, if present, instead of
rebuilding it.  Poorly tested against GHC 6.4 only.  Default: disabled.
@


1.438
log
@force --noinfodir if install-info is missing or broken
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.437 2006/12/14 00:28:02 zaphod Exp zaphod $;
d4416 2
a4417 1
  my($bogus) = $prog && whilefile { !/Ian Jackson/ } $prog; # dpkg
d4419 1
a4419 1
  if(!$prog || $bogus)
d4447 1
a4447 1
    rmall($tmpdir);
d7576 1
@


1.437
log
@remove --infodiropt; use a temporary directory for install-info
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.436 2006/12/13 23:52:54 zaphod Exp zaphod $;
d1546 1
a1546 1
sub which($)
d1555 7
a1561 1
  error("can't find $prog in PATH");
d4415 2
d4418 1
a4418 1
  if(!infodir)
d7352 11
a7362 7
When B<infodir> is enabled, B<toast arm> and B<toast disarm> will create
a file in B<armdir> called C<info/dir>; if the file already exists,
it will be replaced with an updated version.  When this option is set,
B<toast env> sets C<INFODIR> to point to this file, so that the "info"
command can display a list of installed info pages.  If B<infodir> is
disabled, B<toast arm> and B<toast disarm> will delete the C<info/dir>
file, if present, instead of rebuilding it.  Default: enabled.
@


1.436
log
@fix --infodiropt behavior to placate dpkg's fake install-info command
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.435 2006/12/12 02:31:42 zaphod Exp zaphod $;
a306 1
    "infodiropt" => "--dir-file=",
d4420 2
a4421 2
    my($tmpfile) = addtmp($dirfile);
    if(-e($tmpfile) || -l($tmpfile))
d4424 1
a4424 1
      rm($tmpfile);
d4432 2
a4433 2
      optrun("install-info", infodiropt ? (infodiropt . $tmpfile, $_) :
          ($_, $tmpfile));
d4436 1
d4438 1
a7081 9
=item B<--infodiropt=>I<STRING>

When the B<infodir> option is enabled, B<toast arm> and B<toast disarm>
will prepend I<STRING> to the C<install-info> command argument containing
the full path of the file to be created or updated.  See the B<infodir>
option for details.  Previous versions of B<toast> used the empty string,
which causes the path in question to be passed as the second positional
argument to B<install-info>.  Default: C<--dir-file=>.

@


1.435
log
@add --infodiropt; update copyright year
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.434 2006/12/12 00:48:19 zaphod Exp zaphod $;
d4433 2
a4434 1
      optrun("install-info", $_, infodiropt . $tmpfile);
d7084 5
a7088 5
will prepend I<STRING> to the C<install-info> command's second argument,
which is the full path of the file to be created or updated, and not
(for example) the directory containing that file.  See the B<infodir>
option for details.  Previous versions of B<toast> used the empty string.
Default: C<--dir-file=>.
@


1.434
log
@force directories to be readable; document more bugs;
misc fixes for xcircuit, tcl/tk, flash, firefox
@
text
@d6 1
a6 1
# Copyright (C) 2003-2005 Jacques Frechet.                                   #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.433 2005/12/11 23:38:18 zaphod Exp zaphod $;
d46 1
a46 1
my($mycopyright) = "Copyright (C) 2003-2005 Jacques Frechet";
d307 1
d4433 1
a4433 1
      optrun("install-info", $_, $tmpfile);
d7080 9
d7610 1
a7610 1
This manual is part of B<toast>.  Copyright (C) 2003-2005 Jacques Frechet.
@


1.433
log
@try to improve toast's treatment of multiple armdirs;
adjust description of toast find
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.432 2005/11/27 07:01:15 zaphod Exp zaphod $;
d2764 1
d3533 2
a3534 2
  # configure script might be hidden in a "source" subdirectory (e.g. samba)
  for(qw[source src])
d3740 1
a3740 1
    $name =~ /readme|flashplayer-installer|^[A-Z]+$|\.(doc|html)$/;
d4005 1
a4005 1
      $ok ||= m!/(usr|bin|etc|lib|sbin)$!;
d4076 1
a4076 1
    sub { $count{$_} < $total ? !protect || safechmod(0555, $_) : rd($_) }
d7519 1
d7527 2
d7531 2
d7559 1
d7561 1
@


1.432
log
@call LWP directly from toast get; reformat certain error messages
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.431 2005/11/27 05:47:57 zaphod Exp zaphod $;
d1562 1
a1562 1
  my($varname, $subdirs, $default, $delim) = @@_;
d1564 4
a1567 1
  my(@@dirs) = map(path(armdir, $_), split(/$delim/, $subdirs));
d2229 1
a2229 1
sub allarmdirs()
d2231 5
d2237 1
a2237 1
  for (armdir, split(/:/, altarmdirs))
d2239 1
d2257 1
a2257 1
    for (allarmdirs)
d4935 2
a4936 1
          for(@@armdirs)
d4940 1
a4940 1
          if(ismismatched($name, $version, $build))
d6574 10
a6583 10
Locate some of the URLs from which a package could be downloaded.
This command does not write to the disk at all.  The output format is
similar to that of B<toast status>, but all information comes from the
network rather than the on-disk package database.  If a given package
has not been added and no URLs were specified on the command line,
B<toast find> looks for an exact name match on the web sites specified
by the B<findsites> option; otherwise it attempts to list the directory
or directories to which the package's URL(s) belong.  If an explicit
version number is given, only that version is listed; otherwise all
versions are listed from oldest to newest.
d6685 5
a6689 6
Deletes symlinks created by B<toast arm>.  This works by removing symbolic
links to the given build and replacing any links that had been moved
out of the way.  No error occurs if no such links exist.  If no build
number is given, all C<armed> builds, including C<mismatched> builds
reported to be C<armed>, are disarmed from all directories specified
by the B<armdir> and B<altarmdirs> options.  If the package version
d6691 6
a6696 1
the given name are disarmed.
d6779 6
a6784 3
add C<I<armdir>/bin> to the front of C<PATH>, unless either directory
already appears anywhere in C<PATH>, in which case that directory will
be left in its current position instead of being moved to the front.
d6793 3
a6795 3
C<MANPATH> is set before invoking B<toast env>.  This command assumes a
Bourne-like shell -- zsh and bash will work, tcsh won't.  None of this
is likely to be necessary if B<armdir> is C</usr> or C</usr/local>
d6935 13
a6947 8
Specifies an optional colon-separated list of alternate directories to
search for armed packages after searching I<ARMDIR>.  It is strongly
recommended that this list include any directory where a package is
likely to be armed.  is searched to determine whether a package is
currently armed.  When disarming a package, links will be removed from
each I<ALTARMDIR> in addition to I<ARMDIR> itself.  If an I<ALTARMDIR>
is not an absolute path, it is taken to be relative to I<STOREDIR>.
Default: empty list.
d7551 1
a7551 1
  - toast status/env should allow multiple read-only storedirs/armdirs
@


1.431
log
@improve name/version guessing; update buglist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.430 2005/11/25 00:08:46 zaphod Exp zaphod $;
d79 8
d89 1
a89 1
  die(join('', @@_) || "assertion failed", "\n[" . trace . "]\n");
d94 1
a94 1
  warn(join('', @@_) || "warning", "\n[" . trace . "]\n");
d1132 22
d1157 1
a1157 1
  my($newurl) = openurl(*SOURCE, $url);
@


1.430
log
@use built-in HTTP instead of wget so as to be able
to follow relative links after a redirect
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.429 2005/11/16 05:59:52 zaphod Exp zaphod $;
d1385 1
a1386 1
  $word =~ s/[\.-_]?(source|src)$//i; # e.g. mozilla, libjpeg, minicom, XFree86
a7461 2
  - toast add misguesses device-mapper name/version from URL
  - toast add misguesses [ foo-1.0-src.tar.gz foo-1.0-src.diff.gz ]
d7467 1
a7467 4
  - autofind fails for: sleepycat db, gcc, latex, gv, GNU arch (?), ogle,
      wxpython
  - autofind chooses Linux binaries over source for doxygen
  - autofind chooses old (2001) version of Postfix
@


1.429
log
@fix error when explicitly invoking "toast add" with sticky options
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.428 2005/11/16 05:54:00 zaphod Exp zaphod $;
d986 17
a1002 7
  openhttp(*HANDLE, $url, undef, $proxy);
  local($_);
  $_ = <HANDLE>;
  s/\r?\n?$//;
  m|^HTTP/[\w\.]+ 200 | || error("$url: $_");
  while(<HANDLE>) { last if /^\r?\n?$/ }
  return true;
d1108 2
a1113 1
  $proto eq "http" && openhttpurl(*HANDLE, $url) ||
d1116 2
d1127 1
a1127 1
  openurl(*SOURCE, $url);
d1140 1
d1180 2
a1181 2
  openurl(*HANDLE, $url);
  my(@@links) = linksfromstream(*HANDLE, $url);
d2569 1
a2569 1
    geturl($url, $file);
d2580 1
a2580 1
      my(@@links) = reverse(sort cmpab linksfromstream(*FILE, $url));
d2598 1
a7464 1
  - autofind mishandles http redirects (e.g. http://toastball.net/toast)
@


1.428
log
@experimental cvs support
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.427 2005/11/13 02:06:37 zaphod Exp zaphod $;
a2477 2
  setactivepkg($name, $version);

a7465 1
  - "toast add http://x/foo --confappend=bar" fails
@


1.427
log
@fix command-line parsing bug introduced in 1.422; correct buglist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.426 2005/11/11 05:56:39 zaphod Exp zaphod $;
d858 1
a858 1
sub optcdrun($@@)
d860 1
a860 1
  my($dir, @@prog) = @@_;
d871 1
d877 6
d889 6
d1379 1
d2535 15
d4661 8
d5369 1
d5476 1
a5476 1
        if(/^\w+:./)
d6559 3
d7468 1
@


1.426
log
@fix glitches in toast find
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.425 2005/11/11 05:37:16 zaphod Exp zaphod $;
d454 1
a454 1
    $cmdlineopt{$name} = $val;
a7426 1
  - "toast find mplayer" yields warnings and odd results
@


1.425
log
@fix "double slash in path ccache" bug; update buglist/wishlist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.424 2005/10/23 03:42:07 zaphod Exp zaphod $;
d2340 1
a2340 1
              grep { my($n) = guessnv($_); $n eq $name } @@matches;
d4709 1
@


1.424
log
@fix find-related assertion failure and fatal "ARRAY ref" error
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.423 2005/10/23 00:16:02 zaphod Exp zaphod $;
d2892 1
a2892 1
  $found ||= -x(path($_, "ccache")) for split(/:/, $path);
a7406 1
  - "toast arm udev" causes assertion failure
d7426 1
d7452 1
@


1.423
log
@attempt to fix problems that could occur whenever storedir or
armdir contained dev, proc, or tmp as a path component
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.422 2005/10/22 06:46:29 zaphod Exp zaphod $;
d2365 1
a2365 1
    return @@ret if @@ret;
a2449 1
    error unless $version;
@


1.422
log
@add per-package configuration files, --stickyopts, and --showopts
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.421 2005/10/13 04:43:43 zaphod Exp zaphod $;
d2770 2
a2771 1
    if(m|^/| && !m!^(\Q$srcdir\E|\Q$rootdir\E)($|/)!)
a2773 1
      s!^\Q$armdir\E($|/)!$1!;
d2951 2
a2952 1
  int result = strncmp(s, prefix, strlen(prefix)) == 0;
d2992 15
d3849 1
a3849 6
sub rootlinks()
{
  my(@@result) = stdlinks;
  push(@@result, $_, "/$_") foreach (qw[dev proc tmp]);
  @@result;
}
a7407 1
  - badness likely if storedir/armdir contains .../{dev,proc,tmp}/...
@


1.421
log
@fix man page typo; make toast upgrade work after toast edit
@
text
@d36 1
a36 1
  { eval('$foo = 1') && warn("use strict") }
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.420 2005/10/05 01:57:13 zaphod Exp zaphod $;
d94 3
a96 2
sub emptytoundef(@@) { map { defined($_) && $_ eq "" ? undef : $_ } @@_; }
sub undeftoempty(@@) { map { defined($_) ? $_ : "" } @@_; }
d267 1
d297 1
d345 3
a347 1
  sub dotfile()
d349 11
d364 60
a423 3
    -e && return $_ for(@@list);
    return undef;
  }
d425 2
a426 24
  sub loadopt($)
  {
    my($name) = @@_;
    error unless isopt($name);
    return $optloaded{$name} if %optloaded;
    $optloaded{1} = 1;
    my($dotfile) = dotfile;
    return unless defined($dotfile);
    whilefile
    {
      s/^\s+//;
      s/\s+$//;
      return true if $_ eq "" || /^\#/;
      /^([^\=]*?)\s*\=\s*(.*)$/ ||
          error("$dotfile: line $.: missing \"=\"");
      my($name, $val) = ($1, $2);
      isopt($name) ||
          error("$dotfile: line $.: unknown option name \"$name\"");
      !isboolopt($name) || isboolean($val) ||
          error("$dotfile: line $.: illegal boolean value: \"$val\"");
      $optloaded{$name} = $val;
      true;
    } $dotfile;
    $optloaded{$name};
d429 1
a429 3
  my(%optcurrent);

  sub setopt($$)
d448 24
a471 1
    $optcurrent{$name} = $val;
d477 6
a482 3
    setopt($name, firstdef(envopt($name), loadopt($name), $optdefault{$name}))
        unless exists($optcurrent{$name});
    return $optcurrent{$name};
d488 23
d2465 2
d2512 1
d4772 16
d4798 1
d4818 2
d5772 1
d5784 2
d5787 3
a5789 1
    if($@@)
d5791 1
a5791 1
      die($@@) if $$ != $pid;
d6883 25
d6945 7
a6951 5
but it can be awfully handy at times.  The I<ARGS> string is treated as
a list of space-separated words, each of which may be optionally quoted
with single or double quotes with backslash acting as an escape character;
the resulting words are added to the end of the command line.  Default:
empty string.
d7153 3
a7155 1
and installs by default.  Default: enabled.
d7208 1
a7208 1
When B<showurls> is enabled, B<toast show> always displays the stored
d7210 1
a7210 1
B<toast show> only displays a package's URLs if a different list of URLs
d7214 7
d7323 10
d7339 1
a7339 1
=item 3.
d7341 1
a7341 1
The configuration file.  If option I<NAME> has not been assigned a value
d7357 1
a7357 1
=item 4.
d7397 2
d7443 1
@


1.420
log
@improve --interactive
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.419 2005/10/04 06:38:31 zaphod Exp zaphod $;
d4548 3
d6345 1
a6345 1
=item s<B<toast find> I<PACKAGE> ...>
@


1.419
log
@fix --interactive to allow downgrade and mark current version w/ *
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.418 2005/10/04 05:27:12 zaphod Exp zaphod $;
d2313 1
a2313 1
  my($i) = 0;
d2318 4
a2321 1
    print((($curver && $version && $curver eq $version) ? "*" : " "), " $i) ",
d2327 1
a2327 1
    print(">[$i] ");
d2329 1
d2332 1
d4614 2
@


1.418
log
@fix sourceforge upgrade trouble by making --noautochange the default
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.417 2005/10/03 05:48:05 zaphod Exp zaphod $;
d2298 1
a2298 1
sub choose(@@)
d2300 1
a2300 1
  my(@@pkgs) = @@_;
d2318 2
a2319 2
    print("$i) ", join(" ", map(substr($_, $pl, $sl ? -$sl : 9999), @@urls)),
        "\n");
d2324 1
a2324 1
    print("> [$i] ");
d2343 1
a2343 1
    my(@@pkgs) = reverse(choose(findnewpkg($name, $version)));
d4603 2
a4604 1
  my(@@pkgs) = reverse(choose(findnewerpkg($name, $version, $build, @@urls)));
d4612 2
a4613 1
  error("only found older versions of $pkgname") if $sortvers[1] eq $version;
@


1.417
log
@toast find now searches freshmeat, sourceforge, ftp.gnu.org and CPAN;
added --findsites option to customize this behavior
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.416 2005/10/03 03:43:54 zaphod Exp zaphod $;
d274 1
a274 1
    "autochange" => "true",
d6830 8
a6837 10
When B<autochange> is enabled, B<toast get> may replace the URLs
stored by B<toast add> with the actual URLs of the files it downloaded.
This matters if an URL given on the command line points to an HTML page or
FTP directory rather than to an actual archive to be extracted and built.
In order to ensure consistent results, it is often desirable to store the
more specific URLs, especially if B<autopurge> is enabled.  If this option
is disabled, B<toast get> will still follow links in the usual way, but
stored URLs will be left untouched, and future invocations of B<toast get>
may end up downloading different files for the same package if new files
or links have since been added to a page or directory.  Default: enabled.
@


1.416
log
@improve toast find behavior when given a version number
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.415 2005/10/02 22:46:37 zaphod Exp zaphod $;
d266 1
d1278 1
d2158 19
d2179 1
a2179 5
  if($lcname eq $myname)
  {
    $url = $myurl;
  }
  else
d2181 1
a2181 5
    local(*XML, $_);
    my($sitename) = "freshmeat.net";
    openurl(*XML, "http://freshmeat.net/projects-xml/$lcname/$lcname.xml");
    my($notfound, %fmurl);
    while(<XML>)
d2183 14
a2196 4
      $notfound = /^Error: project not found/i ? 1 : 0 if !defined($notfound);
      $fmurl{$1} = $2 while m!<url_(\w+)>([^<]+)</!g;
    }
    close(XML) || error("unable to contact freshmeat.net");
d2198 1
a2198 1
    error("no listing for package $name on $sitename") if $notfound;
d2200 33
a2232 3
    my($redirurl);
    $redirurl ||= $fmurl{$_} for qw(bz2 tgz zip deb rpm homepage);
    $redirurl || error("no suitable URL for package $name on $sitename");
d2234 6
a2239 8
    my($redirhead) = httphead($redirurl);
    $redirhead =~ /^Location: ([^\r\n]+)/im ||
        error("unexpected response from $redirurl");
    $url = $1;
    # wget can't always get FTP directory listing correctly w/o trailing slash
    $url .= "/" if $url =~ m!^ftp:.*/[^/\.]+$!; # e.g. atop
    $url = cleanurl($url);
  }
d2241 3
a2243 22
  my(@@links) = $url;
  for(1..3)
  {
    $url = $links[$#links];
    @@links = sort cmpab grep(lookslikepkgurl(
        $_, defined($version) ? $name : undef, $version), @@links);
    my(@@result);
    for(@@links)
    {
      my($v) = $version;
      (undef, $v) = guessnv($_) unless defined($v);
      push(@@result, [$name, $v, undef, $_])
    }
    if(scalar(@@result) == 1)
    {
      eval
      {
        @@result = findnewerpkg(@@{$result[0]})
      }
    }
    return @@result if @@result;
    last if lookslikepkgurl($url);
d2245 6
a2250 6
    @@links = linksfromurl($url);
    my(@@urls) = grep(lookslikepkgurl($_, $name, $version), @@links);
    my($ext);
    for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .deb .rpm])
    {
      my(@@matches) = grep(stripquery($_) =~ /\Q$ext\E$/i, @@urls);
d2252 9
a2260 2
      my(@@namematches) = grep { my($n) = guessnv($_); $n eq $name } @@matches;
      @@matches = @@namematches if @@namematches;
d2262 2
a2263 5
      if(defined($version))
      {
        my(@@vermatches) =
            grep { my(undef, $v) = guessnv($_); $v eq $version } @@matches;
        @@matches = @@vermatches if @@vermatches;
d2265 1
d2267 2
a2268 12
      @@matches = sort cmpab @@matches;
      @@result = ();
      for(@@matches)
      {
        my($undef, $v) = guessnv($_);
        push(@@result, [$name, $v, undef, $_]);
      }
      return @@result if @@result;
    }

    @@links = grep(/^\Q$url\E/, @@links);
    last unless @@links;
d2271 1
a2271 1
  error("can't find URLs for " . pkgname($name, $version) . " at $url");
d6340 5
a6344 4
B<toast find> looks for an exact name match on freshmeat.net; otherwise
it attempts to list the directory or directories to which the package's
URL(s) belong.  If an explicit version number is given, only that version
is listed; otherwise all versions are listed from oldest to newest.
d6746 11
a7259 1
  - autofind should try other sites if freshmeat.net has no listing
@


1.415
log
@make toast upgrade work on file:// URLs
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.414 2005/10/02 22:20:31 zaphod Exp zaphod $;
d2194 2
a2195 1
    @@links = sort cmpab grep(lookslikepkgurl($_), @@links);
d2211 1
a7195 1
  - "toast find bc/3.14159" yields bizarre results
@


1.414
log
@work around psutils problem
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.413 2005/10/01 23:38:57 zaphod Exp zaphod $;
d1052 1
d4487 1
a4487 1
    m!^((http|ftp)://[^\?]+/)([^\?/]*)(\?.*)?$!i ||
a7194 1
  - "toast upgrade" doesn't like file:// URLs
@


1.413
log
@fix --interactive glitch; remove stale bug reports
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.412 2005/09/30 06:10:35 zaphod Exp zaphod $;
d1387 1
a1387 1
sub findperl()
d1389 2
a1390 2
  my($result);
  if($^X !~ m!/!) # 5.8.2 doesn't need all this, but 5.6.1 seems to
d1392 1
a1392 18
    for(split(/:/, $ENV{"PATH"}))
    {
      my($path) = path($_, $^X);
      if(-x($path) && !-d($path)) # thanks Frederik!
      {
        $result = $path;
        last;
      }
    }
  }
  $result = abspath($^X) unless defined($result);
  $result = abspath($result) unless $result =~ m!^/!;
  return $result if -x($result);

  # maybe it moved as a result of arm/disarm or something...?
  for(split(/:/, $ENV{"PATH"}), "/usr/bin", "/usr/local/bin", "/bin")
  {
    my($path) = path($_, "perl");
d1396 1
a1396 1
  return "/usr/bin/perl";
d1487 1
a1487 1
  optrun(findperl, "-V");
d2592 7
a2598 3
  my($perl) = findperl;
  error("can't find perl: $perl") unless -x($perl);
  writescript(path($helperdir, "$cmd.helper"), "#!$perl\n# $genby\n", q[
d3593 2
d7193 2
a7217 1
  - have autofind/upgrade prompt for version (?)
@


1.412
log
@added --interactive (disabled by default)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.411 2005/09/23 05:22:07 zaphod Exp zaphod $;
d2288 1
a2288 1
  return @@pkgs unless @@pkgs && interactive;
a7184 2
  - autofind produces URLs with extra slashes, e.g. "toast arm latex"
  - make oldconfig isn't running for linux/2.6.x
@


1.411
log
@build gcc 4.x
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.410 2005/09/20 00:25:13 zaphod Exp zaphod $;
d290 1
d2285 34
d2330 1
a2330 1
    my(@@pkgs) = reverse(findnewpkg($name, $version));
d2775 1
a2775 2
    writescript(path($helperdir, $_), qq[
#!/bin/sh
d4584 1
a4584 1
  my(@@pkgs) = reverse(findnewerpkg($name, $version, $build, @@urls));
d6978 9
d7205 1
@


1.410
log
@cover up some toast find glitches
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.409 2005/09/19 04:47:38 zaphod Exp zaphod $;
d3207 1
@


1.409
log
@improved and documented toast find
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.408 2005/09/17 06:28:18 zaphod Exp zaphod $;
d4442 1
a4442 1
sub findnewerpkg($$@@)
d4447 1
d4522 2
a4523 2
  my(@@pkgs) = @@urls || isadded($name, $version)
      ? findnewerpkg($name, $version, @@urls)
d4549 1
a4549 1
  my(@@pkgs) = reverse(findnewerpkg($name, $version, @@urls));
d5391 10
d5431 1
a5431 1
sub parse_find(@@) { uselatestversion(emptytoall(rejectbuilds(parse(@@_)))); }
@


1.408
log
@fix "gcc.helper" bug for packages that invoke gcc during "make install";
improve version-number-guessing heuristic for shar archives
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.407 2005/09/15 01:50:14 zaphod Exp zaphod $;
d2205 1
d2208 4
a2211 1
    if(lookslikepkgurl($url))
d2213 3
a2215 2
      (undef, $version) = guessnv($url) unless defined($version);
      return [$name, $version, undef, $url];
d2217 8
d2226 1
a2226 1
    my(@@links) = linksfromurl($url);
d2236 1
a2236 2
      my($matchver) = $version;
      if(!defined($matchver))
d2238 3
a2240 12
        my(@@versions) = map { my(undef, $v) = guessnv($_); $v } @@matches;
        @@versions = grep(defined($_), @@versions);
        if(@@versions)
        {
          @@versions = reverse sort cmpab @@versions;
          $matchver = $versions[0];
          @@matches = grep
          {
            my(undef, $v) = guessnv($_);
            defined($v) && $v eq $matchver;
          } @@matches;
        }
d2243 8
a2250 2
      # TODO: return an ordered list of candidates, not just the best match
      return ([$name, $matchver, undef, $matches[0]]) if @@matches;
a2254 1
    $url = pop(@@links);
d4521 1
a4521 1
  my(@@pkgs) = isadded($name, $version)
d6268 12
d6747 3
a6749 4
automatically look up package URLs on freshmeat.net when none have
been added previously or given explicitly.  If no version number is
given either, the latest version listed on freshmeat.net will be used.
Default: enabled.
a7148 1
  - "toast find" is undocumented and shows only best match for new pkgs
d7176 1
@


1.407
log
@fix terrible autofind "strict refs" bug introduced in 1.404;
apply --ccache to g++ and remove from wishlist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.406 2005/09/13 06:34:41 zaphod Exp zaphod $;
d152 1
a152 1
sub stripext($) { my($a) = @@_; $a =~ s/(\.tar(\.g?z)?)?(\.[a-z]\w*)?$//i; $a; }
d2736 1
a2736 1
exec ccache $_ "\$\@@"
@


1.406
log
@fix --ccache problem when running as root
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.405 2005/09/13 06:21:19 zaphod Exp zaphod $;
d2210 1
a2210 1
      return ($name, $version, $url);
d3080 1
a3080 1
  helpccache($rootdir, $helperdir, $_) for (qw[cc gcc]);
a7159 1
  - ccache
@


1.405
log
@add --ccache
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.404 2005/09/12 04:08:07 zaphod Exp zaphod $;
a2729 19
  my($storecachedir) = path(storedir, "ccache");
  my($cachedir);
  if(exists($ENV{"CCACHE_DIR"}))
  {
    $cachedir = $ENV{"CCACHE_DIR"};
  }
  elsif(superuser)
  {
    optmd($cachedir = $storecachedir);
  }
  else
  {
    return true unless exists($ENV{"HOME"}) && -d($ENV{"HOME"});
    $cachedir = path($ENV{"HOME"}, ".ccache");
  }

  chownnonroot($cachedir) if superuser && !belongstononroot($cachedir) &&
      optsamefile($cachedir, $storecachedir);

a2735 2
CCACHE_DIR=$cachedir
export CCACHE_DIR
d3923 25
@


1.404
log
@preliminary work on toast find; fixed doc glitch;
noted some more feature requests
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.403 2005/09/09 20:37:45 zaphod Exp zaphod $;
d284 1
d1361 9
d2720 42
d3101 1
d6832 14
@


1.403
log
@build GHCi libraries; make --nohspkg the default;
record various issues
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.402 2005/09/08 05:22:05 zaphod Exp zaphod $;
d2230 2
a2231 1
      return ($name, $matchver, $matches[0]) if @@matches;
d2275 10
a2284 2
  ($name, $version, @@urls) = findnewpkg($name, $version)
      unless @@urls || !autofind;
d4377 1
a4377 1
sub upgrade(@@)
a4381 1
  error if defined($build);
d4423 5
a4427 2
  my($newver);
  for(reverse(sort cmpab keys(%candidates)))
d4431 2
a4432 1
    for(@@newurls)
d4441 1
d4443 30
a4472 5
    if($ok)
    {
      $newver = $candidate;
      last;
    }
d4475 12
a4487 2
  error("URLs for $pkgname don't look version-specific") unless $hasver;
  error("can't find consistent URLs for $pkgname") unless defined($newver);
a4492 8
  for(@@newurls)
  {
    next unless ref;
    my(%vermap) = %$_;
    $_ = $vermap{$newver};
  }

  my(@@cmdargs) = ($name, $newver, undef, @@newurls);
d5355 1
d6777 1
a6777 2
are never treated specially.  See also the B<disarmmismatched> option.
Default: enabled.
d7059 1
a7060 1
  - "toast man" refers to nonexistent disarmmismatched option
d7084 3
a7086 1
  - add "toast find" and/or have autofind/upgrade prompt for version (?)
d7089 1
@


1.402
log
@add --makeappend as requested
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.401 2005/09/08 04:39:31 zaphod Exp zaphod $;
d294 1
a294 1
    "hspkg" => "true",
d2630 1
d2686 4
a2691 1
    --toast-install-wrapper-only) exit 0 ;;
d6870 7
a6876 6
the command lines of some of the appropriate programs.  If B<hspkg> is
disabled, B<toast build> will not attempt to generate any Haskell-specific
wrapper scripts (which may prevent Haskell libraries from building, at
least with GHC 6.4); B<toast arm> and B<toast disarm> will delete the
C<toast-hs-package.conf> file, if present, instead of rebuilding it.
Tested with GHC 6.4.  Default: enabled.
d7020 1
d7043 2
@


1.401
log
@reorder Haskell wrapper arguments; update copyright notices
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.400 2005/09/07 05:47:57 zaphod Exp zaphod $;
d269 1
d3538 3
a3540 2
  return cdrun($dir, @@prog) unless @@targets;
  cdrun($dir, @@prog, $_) foreach @@targets;
d6590 8
@


1.400
log
@fix proxy URL parsing bug; restore perl 5.005_03 compatibility
@
text
@d6 1
a6 1
# Copyright (C) 2003-2004 Jacques Frechet.                                   #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.399 2005/09/06 06:42:44 zaphod Exp zaphod $;
d46 1
a46 1
my($mycopyright) = "Copyright (C) 2003-2004 Jacques Frechet";
d2663 1
a2663 1
        print("toast: rewriting $0 @@ARGV -> $0 @@ARGV @@extra\n") if @@extra;
d2665 1
a2665 1
      exec $_ ($0, @@ARGV, @@extra);
d7065 1
a7065 1
This manual is part of B<toast>.  Copyright (C) 2003-2004 Jacques Frechet.
@


1.399
log
@once more with feeling
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.398 2005/09/06 03:40:29 zaphod Exp zaphod $;
d846 1
a846 1
    $proxy =~ m!^(\w+://)?([-\w\.]+)(:(\d+))?([^:]+)(:(\d+))?/?$!
d2205 1
a2205 1
    for $ext qw[.tar.bz2 .tar.gz .tgz .zip .deb .rpm]
d2595 1
a2595 1
      -d("$armdir$_") && mkdir("$rootdir$_") &&
d6988 1
@


1.398
log
@more of the same
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.397 2005/09/06 00:10:01 zaphod Exp zaphod $;
a2638 1
my(@@extra);
d2640 1
a2640 9
if($wrap)
{
  $wrap .= ":";
}
else
{
  push(@@extra, ($me =~ /-pkg/ ? "-" : "") . "-package-conf", $_)
      for grep(-r, split(/:/, $ENV{"GHC_PKG_PATH"} || ""));
}
d2643 4
@


1.397
log
@further Haskell wrapper changes
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.396 2005/09/05 22:29:42 zaphod Exp zaphod $;
d2665 6
a2670 1
      exec $_ ($0, @@extra, @@ARGV);
d2680 1
a2680 1
for i in ghc ghci ghc-pkg runghc runhaskell; do
@


1.396
log
@try to fix some serious flaws in the Haskell wrapper stuff
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.395 2005/09/05 00:36:12 zaphod Exp zaphod $;
d1443 1
a1443 1
  push(@@vars, newenvvar("HS_PKG_PATH", $hspkgdir)) if hspkg;
d2647 2
a2648 1
  push(@@extra, "--package-conf=$_") for split(/:/, $ENV{"HS_PKG_PATH"} || "");
d2675 1
a2675 1
for i in ghc; do
d6853 1
a6853 1
The B<toast env> command will set C<HS_PKG_PATH> to point to this file
@


1.395
log
@register Haskell libraries that use Setup.hs
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.394 2005/09/04 20:20:54 zaphod Exp zaphod $;
d2624 1
d2630 2
a2631 1
cat > "$rootdir/bin/ghc" << "EOF"
d2633 1
a2633 1
exec perl -wx "$0"
a2637 1
my(@@mystats) = stat($0) or die("stat $0: $!");
d2640 10
a2649 1
push(@@extra, "-package-conf", $_) for split(/:/, $ENV{"HS_PKG_PATH"} || "");
d2651 1
a2651 1
for(split(/:/, $ENV{"PATH"}))
d2653 1
a2653 2
  my($prog) = "$_/$me";
  if(-x($prog))
d2655 12
a2666 4
    my(@@progstats) = stat($prog) or die("stat $prog: $!");
    next if $progstats[0] == $mystats[0] && $progstats[1] == $mystats[1];
    exec($prog, @@extra, @@ARGV);
    die("exec $prog failed: $!");
d2673 8
a2680 3
chmod +x "$rootdir/bin/ghc"
for i in ghc-pkg runghc runhaskell; do
  ln -sf ghc "$rootdir/bin/$i"
d2685 1
d3806 15
d3827 1
d4177 1
a4177 1
  optrun("ghc-pkg", "--force", "-f", $file, "register", $_) for(@@pkgs);
d6844 3
a6846 2
When B<hspkg> is enabled, B<toast arm> and B<toast disarm>
will maintain a Haskell package database B<armdir> called
d6850 11
a6860 9
tries to register itself in the package database.  If the package database
already exists, it may be overwritten or deleted.  The B<toast env>
command will set C<HS_PKG_PATH> to point to this file when this option
is set, which will cause further wrapper scripts automatically installed
with Haskell libraries to insert a -package-conf argument into the command
lines of all the appropriate programs.  If B<hspkg> is disabled, B<toast
arm> and B<toast disarm> will delete the C<toast-hs-package.conf> file,
if present, instead of rebuilding it.  Tested with GHC 6.4.  Default:
enabled.
@


1.394
log
@first attempt at supporting Haskell libraries under ghc
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.393 2005/08/29 04:50:38 zaphod Exp zaphod $;
d3082 2
a3083 1
      cdrunconf($dir, "runghc", $_, "configure", "--prefix=$prefix");
d3090 1
@


1.393
log
@ask Config.pm how to compile rewrite.so
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.392 2005/08/27 23:19:24 zaphod Exp zaphod $;
d293 1
d1434 1
d1443 1
d2621 51
d3010 1
d3568 8
a3575 5
      (qw[bin boot etc include info lib libexec man share src var],
      map(path("man", "man$_"), 1..9), path(qw[var spool]),
      path(qw[etc rc.d]), map(path("etc", "rc.d", "rc$_.d"), 0..6), # vmware
      path(qw[var run]), # hotplug/2004_01_05
      path(qw[share aclocal])); # librep/0.16.1
d4112 35
d4216 1
d4309 1
d6801 17
d6958 1
@


1.392
log
@default to --nostrictpreload under non-Linux; claim support for OS X
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.391 2005/08/27 22:34:13 zaphod Exp zaphod $;
d2887 11
a2897 4
  my(@@socc) = qw[gcc -fPIC -shared -Wall];
  push(@@socc, qw[-Werror]) if strictpreload;
  my(@@sol) = ();
  push(@@sol, qw[-ldl]) if $^O =~ /linux/i;
d2902 5
a2906 3
  return path($helperdir, "rewrite.so")
      if optcdrun($helperdir, @@socc, qw[dummy.c -o rewrite.so])
      && optcdrun($helperdir, @@socc, qw[rewrite.c -o rewrite.so.helper], @@sol);
@


1.391
log
@install instructions: replace broken telnet command with pure-Perl command
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.390 2005/08/26 05:25:13 zaphod Exp zaphod $;
d284 1
a284 1
    "strictpreload" => "true",
d5919 8
a5926 7
B<toast> itself is known to work with Perl 5.005_03 through 5.8.x under
Linux, FreeBSD, Solaris, and Cygwin, without relying on the presence
or absence of any Perl modules or other tools.  Perl is available for
download at C<http://www.cpan.org/src/stable.tar.gz>.  Although it isn't
required, B<toast get> works better if you have GNU wget; you can use
C<toast arm wget> to download and install it if necessary.  Additional
requirements for B<toast build> vary according to the package being built.
d6595 5
a6599 4
to build the shared library causes B<toast build> to behave as if
the B<preload> option were disabled.  This may allow B<toast build>
to succeed in the absence of a suitable C compiler, but it may allow
some packages to build incorrectly in some situations.  Default: enabled.
@


1.390
log
@check for Setup.hs before configure
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.389 2005/08/26 05:17:36 zaphod Exp zaphod $;
d5932 4
a5935 2
requires GNU wget; the second relies on the GET utility that comes with
the LWP Perl module; the third uses telnet.
d5938 1
d5940 4
a5943 1
  echo GET /toast/toast|telnet toastball.net 80|perl -x - arm toast
@


1.389
log
@trivial doc fixes
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.388 2005/07/24 18:37:09 zaphod Exp zaphod $;
d3010 20
a3316 18
  # Haskell Cabal (http://www.haskell.org/cabal/)
  for("Setup.hs", "Setup.lhs")
  {
    if(-r(path($dir, $_)))
    {
      cdrun($dir, qw(ghc-pkg list)); # work around ~/.ghc bug in ghc-pkg 6.4 (?)
      cdrunconf($dir, "runghc", $_, "configure", "--prefix=$prefix");
      writefile
      (
        path($dir, "Makefile"),
        "# $genby\n\n",
        "all:\n\trunghc $_ build\n\n",
        "install:\n\trunghc $_ copy --copy-prefix=\$(DESTDIR)\n",
      );
      return $dir;
    }
  }

@


1.388
log
@cover up an obscure command line parsing quirk
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.387 2005/07/18 03:00:47 zaphod Exp zaphod $;
d6183 1
a6183 1
=item <B<toast env>>
d6201 1
a6201 1
is likely to be unnecessary if B<armdir> is C</usr> or C</usr/local>
@


1.387
log
@try to suppress yet another harmless warning for versionless packages
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.386 2005/07/06 06:15:57 zaphod Exp zaphod $;
d4981 1
a4981 1
        if(/^\w+:/)
@


1.386
log
@try to fix x86-64
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.385 2005/07/04 22:35:35 zaphod Exp zaphod $;
d1921 1
@


1.385
log
@try to suppress harmless head -1 warning for some versionless packages
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.384 2005/07/04 19:05:50 zaphod Exp zaphod $;
d2886 1
a2886 1
  my(@@socc) = qw[gcc -shared -Wall];
@


1.384
log
@suppress meaningless "yes count exceeded" message
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.384 2005/07/04 19:01:59 zaphod Exp zaphod $;
d1911 1
a1911 1
  $cmd .= "head -1";
d1921 1
a1921 1
  chomp $result;
@


1.383
log
@don't try to run any directories called "perl" appearing in PATH
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.382 2005/06/24 03:48:28 zaphod Exp zaphod $;
d1479 2
a1480 2
  print("\n") || exit(0) foreach 1..9999;
  error("yes count exceeded");
@


1.382
log
@allow options later in command line; log command line during build
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.381 2005/06/10 23:01:35 zaphod Exp zaphod $;
d1382 1
a1382 1
      if(-x($path))
@


1.381
log
@identify shar archives without shebang lines (e.g. ISC (Vixie) cron);
new feature request
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.380 2005/05/17 05:04:31 zaphod Exp zaphod $;
a1460 1
optrun("printenv") || optrun("env");
d1491 1
d5247 2
a5248 2
  my($opt, $cmd);
  while(($opt = shift) && $opt =~ /^-/ && $opt ne "--")
d5250 11
a5306 2
  my(@@result) = @@_;
  unshift(@@result, $opt) if defined($opt) && $opt ne "--";
@


1.380
log
@Setup.hs and Setup.lhs are equivalent
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.379 2005/05/12 06:05:10 zaphod Exp zaphod $;
d1535 1
a1535 1
  return ".shar" if m:^\#!/bin/sh\n\# This is a shell archive:;
d6837 1
@


1.379
log
@Haskell Cabal
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.378 2005/05/10 23:50:50 zaphod Exp zaphod $;
d3297 1
a3297 1
  if(-r(path($dir, "Setup.hs")))
d3299 13
a3311 10
    cdrun($dir, qw(ghc-pkg list)); # work around ~/.ghc bug in ghc-pkg 6.4 (?)
    cdrunconf($dir, qw(runghc Setup.hs configure), "--prefix=$prefix");
    writefile
    (
      path($dir, "Makefile"),
      "# $genby\n\n",
      "all:\n\trunghc Setup.hs build\n\n",
      "install:\n\trunghc Setup.hs copy --copy-prefix=\$(DESTDIR)\n",
    );
    return $dir;
@


1.378
log
@htmltidy
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.377 2005/05/04 04:30:03 zaphod Exp zaphod $;
d3296 15
a6816 1
  - add support for http://www.haskell.org/cabal/
@


1.377
log
@workaround for ISC DHCP; build non-module-capable Linux kernels;
try to resolve a glibc upgrade issue
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.376 2005/04/10 17:50:03 zaphod Exp zaphod $;
d1255 1
a1255 1
  $word =~ s/[\.-]?(source|src)$//i; # e.g. mozilla, libjpeg, minicom, XFree86
d3296 8
d3356 1
a3356 1
  error("can't figure out how to compile")
d6802 1
@


1.376
log
@replace assertion with error message
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.375 2005/03/17 03:31:38 zaphod Exp zaphod $;
d3047 1
d3197 4
a3200 3
    my($mftext) = "# $genby\n\nall:\n\t\$(MAKE) -C $emdir\n\n" .
        "install:\n\t\$(MAKE) -C $emdir install\n" .
        "\tyes '' | make -C $ehdir oldconfig dep\n"; # e.g. mtools expects this
d3451 2
@


1.375
log
@fix spurious assertion failure when disarming packages by URL;
add rule to build from setup.py (e.g. BitTorrent)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.374 2005/03/07 00:32:13 zaphod Exp zaphod $;
d2173 1
a2173 1
    close(XML) || error;
@


1.374
log
@do a better job of building modern linux kernels
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.373 2005/01/17 04:46:17 zaphod Exp zaphod $;
a1992 1
  @@urls && error;
d3279 15
@


1.373
log
@prevent toast's behavior from depending on the ordering of directory entries
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.372 2005/01/16 18:48:22 zaphod Exp zaphod $;
d3360 1
a3360 1
  my($lk) = false; # blatant special case for the Linux kernel
d3365 1
d3381 1
d3389 1
a3389 1
  @@targets = qw[oldconfig all] if $menuconfig;
d3394 1
a3394 1
  if($lk && reconfigure)
d3421 1
a3421 1
      $cdrtools, $e2fsprogs);
d3432 1
d3448 1
@


1.372
log
@wrappers in "helpers" directory were failing under obscure circumstances
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.371 2004/12/27 03:25:41 zaphod Exp zaphod $;
d451 1
a451 1
  local(*DIR, $_);
d453 4
a456 1
  while(defined($_ = readdir(DIR)))
d458 1
a458 3
    next if $_ eq ".";
    next if $_ eq "..";
    last unless &$sub($_);
d460 1
a460 2
  closedir(DIR);
  !defined($_);
@


1.371
log
@fix bug introduced in 1.369 that prevented toast from building itself
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.370 2004/12/26 19:49:27 zaphod Exp zaphod $;
d1390 1
d1397 1
@


1.370
log
@fix for spurious autogen.sh error introduced in 1.369
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.369 2004/12/26 07:01:02 zaphod Exp zaphod $;
d3069 20
a3088 17
    next if $self || $bogus;
    @@confcmd = ("./$cfg", "--prefix", $prefix) if $twowordprefix;
    @@confcmd = ("./$cfg") if $noprefix;
    push(@@confcmd, sort(grep($confopts{$_}, keys(%confopts))));
    unshift(@@confcmd, "sh") unless -x($confprog);
    if($builddir)
    {
      $confcmd[0] = "../$cfg";
      $dir = path($dir, "$myname-build.d");
      md($dir);
    }
    elsif($cfg eq "configure.gnu")
    {
      # force perl to install files it thinks are already installed
      # (5.8.2 and later support DESTDIR and should no longer need this)
      optpatch { s/^use File::Compare;$/sub compare(\$\$){1}; #$genby/ }
          path($dir, "installperl");
@


1.369
log
@build libmng
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.368 2004/12/19 04:49:55 zaphod Exp zaphod $;
d3015 1
a3015 1
    next unless -x($confprog) || $confprog =~ /\.sh$/;
@


1.368
log
@improved the preceding bugfix
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.367 2004/12/19 04:40:00 zaphod Exp zaphod $;
d3010 2
a3011 2
  #            autoconf  Perl          openssl elm       pmk (bootstrap)
  for $cfg (qw[configure configure.gnu config  Configure pmkcfg.sh])
d3014 13
a3026 1
    if(-x($confprog) && !-d($confprog))
d3028 1
a3028 10
      my($self) = false;
      my($builddir) = false;
      my($bogus) = false;
      my($twowordprefix) = false;
      my($noprefix) = false;
      my($mozilla) = false;
      my(%confopts);

      my($opensslcfg) = path($dir, "Configure");
      if(reconfigure && $cfg eq "config" && -x($opensslcfg))
d3030 3
a3032 5
        whilefile
        {
          !($confopts{"shared"} ||= /^# \[no-\]shared\s/);
        } $opensslcfg;
      }
d3034 21
a3054 42
      patch
      {
        $self ||= /this is toast 89a72ef9c34e1fd4927afa36c9be8b15/;
        $twowordprefix ||= /^\s*prefix=\$2; shift;;$/; # ocaml
        $twowordprefix ||= /  --prefix dir  /; # doxygen
        $builddir ||= /error: you must configure in a separate build/; # glibc
        $builddir||=m!\. \$srcdir/build-tools/scripts/configure-top !;#arch/tla
        $bogus ||= /There is no .+configure.+ script .+Instead/i; # libpng
        $bogus ||= /configure is no longer used - just type /i; # cdrtools
        s/(^\s*)read\s+(acceptance)(\s*$)/$1$2=yes$3/; # qt license
        s/^if test ! -t 0; /if false; /; # elm
        $noprefix = $confopts{"-d"} = 1 if /^\s*-d\) shift; fastread='y/; # elm
        if(reconfigure)
        {
          s/^\s*AUTOTHREAD=no\s+\#+ leave off for now/\#$&/; # qt multithreaded
          $mozilla = $1 if /(--enable-default-toolkit)=TK/;
          my($opt); # glibc; libjpeg; tetex; others?
          for $opt ("enable-add-ons", # glibc
              "enable-shared", # various
              "with-shared", # ncurses
              "disable-multiplatform") # tetex
          {
            $confopts{"--$opt"} ||= / \Q--$opt\E\b($|[^-])/;
          }
          $confopts{$1} = 1 if /"configure (-\S+)"; by default a static/;#zlib
        }
      } $confprog;
      $noprefix ||= -x(path($dir, "installnetpbm")); # netpbm 10.19
      if($mozilla)
      {
        local($^W) = false; # suppress misguided exec failure warning
        $confopts{"$mozilla=gtk2"} ||= system(qw(pkg-config gtk+)) == 0;
      }

      my(@@confcmd) = ("./$cfg", "--prefix=$prefix");
      if(!$self)
      {
        next if $bogus;
        @@confcmd = ("./$cfg", "--prefix", $prefix) if $twowordprefix;
        @@confcmd = ("./$cfg") if $noprefix;
        push(@@confcmd, sort(grep($confopts{$_}, keys(%confopts))));
        if($builddir)
d3056 1
a3056 10
          $confcmd[0] = "../$cfg";
          $dir = path($dir, "$myname-build.d");
          md($dir);
        }
        elsif($cfg eq "configure.gnu")
        {
          # force perl to install files it thinks are already installed
          # (5.8.2 and later support DESTDIR and should no longer need this)
          optpatch { s/^use File::Compare;$/sub compare(\$\$){1}; #$genby/ }
              path($dir, "installperl");
d3058 1
d3060 7
d3068 19
a3086 7
      my($amhelper) = path($dir, "install-sh");
      if(-l($amhelper) && !-r($amhelper)) # e.g. sgml-common/0.6.3
      {
        optcdrun($dir, "aclocal");
        optcdrun($dir, "automake", "-acf");
        optcdrun($dir, "autoconf", "-f");
      }
d3088 6
a3093 2
      cdrunconf($dir, @@confcmd);
      return $dir;
d3095 3
@


1.367
log
@fix spurious trailing // in some autofind URLs; add bug report
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.366 2004/12/06 04:34:01 zaphod Exp zaphod $;
d2185 1
a2185 1
    $url .= "/" unless basename(stripquery($url)) =~ /\.|\/$/; # e.g. atop
@


1.366
log
@improved --expand heuristic
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.365 2004/12/06 00:34:43 zaphod Exp zaphod $;
d2185 1
a2185 1
    $url .= "/" unless basename(stripquery($url)) =~ /\./; # e.g. atop
d6765 1
@


1.365
log
@added --nice
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.364 2004/12/05 23:42:41 zaphod Exp zaphod $;
d4964 1
a4964 1
              !($xform =~ s/\.tar\.gz$/.tar.bz2/ && $expansion{$xform});
@


1.364
log
@install openssl even with --nopreload
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.363 2004/12/05 06:45:04 zaphod Exp zaphod $;
d262 1
d708 1
a708 1
sub nice($)
d710 3
a712 1
  eval { setpriority(0, 0, min(getpriority(0, 0) + $_[0], 20)) };
d3737 1
a3737 1
    nice(10);
d6305 14
@


1.363
log
@try to fix obscure "can't find perl" error
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.362 2004/12/02 06:28:30 zaphod Exp zaphod $;
d3412 2
a3413 1
  my($man, $subdir, $netpbm, $usedestdir, $nodestdir, $cdrtools, $e2fsprogs);
d3421 1
d3435 1
@


1.362
log
@tweak filtering heuristics; add bug report
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.361 2004/11/08 05:01:07 zaphod Exp zaphod $;
d1373 1
d1379 5
a1383 1
      return $path if -x($path);
d1386 10
a1395 1
  return abspath($^X);
@


1.361
log
@fix bug tickled by e.g. openssl when last cp argument is a directory
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.360 2004/11/07 06:25:00 zaphod Exp zaphod $;
d152 1
a152 1
sub stripext($) { my($arg) = @@_; $arg =~ s/(\.tar)?(\.[a-z]\w*)?$//i; $arg; }
d2123 1
a2123 2
  return false if $noquery =~
      m!\.(html?|php|txt|gif|jpg|png|css|asc|sum|sig|sign|lsm)$!i;
d6730 1
@


1.360
log
@fixed a bug that prevented toast disarm from running postarmprog
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.359 2004/11/07 05:38:21 zaphod Exp zaphod $;
d2574 2
@


1.359
log
@fixed a bug in the way the toast distribution tarball was being generated
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.358 2004/11/07 05:15:03 zaphod Exp zaphod $;
d4131 1
@


1.358
log
@fixed a couple of minor glitches in package URL location heuristics
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.357 2004/10/30 05:59:20 zaphod Exp zaphod $;
d5367 1
a5367 1
  my($pad) = "\x00" x ($size ? 512 - ($size % 512) : 0);
@


1.357
log
@added --confappend by popular demand; corrected bug list
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.356 2004/10/28 05:18:16 zaphod Exp zaphod $;
d2124 1
a2124 1
      m!\.(html?|php|txt|gif|jpg|png|css|asc|sum|sig|lsm)$!i;
d2165 1
a2165 1
    $redirhead =~ /^Location: ([^\r\n]+)/m ||
@


1.356
log
@fixed a bug that caused toast build to arm things for no apparent reason
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.355 2004/10/11 06:21:36 zaphod Exp zaphod $;
d267 1
d2965 21
d3079 1
a3079 1
      cdrun($dir, @@confcmd);
d3089 1
a3089 1
        cdrun($bubuilddir, "../dist/configure", "--prefix=$prefix");
d3122 1
a3122 1
    cdrun($dir, "xmkmf");
d3128 1
a3128 1
  return $dir if -r($mfpl) && cdrun($dir, "perl", $mfpl);
d3132 1
a3132 1
  return $dir if -r($pmkfile) && cdrun($dir, "pmk");
d3136 1
a3136 1
  return $dir if scalar(@@profiles) == 1 && cdrun($dir, "qmake", $profiles[0]);
d3191 1
a3191 1
    cdrun($makedir, qw(sh ../configure), sort(keys(%confopts)));
d6325 11
a6726 2
  - if x/1 is armed and x/2 is built, "toast rebuild x" also arms x/2
  - "toast build" arms newly built packages for no apparent reason
@


1.355
log
@fixed a bug that prevented building version 0 of a package
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.354 2004/10/04 05:16:04 zaphod Exp zaphod $;
d2086 1
a2086 1
  };
@


1.354
log
@some concessions to glibc 2.3.3
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.353 2004/10/03 04:03:07 zaphod Exp zaphod $;
d3665 2
a3666 2
  $name || error;
  $version || error;
@


1.353
log
@improve --expand heuristics
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.352 2004/10/02 22:58:58 zaphod Exp zaphod $;
d3130 1
a3130 1
    if(-x($cfg))
d3162 8
a3169 4
    my(@@confcmd) = ("../configure", "--prefix=$prefix");
    push(@@confcmd, "--enable-add-ons") if @@addons;
    push(@@confcmd, "--with-headers=$hdrdir/include") if $hdrdir;
    cdrun($makedir, @@confcmd);
@


1.352
log
@account properly for case where etc/xml doesn't exist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.351 2004/10/01 04:51:30 zaphod Exp zaphod $;
d2122 2
a2123 1
  return false if $noquery =~ m!\.(html?|php|txt|gif|jpg|png|css|asc|sum)$!i;
d4889 4
a4892 2
            # filter out likely symlinks, e.g. LVM2.0-stable.tgz
            my(@@filtered) = grep(!/\b(latest|stable)\b/i, @@expansion);
@


1.351
log
@force gtk+ to install more completely
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.350 2004/09/28 05:55:31 zaphod Exp zaphod $;
d3908 1
a3908 1
    @@subcats = grep(m!/catalog[^/]*$!, absls(path(armdir, qw(etc xml))));
@


1.350
log
@try to accomodate packages that update /etc/xml/catalog, like libglade
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.349 2004/09/27 03:32:38 zaphod Exp zaphod $;
d3392 2
@


1.349
log
@merge sbin into bin
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.348 2004/09/26 22:09:23 zaphod Exp zaphod $;
d1412 1
a1412 1
  my($x) = path(qw(etc xml catalog));
d2921 3
a2923 4
      foreach (qw[mkdir rmdir touch cp rm ln install chmod test ranlib gzip],
      "[");
  helprewrite($srcdir, $rootdir, $helperdir, $_, true)
      foreach (qw[mv]);
a3897 2
  return true unless xmlcatalog;

d3901 2
a3902 2
  my($master) = path($xmldir, "catalog");
  return true if -l($master);
d3904 12
a3915 9
  my(@@subcats);
  my($dir) = path($armdir, qw[share xml]);
  dfs
  (
    $dir,
    sub { true },
    sub { push(@@subcats, $_) if m!/catalog.xml$!; true },
    sub { true },
  ) if -d($dir);
d3917 1
a3917 1
  return -e($master) ? rm($master) : true unless @@subcats;
d6527 6
a6532 6
When B<infodir> is enabled, B<toast arm> and B<toast disarm> will create a
file in B<armdir> called C<info/dir>; if the file already exists, it will
be replaced with an updated version.  The "info" command uses this file to
display a list of installed info pages.  This is normally the only regular
file in B<armdir>; all the other files are symbolic links.  If B<infodir>
is disabled, B<toast arm> and B<toast disarm> will delete the C<info/dir>
d6538 9
a6546 11
maintain a catalog file in B<armdir> called C<etc/xml/catalog>, whose
presence and contents depend on the contents of B<armdir>'s C<share/xml>
subdirectory.  If the catalog already exists, it may be overwritten
or deleted.  It may be convenient to refer to this catalog from the real
master XML catalog file (outside of B<armdir>), in order to allow programs
to locate XML DTDs, XSL style sheets, and perhaps other XMLish things
in B<armdir>.  This is most likely to come up in the context of DocBook.
If B<xmlcatalog> is disabled, B<toast arm> and B<toast disarm> will not
create an XML catalog and will ignore any existing catalog.  Note that
this option is implicitly disabled if any package installed in B<armdir>
itself provides an C<etc/xml/catalog> file.  Default: enabled.
a6690 1
  - simpler setup for root: auto-create toast user? (email 7/21/04)
@


1.348
log
@goad mozilla into building without gtk1
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.347 2004/09/26 05:40:25 zaphod Exp zaphod $;
d1415 1
a1415 1
  push(@@vars, newenvvar("PATH", "sbin:bin"));
d3401 1
a3401 1
      (qw[bin boot etc include info lib libexec man sbin share src var],
d3415 1
d6074 8
a6081 8
add C<I<armdir>/sbin> and C<I<armdir>/bin> to the front of C<PATH>, unless
either directory already appears anywhere in C<PATH>, in which case that
directory will be left in its current position instead of being moved to
the front.  Other environment variables are similarly affected: C<MANPATH>
(used to find man pages), C<INFOPATH> (used by GNU info), C<CPATH> (used
by gcc to find include files), C<XML_CATALOG_FILES> (used by DocBook and
other tools to locate XML catalogs), and C<LIBRARY_PATH> (used by GNU ld
to find libraries; not to be confused with C<LD_LIBRARY_PATH>, which also
@


1.347
log
@munge modern docbook-xml catalog to placate GNOME
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.346 2004/09/25 23:55:10 zaphod Exp zaphod $;
d2981 1
d3008 1
d3021 5
@


1.346
log
@try to do something about docbook
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.345 2004/09/22 04:27:51 zaphod Exp zaphod $;
d3450 2
a3451 2
    my($name, $version);
    whilefile
d3454 4
a3457 1
      !$version;
@


1.345
log
@make --expand more selective
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.344 2004/09/19 01:29:00 zaphod Exp zaphod $;
d290 1
d1385 1
a1385 1
sub newenvvar($$;$)
d1387 3
a1389 2
  my($varname, $subdirs, $default) = @@_;
  my(@@dirs) = map(path(armdir, $_), split(/:/, $subdirs));
d1395 1
a1395 1
    $have{$_} = 1 for split(/:/, $current);
d1400 1
a1400 1
  return($varname, join(":", @@dirs));
d1412 1
d1417 1
a1417 1
  push(@@vars, newenvvar("INFOPATH", "info", ""));
d1420 1
d3432 48
d3603 3
a3605 1
  compilebin($srcdir, $rootdir) || compilehelp($srcdir, $rootdir, $helperdir);
d3886 44
d3998 1
d4090 1
d6068 3
a6070 2
by gcc to find include files), and C<LIBRARY_PATH> (used by GNU ld to
find libraries; not to be confused with C<LD_LIBRARY_PATH>, which also
d6514 1
a6514 1
=item S<B<--infodir> | B<noinfodir>>
d6524 15
@


1.344
log
@reconfigure now enables shared libraries for ncurses
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.343 2004/09/18 21:33:36 zaphod Exp zaphod $;
d2118 1
a2118 1
  return false if $noquery =~ m!\.(html?|php|txt|gif|jpg|png|css)$!i;
d4775 4
@


1.343
log
@added fallbackuid
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.342 2004/09/05 22:03:00 zaphod Exp zaphod $;
d3004 4
a3007 1
          for $opt (qw[enable-add-ons enable-shared disable-multiplatform])
@


1.342
log
@added --expand (on by default)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.341 2004/09/05 01:54:59 zaphod Exp zaphod $;
d261 1
d1314 1
a1314 1
sub getuidgid()
d1316 49
a1364 18
  my($username) = username;
  my($name, $passwd, $uid, $gid) = getpwnam($username);
  error("getpwnam $username: $!") unless defined($name);
  return ($uid, $gid);
}

sub dropprivs()
{
  return unless superuser;
  my($username) = username;
  explain("running as user $username");
  my($uid, $gid) = getuidgid;
  $uid || error("refusing to run as root");
  $( = $gid;
  $) = "$gid $gid";
  ($<, $>) = ($uid, $uid);
  $> == $< || error("real and effective UIDs do not match");
  $> == $uid || error("uid is not set correctly");
d3608 1
a3608 6
  if(superuser)
  {
    my($uid, $gid) = getuidgid;
    announce("chown", username, $builddir);
    chown($uid, $gid, $builddir) || error("chown $uid:$gid $builddir: $!");
  }
d4255 1
a4255 7
  if(superuser)
  {
    my($uid, $gid) = getuidgid;
    announce("chown", username, $olddir, $newdir);
    chown($uid, $gid, $olddir, $newdir) ||
        error("chown $uid:$gid $olddir $newdir: $!");
  }
d6125 8
@


1.341
log
@build Xaw3d
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.340 2004/09/05 01:03:40 zaphod Exp zaphod $;
d135 13
d267 1
d1036 1
a1036 1
  return @@links;
d2082 1
a2082 1
  return false unless $url =~ m!^(http|ftp)://!;
d2086 1
a2086 1
  return false if $noquery =~ m!\.(html?|php)$!i;
d4691 1
d4693 1
a4693 1
  while(@@_)
d4695 1
a4695 1
    local($_) = shift;
d4707 2
a4708 2
        @@_ || error("expected file or URL after \"$_\"");
        $_ = shift;
d4729 2
a4730 2
          ($multi && @@_) || error("expected file after \"[\"");
          $_ = shift;
d4746 42
d4798 2
a4799 2
          @@_ || error("expected \"]\" after \"$_\"");
          $_ = shift;
d4815 4
a4818 1
  print("parsed ", scalar(@@_), " argument(s)\n");
d4820 1
a4820 1
  for(parse(@@_))
d4823 1
a4823 1
    print("argument ", ++$index, ":\n");
d6152 18
@


1.340
log
@bug report
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.339 2004/08/29 21:33:52 zaphod Exp zaphod $;
d3027 16
a3042 1
  return $dir if -r($imf) && cdrun($dir, "xmkmf");
d3382 1
d6444 1
@


1.339
log
@relax path checking (fixes bug when $HOME is /)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.338 2004/08/28 22:56:42 zaphod Exp zaphod $;
d6427 1
@


1.338
log
@try to install VMware from tarball
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.337 2004/07/25 23:53:17 zaphod Exp zaphod $;
d144 19
a162 5
  defined($_) || error("undefined path component in @@_") foreach @@_;
  local($_) = join("/", @@_);
  m|//| && error("double slash in path(@@_): $_");
  m|/$| && error("final slash in path(@@_): $_");
  $_;
d322 1
a322 1
    push(@@list, path($ENV{HOME}, qw[.toast conf]))
@


1.337
log
@added built-in gunzip
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.336 2004/07/19 03:52:38 zaphod Exp zaphod $;
d3120 1
a3120 1
  for(qw[install.sh INSTALL install.pl])
d3133 1
d3314 1
@


1.336
log
@invoke install-info on the correct set of files when arming/disarming
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.335 2004/07/18 22:56:16 zaphod Exp zaphod $;
d1575 189
d1780 1
a1780 1
    open(STDIN, "$prog |") || error("$prog: $!");
d5691 14
a5704 15
Building may involve implicitly invoking B<toast get>, decompressing
and extracting archives, applying patch files, compiling a new build
of the package and installing it in a build-specific directory tree.
Supported archive formats include compress, gzip, bzip2, zip, rpm,
deb, cpio, tar, shar, patch, and most combinations of the above.
You don't need to have RPM installed to extract .rpm files; gunzip and
cpio usually suffice.  Similarly, only gunzip and tar should be required
to extract .deb files.  Note that toast completely ignores dependencies
and other meta-information in .rpm and .deb files; only the raw binaries
are extracted and used.  Archives should contain either precompiled
binaries or source code, which will be identified and/or built according
to heuristics too mind-numbing to describe completely; in the case of
source files, a C<configure> script, C<Makefile> or similar is often
required.  Many options can influence this command's behavior; see the
options reference for full details.
d6418 2
@


1.335
log
@--noprotect now prevents toast build from creating read-only directories;
made --noprotect the new default
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.334 2004/07/18 20:20:18 zaphod Exp zaphod $;
d3556 1
a3556 1
      return true if !m!(/dir|\Q$tmpsuffix\E|\Q$offsuffix\E|-\d+(\.info)?)$!;
a6210 1
  - info pages with .off suffix are being included in info/dir
@


1.334
log
@fixed "permission denied" bug when arming/disarming overlapping packages
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.333 2004/07/12 04:07:33 zaphod Exp zaphod $;
d261 1
a261 1
    "protect" => "true",
d3240 1
a3240 1
    sub { $count{$_} < $total ? safechmod(0555, $_) : rd($_) }
d6091 6
a6096 3
If B<protect> is enabled, B<toast arm> will attempt to ensure that
B<armdir> and its subdirectories are read-only, changing existing modes
if necessary.  If B<protect> is disabled, B<toast arm> will make B<armdir>
d6099 1
a6099 1
Default: enabled.
@


1.333
log
@toast wasn't reading /etc/toast.conf as promised by setup instructions;
updated code and docs to look for configuration file in various places;
cleaned up code to get rid of a few unnecessary calls to setopt()
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.332 2004/07/10 21:08:02 zaphod Exp zaphod $;
d3626 1
a3626 1
      my($target) = displace(optpath(armdir, $_[0]));
d3628 1
@


1.332
log
@default to configure --disable-multiplatform when building tetex
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.331 2004/07/10 18:33:20 zaphod Exp zaphod $;
d305 10
d321 2
a322 4
    return unless $ENV{HOME};
    my($dotfile) = "$ENV{HOME}/.$myname/conf";
    $dotfile = "/etc/toast.conf" unless -e($dotfile);
    return unless -e($dotfile);
d394 1
a394 1
sub explain(@@)
d396 3
a398 1
  print("# @@_\n") unless quiet;
d401 2
a402 4
sub announce(@@)
{
  print("@@_\n") unless quiet;
}
d3357 1
a3357 1
    setopt("quiet", false);
d3388 1
a3388 1
    print("  $_\n") unless quiet;
d4823 1
a4823 1
  setopt("quiet", false);
d6151 15
a6165 13
The configuration file.  If option I<NAME> has not been assigned
a value through any of the above methods, its value will be taken
from a line of the form I<NAME>B<=>I<VALUE>, if such a line exists, in
C<I<$HOME>/.toast/conf>, if that file exists.  (C<I<$HOME>> specifically
represents the value of the C<HOME> environment variable.)  I<NAME>
is case-insensitive in this context.  Any whitespace before or after
I<NAME> or I<VALUE> will be ignored, as will any blank line, any
line containing only whitespace, and any line with B<#> as its first
non-whitespace character.  If the file exists but cannot be read or has
invalid syntax, an invalid I<NAME>, or an illegal I<VALUE> for a boolean
option (an explicit value must be given; see item 1 for allowed forms),
B<toast> will normally give an error message at startup and refuse to
execute any commands.
@


1.331
log
@toast arm/disarm now keep rebuilding info index when install-info fails
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.330 2004/06/01 01:01:08 zaphod Exp zaphod $;
d2746 2
a2747 2
          my($opt); # glibc; libjpeg; others?
          for $opt (qw[--enable-add-ons --enable-shared])
d2749 1
a2749 1
            $confopts{$opt} ||= / \Q$opt\E\b($|[^-])/;
d6197 1
a6216 1
  - default to --disable-multiplatform for tetex? (email 5/26/04)
@


1.330
log
@work around bug in sgml-common/0.6.3 (and perhaps others?)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.329 2004/05/24 00:04:39 zaphod Exp zaphod $;
d3551 1
a6196 1
  - info/dir isn't being completely rebuilt correctly
@


1.329
log
@try /etc/toast.conf if $HOME/.toast/conf doesn't exist; update buglist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.328 2004/05/06 21:16:32 zaphod Exp zaphod $;
d2778 8
d6216 1
@


1.328
log
@rewrite execve() during install (required by teTeX); update buglist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.327 2004/05/04 21:40:10 zaphod Exp zaphod $;
d313 1
d5407 1
a5407 2
file in root's home directory specifying an alternate username (C<fred>
in this example) by running the following command as root:
d5409 1
a5409 1
  mkdir ~/.toast && echo 'username=fred' > ~/.toast/conf
d5412 2
a5413 2
now would be a good time to specify those as well, since changing them
later is very tedious:
d5415 2
a5416 3
  mkdir -p ~/.toast
  echo 'storedir=/path/to/use/to/store/files'
  echo 'armdir=/place/to/put/symlinks/to/armed/packages'
d5418 1
a5418 1
Once the C<toast> user and/or C<~/.toast/conf> configuration file has
d5422 3
a5424 3
B<toast env> stuff described above, but when using another location, you
may wish to put some variation on the B<toast env> command given above
in C</etc/profile> or something.
d6201 1
a6201 1
  - build fails for: jikes, sirc, netcat, lcab, gv, bittorrent
d6208 1
@


1.327
log
@build shared OpenSSL libraries unless --noreconfigure is given
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.326 2004/05/04 20:03:03 zaphod Exp zaphod $;
d2523 1
d6189 2
a6190 1
  - autofind produces URLs with extra slashes, e.g. "toast arm flex" (?)
d6205 1
@


1.326
log
@don't run configure script if it's a directory (e.g. Opera 7.50);
don't put DESTDIR on command line if it points to foo/bin (e.g. figlet)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.325 2004/04/25 05:03:59 zaphod Exp zaphod $;
d2720 9
@


1.325
log
@skip unneeded chmods to avoid spurious errors
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.324 2004/04/25 00:50:13 zaphod Exp zaphod $;
d2711 1
a2711 1
    if(-x($confprog))
d3056 1
a3056 1
  my(@@trace, $man, $subdir, $netpbm, $usedestdir, $cdrtools, $e2fsprogs);
d3065 1
d3072 1
d3083 1
a3083 1
  push(@@targets, "DESTDIR=$rootdir") if $usedestdir;
d6197 1
@


1.324
log
@added autoenv option; update PWD variable when changing directories;
run "env" to log environment if "printenv" fails
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.323 2004/04/24 22:37:06 zaphod Exp zaphod $;
a512 6
sub optln($$)
{
  my($source, $target) = @@_;
  ln($source, $target) unless -e($target) || -l($target);
}

a662 1
sub optrm(@@) { rm(grep(-e || -l, @@_)) }
d692 2
a693 2
  my($code) = $? & 0xff;
  my($sig) = ($? >> 8) & 0xff;
d3236 9
a3244 2
    safechmod(0777, $libdir) if %liblinks;
    optln($liblinks{$_}, path($libdir, $_)) for sort(keys(%liblinks));
a3450 13
sub replace($)
{
  my($on) = @@_;
  rm($on);
  my($off);
  while(-e($off = addoff($on)))
  {
    mv($off, $on);
    $on = $off;
  }
  true;
}

a3505 1
  safechmod(0777, $dir);
d3509 5
a3513 1
    optrm($dirfile);
d3518 5
a3522 1
    optrm($tmpfile);
d3527 3
a3529 2
      m!(/dir|\Q$tmpsuffix\E|\Q$offsuffix\E|-\d+(\.info)?)$! or
          optrun("install-info", $_, $tmpfile);
a3536 10
sub postarm(;$$)
{
  my($armdir, $postarmprog) = @@_;
  $armdir = armdir unless defined($armdir);
  $postarmprog = postarmprog unless defined($postarmprog);
  rebuildinfodir($armdir);
  run($postarmprog) if $postarmprog;
  return true;
}

d3569 1
a3569 1
        safechmod(755, $parent);
d3587 6
a3592 2
      optmd($dir);
      safechmod(0777, $dir);
d3597 1
d3603 2
a3604 1
  postarm;
d3629 1
a3629 1
  my($i, $armdir);
d3633 1
a3650 1
            safechmod(0777, $armsubdir);
d3657 1
a3657 1
          my($armfile) = path($armdir, $rel); # BUG: $rel is sometimes undef?
d3660 12
a3671 1
            return replace($armfile) if optsamefile($armfile, $_);
d3683 3
a3685 1
            isempty($armsubdir) ? rd($armsubdir) : safechmod($mode, $armsubdir);
d3694 2
a3695 1
    postarm($armdir, ++$i == scalar(@@armdirs) ? postarmprog : "");
d6191 1
a6191 1
  - toast disarm fails spuriously whenever an altarmdir isn't writable
@


1.323
log
@improved guessing of package names and versions from URLs
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.322 2004/04/24 22:16:57 zaphod Exp zaphod $;
d243 1
d732 1
a732 1
    chdir($dir) || error("chdir $dir: $!");
d1049 8
d1322 66
d1405 1
a1405 1
  optrun("printenv");
d1615 1
a1615 1
    chdir($outdir) || error("chdir $outdir: $!");
d3333 1
a4162 43
sub printenvcmd($$;$)
{
  my($varname, $subdirs, $default) = @@_;
  my(@@dirs) = map(path(armdir, $_), split(/:/, $subdirs));
  my($exists) = exists($ENV{$varname});
  my($current) = $exists ? $ENV{$varname} : $default;
  my($export) = $exists ? "" : " export $varname;";

  if(defined($current))
  {
    my(%have);
    $have{$_} = 1 for split(/:/, $current);
    @@dirs = grep(!$have{$_}, @@dirs);
  }

  push(@@dirs, $current) if defined($current);
  print("$varname=" . shellescape(join(":", @@dirs)) . ";$export\n");
}

sub env(@@)
{
  @@_ && error;

  my($defaultman) = "/usr/man:/usr/share/man:/usr/local/man:/usr/X11R6/man";
  if(!exists($ENV{MANPATH})) # don't bother unless we're going to use it...
  {
    my($out) = `man -w 2>/dev/null`;
    chomp($out) if defined($out);
    $defaultman = $out if defined($out) && $out =~ m!^/! && $out !~ /\n/;
  }

  printenvcmd("PATH", "sbin:bin");
  printenvcmd("MANPATH", "man", $defaultman);
  printenvcmd("INFOPATH", "info", "");
  printenvcmd("CPATH", "include");
  printenvcmd("LIBRARY_PATH", "lib");
  # there's also a LIBRARY_RUN_PATH or something that affects ld somehow...

  return true;
}

##############################################################################

d5876 7
a6189 1
  - automatically "toast env"-ify environment during "toast build"
@


1.322
log
@fixed openssl build problem
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.321 2004/04/24 22:04:04 zaphod Exp zaphod $;
d1219 3
a1221 1
      || $base =~ /([^-]+)-(.*\d.+)/                       # iputils-ss020124
a6132 1
  - toast guesses device/mapper-1.00.17 for device-mapper.1.00.17.tgz
@


1.321
log
@add dummy mknod helper for make install phase;
parse HTTP and proxy URLs with dashes in hostname correctly
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.320 2004/04/09 23:28:59 zaphod Exp zaphod $;
d2637 2
a2638 2
  #            autoconf  Perl          elm       pmk (bootstrap)
  for $cfg (qw[configure configure.gnu Configure pmkcfg.sh])
@


1.320
log
@fix DESTDIR issue building man 1.5m2
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.319 2004/04/09 21:31:37 zaphod Exp zaphod $;
d801 2
a802 1
  $url =~ m!^(\w+)://([\w\.]+)(:(\d+))?(/[\!-\~]*)?$! || error("bad url: $url");
d808 1
a808 1
    $proxy =~ m!^(\w+://)?([\w\.]+)(:(\d+))?([^:]+)(:(\d+))?/?$!
d2592 1
a2592 1
  helpnop($helperdir, $_) foreach (qw[chown chgrp ldconfig install-info]);
d6130 2
a6131 1
  - autofind produces URLs with extra slashes, e.g. "toast arm flex"
d6149 1
@


1.319
log
@add rudimentary qmake support
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.318 2004/04/09 21:25:40 zaphod Exp zaphod $;
d506 6
d518 1
a518 1
sub relln($$)
d520 2
a521 2
  my($src, $target) = @@_;
  ln($src =~ m|^/| ? findrelpath(dirname($target), $src) : $src, $target);
d3055 2
a3056 1
  optln(".", path($rootdir, $_)) foreach (unpath($armdir), unpath($rootdir));
a6128 1
  - "toast arm man" fails due to incorrect DESTDIR symlinks
@


1.318
log
@pretend to support pmk; add new bug reports to list
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.317 2004/04/08 20:57:16 zaphod Exp zaphod $;
d2730 4
@


1.317
log
@add chgrp to list of commands to be ignored during install phase
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.316 2004/04/05 06:27:45 zaphod Exp zaphod $;
d2630 2
a2631 2
  #            usual     Perl          elm
  for $cfg (qw[configure configure.gnu Configure])
d2726 4
d6118 2
@


1.316
log
@skip CVS subdir when finding build directory;
build linux/autoconf.h with glibc
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.315 2004/04/02 22:10:13 zaphod Exp zaphod $;
d2585 1
a2585 1
  helpnop($helperdir, $_) foreach (qw[chown ldconfig install-info]);
@


1.315
log
@built-in FTP was spuriously rejecting hostnames with dashes in them;
explicit "toast get" would re-get stored packages, then become confused
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.314 2004/03/31 00:40:43 zaphod Exp zaphod $;
d2136 9
a2144 1
  my($ok) = abswhiledir { -d && !defined($subdir) && ($subdir = $_) } $dir;
d2765 2
a2766 1
        "install:\n\t\$(MAKE) -C $emdir install\n";
@


1.314
log
@added --nopreload
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.313 2004/03/25 00:51:15 zaphod Exp zaphod $;
d860 2
a861 1
  $url =~ m!^(\w+)://([\w\.]+)(:(\d+))?(/[\!-\~]*)?$! || error("bad url: $url");
d2083 2
@


1.313
log
@use gunzip/bunzip2 rather than gzip/bzip2 -cd to decompress; record new bug
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.312 2004/03/25 00:26:43 zaphod Exp zaphod $;
d251 1
d2250 2
d5881 11
d5894 7
a5900 7
When B<strictpreload> is enabled, B<toast build> will fail unless it
can successfully compile a shared library for use with C<LD_PRELOAD>
during the C<make install> phase.  If B<strictpreload> is disabled,
B<toast build> still tries to build and use the shared library, but will
do the best it can otherwise.  This may allow B<toast build> to succeed
in the absence of a suitable C compiler, but it may allow some packages
to build incorrectly in some situations.  Default: enabled.
@


1.312
log
@toast's own Makefile now deals gracefully with missing pod2man utility
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.311 2004/03/21 02:09:40 zaphod Exp zaphod $;
d1502 2
a1503 2
    my($prog) = $type eq ".bz2" ? "bzip2" : "gzip";
    open(STDIN, "$prog -cd |") || error("$prog: $!");
d1545 2
a1546 2
  ($cmd, $arg) = ($cmd . "gzip -cd $arg | ", "-") if s/\.gz$//i;
  ($cmd, $arg) = ($cmd . "bzip2 -cd $arg | ", "-") if s/\.bz2$//i;
d2943 1
a2943 1
    optrun("gzip -cd < " . shellescape($in) . " > " . shellescape($out))
d5407 2
a5408 2
You don't need to have RPM installed to extract .rpm files; gzip and
cpio usually suffice.  Similarly, only gzip and tar should be required
d6101 1
@


1.311
log
@improved handling of urls that end after the hostname (no trailing slash)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.310 2004/03/10 03:10:43 zaphod Exp zaphod $;
d4775 1
a4775 1
  $(POD2MAN) $(prog) > $(manpage) || rm $(manpage)
d4778 1
a4778 1
  ./$(prog) tarself < $(prog) > $(tarball) || rm $(tarball)
d4783 1
a4783 1
  $(CP) $(manpage) $(DESTDIR)$(man1dir)
@


1.310
log
@install libext2fs with e2fsprogs when reconfigure is enabled
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.309 2004/03/08 06:42:27 zaphod Exp zaphod $;
d970 3
a972 3
  $url =~ m!^(((\w+:)//[^/]+)[^\?]*/)([^/\?](\?|$))?!
      || error("bad url: $url");
  my($proto, $host, $parent) = ($3, $2, $1);
d1827 1
d4298 2
a4299 1
  $url =~ s!^(ftp://[^/:]+):21(/|$)!$1$2!; # wget emits redundant ftp port no.
@


1.309
log
@fix glibc install
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.308 2004/03/07 03:27:35 zaphod Exp zaphod $;
d2955 1
a2955 1
  my(@@trace, $man, $subdir, $netpbm, $usedestdir, $cdrtools);
d2971 1
d2977 1
d6098 1
@


1.308
log
@fix assertion failure under linux 2.6.x by robustifying readdir code
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.307 2004/03/06 22:10:11 zaphod Exp zaphod $;
d2711 1
a2711 1
  # Write a custom Makefile for glibc with linuxthreads and/or kernel headers.
d2750 1
a2750 1
        "install:\n\t\$(MAKE) -C $emdir\n";
d6084 1
@


1.307
log
@fix for compiling glibc with headers from linux 2.6
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.306 2004/03/06 06:43:10 zaphod Exp zaphod $;
d410 6
a415 3
  readdir(DIR) eq "." || error;
  readdir(DIR) eq ".." || error;
  while(defined($_ = readdir(DIR)) && &$sub($_)) { }
@


1.306
log
@group kernel headers with glibc rather than linux
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.305 2004/02/29 06:55:50 zaphod Exp zaphod $;
d2748 3
a2750 2
    $mftext .= "\t\(cd $ehdir && tar c include/linux include/asm/.) |" .
        " (cd \$(DESTDIR) && tar x)\n" if $ehdir;
@


1.305
log
@dispense with "returning failure (1)" message for each error;
optionally fetch default Linux kernel configuration from /proc
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.304 2004/02/27 00:15:37 zaphod Exp zaphod $;
a2549 1
(cd $makedir; tar cf - include/linux include/asm/.) | (cd $rootdir; tar xf -)
d2708 3
a2710 10
  # Terrible, terrible hack to allow glibc+linuxthreads to compile:
  # Look for a situation where we have multiple subdirectories, but no files,
  # and only one of the subdirectories contains an executable configure script
  # that actually does something.  If that happens, move the other directories
  # into the directory with the non-broken configure script and run that.
  # Otherwise one of the rules below will grab a Makefile from a random
  # subdirectory and try to use it, which doesn't work.
  my($newdir);
  my(@@addons);
  my($addonsok) = whiledir
d2715 6
d2725 2
a2726 2
      return false if $newdir;
      $newdir = $abs;
d2731 1
a2731 1
  if($addonsok && @@addons && $newdir)
d2733 25
a2757 2
    mv(path($dir, $_), path($newdir, $_)) foreach @@addons;
    return &configure($newdir, $prefix);
d6080 1
@


1.304
log
@work around an apparent parse bug in perl 5.6.1
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.303 2004/02/26 02:02:18 zaphod Exp zaphod $;
d2913 8
a4684 1
warning("$myname: returning failure ($result)") if $result != 0;
a6071 1
  - when building linux, default to using /proc/kconfig.gz if present?
@


1.303
log
@four very minor bugfixes (see diff)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.302 2004/02/25 06:47:25 zaphod Exp zaphod $;
d3490 1
a3490 1
  my($name, $version, $build) = @@_;
d3543 1
a3543 1
    } ($name, $version, $build);
d6090 1
@


1.302
log
@improved patch heuristic
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.301 2004/02/25 05:42:30 zaphod Exp zaphod $;
a749 1
  if(!open(HANDLE, "$prog @@args |"))
d751 6
a756 2
    explain("failed to exec $prog: $!");
    return false;
d1318 1
d1320 3
a1322 3
  my($verdir) = pkgpath($name, $version);
  my($archivedir) = path($verdir, archivedir);
  optrun("md5sum", absls($archivedir));
d4044 3
a4046 3
    my($out) = `man -w`;
    chomp($out);
    $defaultman = $out if $out =~ m!^/! && $out !~ /\n/;
d4337 1
a4337 1
        $nourls = false if -e;
a6061 4
  - "toast add foo/bar-1.2.tar.gz" guesses "foo version bar-1.2.tar.gz"
  - openprog() still emits redundant exec() warnings
  - toast build hangs in md5sum if a package has no archives or urls
  - in some environments, toast env spews warnings if MANPATH is unset
@


1.301
log
@1.300 erroneously claims builds made by earlier versions are "mismatched"
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.300 2004/02/25 05:32:38 zaphod Exp zaphod $;
d1434 8
d1487 2
a1488 1
  safeexec("patch", "-p0") if $type eq ".patch";
@


1.300
log
@toast build now records the armdir for which each build was built;
added --altarmdirs and --skipmismatched options;
toast status can now display additional information about armdirs;
fixed a number of minor bugs, including pesky boolean option parse bug
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.299 2004/02/21 20:57:20 zaphod Exp zaphod $;
a1738 1
  return true if $armdirisdir && !$linkisdir;
@


1.299
log
@made --relative more robust
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.298 2004/02/21 06:27:07 zaphod Exp zaphod $;
d232 1
d239 23
a261 22
    "quiet" => false,
    "autofind" => true,
    "autochange" => true,
    "autorename" => true,
    "autoclean" => true,
    "autopurge" => false,
    "autoarm" => true,
    "autodisarm" => true,
    "autodemolish" => true,
    "autoremove" => false,
    "crossversion" => false,
    "strictpreload" => true,
    "useflock" => $^O !~ /win/i,
    "reconfigure" => true,
    "fixliblinks" => true,
    "stoponerror" => true,
    "ignorecase" => true,
    "showurls" => true,
    "infodir" => true,
    "protect" => true,
    "relative" => false,
    "debugrewrite" => false,
d294 1
a294 1
    return defined($def) && ($def eq true || $def eq false);
d371 1
d1604 1
a1604 1
  for $build (allbuilds($name, $version, $build))
d1606 1
a1606 1
    return $build if isbuilt($name, $version, $build);
d1668 41
d1714 40
a1753 19
    my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
    my($armed) = -d($rootdir) && !dfs
    (
      $rootdir,
      sub { true },
      sub
      {
        my($rel) = @@_;
        my($armfile) = path(armdir, $rel);
        while(-e($armfile) || -l($armfile))
        {
          return false if optsamefile($_, $armfile);
          $armfile = addoff($armfile);
        }
        return true;
      },
      sub { true }
    );
    !$armed;
d3182 1
d3184 1
d3242 1
a3242 1
  arm($name, $version, $build) if autoarm && isarmed($name, $version);
d3249 11
a3259 1
      for $abuild (allbuilds($name, $aversion))
d3261 3
a3263 2
        demolish($name, $aversion, $abuild)
            if autodemolish && ($aversion ne $version || $abuild != $build);
a3264 1
      remove($name, $version) if autoremove && $aversion ne $version;
d3345 1
a3345 1
sub rebuildinfodir()
d3347 2
a3348 1
  my($dir) = path(armdir, "info");
d3385 1
a3385 1
sub postarm()
d3387 5
a3391 2
  rebuildinfodir;
  run(postarmprog) if postarmprog;
d3478 1
a3478 3
  my($name, $version, $build, @@urls) = @@_;

  lock(armdir);
d3480 16
a3495 13
  whilebuild
  {
    my($name, $version, $build) = @@_;
    my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
    my(@@dirmodes);
    -d($rootdir) && dfs  # ignore broken packages
    (
      $rootdir,
      sub
      {
        my($rel) = @@_;
        my($armdir) = optpath(armdir, $rel);
        if(-d($armdir) && !-l($armdir))
d3497 10
a3506 10
          push(@@dirmodes, getmode($armdir));
          safechmod(0777, $armdir);
        }
        return true;
      },
      sub
      {
        my($rel) = @@_;
        my($armfile) = path(armdir, $rel); # BUG: $rel is sometimes undefined?
        while(-e($armfile) || -l($armfile))
d3508 10
a3517 10
          return replace($armfile) if optsamefile($armfile, $_);
          $armfile = addoff($armfile);
        }
        return true;
      },
      sub
      {
        my($rel) = @@_;
        my($armdir) = optpath(armdir, $rel);
        if(-d($armdir) && !-l($armdir))
d3519 8
a3526 2
          my($mode) = pop(@@dirmodes);
          isempty($armdir) ? rd($armdir) : safechmod($mode, $armdir);
d3528 4
a3531 6
        return true;
      }
    );
    error if @@dirmodes;
    true;
  } @@_;
d3533 3
a3535 3
  postarm;

  unlock(armdir);
d3627 1
a3627 1
  if(isarmed($name, $version) && autoarm)
d3631 1
a3631 1
  elsif(isbuilt($name, $version))
a3672 17
sub verstatus($$)
{
  my($name, $version) = @@_;
  return "stored" if isstored($name, $version);
  return false;
}

sub buildstatus($$$)
{
  my($name, $version, $build) = @@_;
  return "broken" if isbroken($name, $version, $build);
  return "building" unless isbuilt($name, $version, $build);
  my($nc) = isclean($name, $version, $build) ? "" : " (not clean)";
  return "armed$nc" if isarmed($name, $version, $build);
  return "built$nc";
}

d3678 2
d3686 2
a3687 2
      my($vs) = verstatus($name, $version);
      print("  version $version", $vs ? ": $vs\n" : "\n");
d3704 44
a3747 2
        print("    build $build: ",
            buildstatus($name, $version, $build), "\n");
d5417 8
a5424 6
Deletes symlinks created by B<toast arm>.  This works by removing
symbolic links to the given build and replacing any links that had
been moved out of the way.  No error occurs if no such links exist.
If no build number is given, all C<armed> builds are disarmed.  If the
package version number is also omitted, all C<armed> builds belonging
to packages with the given name are disarmed.
d5657 11
d5801 5
a5805 5
When both B<autoremove> and B<crossversion> are enabled, B<toast build>
performs an implicit B<toast remove> on every other package with the
same name as the package containing a newly-created, non-broken build.
If B<crossversion> is disabled, this option has no effect.  Default:
disabled.
d5814 16
a6049 3
  - "toast --autoremove --crossversion upgrade toast" breaks everything
  - if x/1/1 is armed and x/1/2 is built, "toast arm x" does nothing
  - if x/1/1 is armed, "toast --noautodisarm rebuild x" arms then fails
d6052 2
@


1.298
log
@fixed Sleepycat/Berkeley db 4 (broken since 1.286);
messed around with toast get logic
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.297 2004/02/21 04:36:07 zaphod Exp zaphod $;
d1064 2
a1065 2
      my($pd, $pi) = safestat(path($dir, $_));
      return true unless "$pd $pi" eq $di;
@


1.297
log
@added --relative
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.296 2004/02/14 07:52:25 zaphod Exp zaphod $;
d1914 3
d2601 8
d2610 1
a2610 2
  # or a "dist" subdirectory (e.g. nvi)
  for(qw[source src dist])
a2698 6
  # Sleepycat DB appears to demand the following in Unix-like environments:
  my($dbbuilddir) = path($dir, "build_unix");
  my($dbconfprog) = path($dir, "dist", "configure");
  return $dbbuilddir if -d($dbbuilddir) && -x($dbconfprog) &&
      cdrun($dbbuilddir, "../dist/configure", "--prefix=$prefix");

a5897 1
  - Berkeley/Sleepycat DB is broken again
@


1.296
log
@toast env wasn't properly exporting MANPATH and INFOPATH
@
text
@d6 1
a6 1
# Copyright (C) 2003-2003 Jacques Frechet.                                   #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.295 2004/02/13 05:50:09 zaphod Exp zaphod $;
d258 1
d505 6
d1041 55
d3363 5
a3367 1
    sub { ln($_, displace(optpath(armdir, $_[0]))) },
d3422 1
a3422 2
          my($target) = readlink($armfile);
          return replace($armfile) if defined($target) && $target eq $_;
d5780 2
a5781 2
armdir and its subdirectories are read-only, changing existing modes if
necessary.  If B<protect> is disabled, B<toast arm> will make B<armdir>
d5784 16
d5894 1
@


1.295
log
@added toast env; updated/corrected setup docs
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.294 2004/02/11 02:38:10 zaphod Exp zaphod $;
a3833 1
    $export = "";
d5819 2
a5820 1
  - autofind fails for: sleepycat db, gcc, latex, gv, GNU arch (?), ogle
d5822 1
a5822 1
  - build fails for: jikes, sirc, netcat, lcab, gv
@


1.294
log
@recognize self-extracting .zip files; build j2sdk; tweak man page
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.293 2004/02/09 23:27:11 zaphod Exp zaphod $;
d731 1
a731 1
  return @@words;
d3824 44
d4320 1
d5062 5
a5066 4
To have the latest version of B<toast> download and install itself,
run one of the following commands.  The first requires GNU wget; the
second relies on the GET utility that comes with the LWP Perl module;
the third uses telnet.
d5072 42
a5113 19
If you ran one of the above commands as root, B<toast> should now be
installed in C</toast> with appropriate symlinks under C</usr/local>,
and you should be all set.  If you ran one of the command as a
non-root user, B<toast> will have installed itself and everything
it needs under C<I<$HOME>/.toast>, and you'll probably need to add
C<I<$HOME>/.toast/armed/bin> to your C<PATH> environment variable in
order to be able to use B<toast> and any other packages it installs.
For example, in a Bourne-like shell:

  PATH=$HOME/.toast/armed/bin:$PATH

If you would like to use any man pages, info pages, libraries or header
files installed by B<toast>, you may also want to adjust C<MANPATH>,
C<INFOPATH>, C<LD_LIBRARY_PATH>, or C<CFLAGS> as appropriate.  Note that
setting C<LD_LIBRARY_PATH> may have unintended consequences; for more
information, search the Web for C<LD_LIBRARY_PATH considered harmful>.
If your C compiler is gcc, you may be able to use the C<CPATH> environment
variable instead of messing with C<CFLAGS>; see the gcc documentation
for details.
d5319 20
d5827 1
a5830 2
  - optionally set CPATH, LIBRARY_PATH, LD_RUN_PATH, etc. during build
  - add a command to set PATH, MANPATH, INFOPATH, etc. in user's shell
@


1.293
log
@add support for building perl modules
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.292 2004/02/08 22:52:56 zaphod Exp zaphod $;
d1304 7
d1312 1
a1312 1
  return magicstring($buf);
d1437 1
d1443 2
a1444 1
    $? && error("extract subprocess returned $?");
a1448 1
    my($type) = magicfile($infile);
d2590 17
d2610 2
a2611 1
  # Makefile from glibc+linuxthreads if the above rule didn't come first
d2616 8
a2623 1
    sub { !/makefile/i || !/$^O|\bunix/i || !mv($_, path($dir, "Makefile")); },
d4947 1
a4947 1
toast - build and install programs from source
@


1.292
log
@fixed boolean option parsing bug introduced in 1.284; build hotplug
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.291 2004/02/05 07:32:24 zaphod Exp zaphod $;
d2548 4
a5716 1
  - "toast build" should be able to deal with perl modules
@


1.291
log
@added built-in FTP and FTP proxy support; fixed incomplete disarming bug
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.290 2004/02/05 00:04:15 zaphod Exp zaphod $;
d291 1
a291 1
    return !defined($def) || $def eq true;
d2779 1
@


1.290
log
@fixed spurious "url = ..." autofind error introduced in 1.288
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.289 2004/02/04 23:19:21 zaphod Exp zaphod $;
d236 2
a237 1
    "httpproxy" => $ENV{http_proxy} || "",
d757 1
a757 1
sub openhttp(*$;$)
d760 15
a774 1
  my($url, $method) = @@_;
d776 1
a776 1
  $url =~ m!^http://([\w\.]+)(:(\d+))?(/[\!-\~]*)?$! || error("bad url: $url");
d778 2
a779 1
  my($host, $port, $path) = ($1, $3 || 80, $4 || '/');
d781 1
a781 1
  if(httpproxy)
d783 3
a785 3
    $path = "http://$host:$port$path";
    httpproxy =~ m!^(http://)?([\w\.]+)(:(\d+))?([^:]+)(:(\d+))?/?$!
        || error("bad httpproxy: " . httpproxy);
a787 1
  my($ip) = gethostbyname($host) || error("gethostbyname $host: $!");
d791 1
a791 4
  socket(HANDLE, 2, 1, 0) || error("$!");
  connect(HANDLE, pack("Sna4x8", 2, $port, $ip)) ||
      error("connect $host:$port: $!");
  unbuffer(HANDLE);
d805 1
a805 1
sub openhttpurl(*$)
d808 2
a809 3
  my($url) = @@_;
  return true if openprog(*HANDLE, "GET", $url);
  openhttp(*HANDLE, $url);
d818 67
a909 7
sub openwgeturl(*$)
{
  local(*HANDLE) = shift;
  my($url) = @@_;
  openprog(*HANDLE, "wget", "-O-", $url);
}

d918 2
d922 2
a923 1
  openwgeturl(*HANDLE, $url) ||
d925 1
d3337 1
d5050 1
a5050 2
B<toast purge> to force them to be downloaded afresh.  B<toast get> has
rudimentary built-in support for C<file> and C<http> URLs.  If GNU B<wget>
d5053 3
a5055 1
B<GET> utility to fetch C<http> URLs, rather than using built-in HTTP.
d5057 1
a5057 1
URLs of the form C<ssh:/[username@@]hostname/absolute/path/to/file>.
d5382 14
a5395 6
HTTP, the proxy URL should be of the form C<I<hostname>:I<port>>
or C<http://I<hostname>:I<port>/>.  Note that using an empty URL will
not cause C<http_proxy> to be removed from the environment of B<wget>
or B<GET>.  The proxy string is not exported during B<toast build>.
Default: the current value of the C<http_proxy> environment variable,
or the empty string if that variable is not set.
a5723 1
  - built-in FTP?
@


1.289
log
@spurious shell escapes were preventing wget fallback from working
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.288 2004/02/04 06:06:21 zaphod Exp zaphod $;
a1608 1
error("url = $url");
@


1.288
log
@fixed URL unescaping/quoting bugs; tweaked autofind
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.287 2004/02/04 01:34:44 zaphod Exp zaphod $;
d727 2
a728 2
    next unless m![^0-9a-z\+,\./:\@@_-]!;
    /'/ ? s!([^0-9a-z\+,\./:\@@_-])!\\$1!g : ($_ = "'$_'");
@


1.287
log
@maybe nvi will actually build now!
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.286 2004/02/04 00:38:50 zaphod Exp zaphod $;
d721 12
d738 1
d890 1
d1556 1
a1556 1
  return false if $noquery =~ m!\.html?$!i;
d1609 1
a5602 1
  - openprog() quoting and HTML unescaping bugs: "toast arm tinyproxy"
@


1.286
log
@inadequately tested support for building nvi
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.285 2004/02/04 00:16:42 zaphod Exp zaphod $;
d2374 2
a2375 2
  #            usual     Perl          elm       nvi
  for $cfg (qw[configure configure.gnu Configure dist/configure])
d2440 2
a2441 1
  for(qw[source src])
@


1.285
log
@try to build elm; updated buglist/wishlist
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.284 2004/02/02 05:24:05 zaphod Exp zaphod $;
d2374 2
a2375 1
  for $cfg (qw[configure configure.gnu Configure])
@


1.284
log
@added --httpproxy option
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.283 2004/02/02 01:45:56 zaphod Exp zaphod $;
d2374 1
a2374 1
  for $cfg (qw[configure configure.gnu])
d2396 2
d5586 2
d5624 1
@


1.283
log
@try using LWP's GET for http if wget fails; updated docs
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.282 2004/02/02 01:11:05 zaphod Exp zaphod $;
d236 1
d288 3
a290 1
    return isopt($name) && isboolean($optdefault{$name});
d751 8
d761 1
a761 1
  my($request) = "$method $path HTTP/1.0\r\nHost: $host\r\n".
d833 1
d5281 13
@


1.282
log
@possible fix for SunOS/sparc/gcc2 __eprintf problem
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.281 2004/02/02 00:30:43 zaphod Exp zaphod $;
d773 1
d4864 6
a4869 6
Linux, FreeBSD and Cygwin, without relying on the presence or absence
of any Perl modules or other tools.  Perl is available for download at
C<http://www.cpan.org/src/stable.tar.gz>.  Although it isn't required,
B<toast get> works better if you have GNU wget; use C<toast arm wget>
to download and install it if necessary.  Additional requirements for
B<toast build> vary according to the package being built.
d4944 7
a4950 6
B<toast purge> to force them to be downloaded afresh.  B<toast get>
has rudimentary built-in support for C<file> and C<http> URLs.
If GNU B<wget> is installed, B<toast get> will use it to fetch
C<http>, C<https>, and C<ftp> URLs.  If B<ssh> is available,
B<toast get> can use it to fetch (non-standard) URLs of the form
C<ssh:/[username@@]hostname/absolute/path/to/file>.
@


1.281
log
@second attempt at SunOS utimes() fix
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.280 2004/02/02 00:14:15 zaphod Exp zaphod $;
a1999 1
#include <assert.h>
a2213 2
  assert(next_$name);

@


1.280
log
@update copyright date and wishlist; first attempt at SunOS utimes() fix
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.279 2004/01/29 03:38:25 zaphod Exp zaphod $;
d2176 1
a2176 1
    wrap int utimes(const char *pathname, struct timeval *tvp);
@


1.279
log
@suppress spurious exec warnings; clarify install-info warning;
related cleanups/fixes; add bug to bug list
@
text
@d6 1
a6 1
# Copyright (C) 2003 Jacques Frechet.                                        #
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.278 2004/01/18 07:19:26 zaphod Exp zaphod $;
d46 1
a46 1
my($mycopyright) = "Copyright (C) 2003 Jacques Frechet";
d2016 2
d2176 1
a2176 1
    wrap int utimes(const char *pathname, void *foo);
d5575 3
d5591 2
d5631 1
a5631 1
This manual is part of B<toast>.  Copyright (C) 2003 Jacques Frechet.
@


1.278
log
@rudimentary .deb support
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.277 2004/01/16 23:59:32 zaphod Exp zaphod $;
d654 10
d668 6
a673 2
  my($result) = system(@@prog);
  return "exec @@prog: $!" unless defined($result);
d690 1
a690 1
  explain($msg) if defined($msg);
d708 1
a708 1
    exec(@@prog) || error("exec @@prog: $!");
d1302 4
a1305 4
  exec("tar", "xf", "-") || error("tar: $!") if $type eq ".tar";
  exec("cpio", "-di") || error("cpio: $!") if $type eq ".cpio";
  exec("/bin/sh") || error("/bin/sh: $!") if $type eq ".shar";
  exec("patch", "-p0") || error("patch: $!") if $type eq ".patch";
d1339 1
a1339 1
    exec("unzip", "-qo", $infile) || error("unzip: $!") if $type eq ".zip";
d5569 1
@


1.277
log
@suppress warning if PWD env var is unset;
--nostrictpreload works better now
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.276 2004/01/15 19:39:47 zaphod Exp zaphod $;
d1171 1
d1266 18
d1294 1
d1552 1
a1552 1
    $redirurl ||= $fmurl{$_} for qw(bz2 tgz zip rpm homepage);
d1574 1
a1574 1
    for $ext qw[.tar.bz2 .tar.gz .tgz .zip .rpm]
d1734 1
a1734 1
      for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .rpm])
d4947 12
a4958 9
Supported archive formats include compress, gzip, bzip2, zip, rpm, cpio,
tar, shar, patch, and most combinations of the above.  You don't need to
have RPM installed to extract .rpm files; gzip and cpio usually suffice.
Archives should contain either precompiled binaries or source code, which
will be identified and/or built according to heuristics too mind-numbing
to describe completely; in the case of source files, a C<configure>
script, C<Makefile> or similar is often required.  Many options can
influence this command's behavior; see the options reference for full
details.
@


1.276
log
@doxygen
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.275 2003/12/29 00:19:07 zaphod Exp zaphod $;
d887 1
a887 1
    return $pwd = $env if -d($env) && samefile($env, ".");
d2223 3
d2228 1
a2228 1
  cdrun($helperdir, @@socc, qw[dummy.c -o rewrite.so]);
d2230 3
a2232 3
  push(@@socc, qw[-Werror]) if strictpreload;
  push(@@socc, qw[rewrite.c -o rewrite.so.helper]);
  push(@@socc, "-ldl") if $^O =~ /linux/i;
d2234 3
a2236 10
  writefile(path($helperdir, "rewrite.c"), $code);
  if(optcdrun($helperdir, @@socc))
  {
    return path($helperdir, "rewrite.so");
  }
  else
  {
    error("unable to compile rewrite.so") if strictpreload;
    return undef;
  }
@


1.275
log
@uClibc
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.274 2003/12/28 07:16:52 zaphod Exp zaphod $;
d2348 1
d5531 1
@


1.274
log
@fixed tarball problem in previous revision
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.273 2003/12/24 23:02:05 zaphod Exp zaphod $;
a2566 1
  my($ocaml) = false; # ditto ocaml
d2568 2
a2569 1
  my($figlet, $busybox); # further eponymous special cases
d2584 1
a2584 1
    $busybox ||= m!^all: menuconfig$!;
d2592 1
a2592 1
  @@targets = qw[oldconfig dep all] if $busybox;
@


1.273
log
@attempted workaround for perl 5.8.0 (only) with UTF-8 locale
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.272 2003/12/21 21:01:43 zaphod Exp zaphod $;
a4385 1
  binmode(TAR2GZIP) || error("binmode: $!"); # perl 5.8.0 utf8 bug
d4389 1
@


1.272
log
@added fixliblinks option; show broken link target before removing;
added bug list entry
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.271 2003/12/15 07:22:09 zaphod Exp zaphod $;
d189 2
a190 1
  open(HANDLE, "$mode$escaped") or error("open $file: $!");
d709 6
a714 3
  return true if open(HANDLE, "$prog @@args |");
  explain("failed to exec $prog: $!");
  return false;
d1221 1
d1228 1
d1280 1
d4386 1
d4402 1
@


1.271
log
@fixed potential problems with open() and odd filename characters
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.270 2003/12/15 00:49:56 zaphod Exp zaphod $;
d249 1
d2717 1
a2717 1
  explain("found broken symlink: $link");
d2753 26
d5356 16
d5524 1
@


1.270
log
@added protect option (enabled by default) to make armdir read-only;
toast build now makes rootdir files/directories read-only regardless;
new bugs in this version are not unlikely, despite my best efforts
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.269 2003/12/13 02:36:56 zaphod Exp zaphod $;
d183 9
d196 1
a196 1
  open(FILE, "<$file") || error("open $file for read: $!");
d538 1
a538 1
  open(FILE, ">$name") || error("open $name for write: $!");
d772 1
a772 1
  open(HANDLE, "<$source") || error("open $source for read: $!");
d815 1
a815 1
  open(DEST, ">$dest") || error("open $dest for write: $!");
d1179 1
a1179 1
  open(FILE, "<$file") || error("open $file for read: $!");
d1298 1
a1298 1
    open(STDIN, "<$infile") || error("open $infile for stdin: $!");
d1323 1
a1323 1
  open(STDIN, "<$file") || error("open $file: $!");
d1692 1
a1692 1
    open(FILE, "<$file") || error("open $file: $!");
d2855 1
a2855 1
  open(LOG, ">$tmplogname") || error("open $tmplogname for write: $!");
d2973 1
a2973 1
    open(LOCK, "<$path") || error("open $path: $!");
d3418 1
a3418 1
  open(PATCH, ">$patchfile") or error("open $patchfile: $!");
d3619 1
a3619 1
  open(SCRIPT, "<$file") || error("open $file for read: $!");
a5480 1
  - various unquoted arguments to 2-arg open()
@


1.269
log
@fixed terrible opendir error message (bug introduced in 1.267)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.268 2003/12/11 05:16:53 zaphod Exp zaphod $;
d244 1
d278 1
a278 1
  
a468 41
sub silentrm(@@)
{
  unlink || error("rm $_: $!") foreach @@_;
  true;
}

sub rm(@@)
{
  announce("rm", @@_);
  silentrm(@@_);
}

sub silentrd(@@)
{
  rmdir || error("rmdir $_: $!") foreach @@_;
  true;
}

sub rd(@@)
{
  announce("rmdir", @@_);
  silentrd(@@_);
}

sub rmall(@@)
{
  @@_ || error;
  announce("rm", "-r", @@_);
  dfs($_, sub { true }, sub { silentrm($_) }, sub { silentrd($_) }) foreach @@_;
  true;
}

sub rmexisting(@@)
{
  my(@@existing) = grep(-e || -l, @@_);
  rmall(@@existing) if @@existing;
  true;
}

##############################################################################

d491 21
d515 7
a521 6
  $mode = $mode & ~umask;
  my($txtmode) = sprintf("%lo", $mode);
  (($mode | 01777) == 01777) || error("unsafe mode: $txtmode");
  announce("chmod", $txtmode, @@files);
  chmod($mode, $_) || error("chmod $txtmode $_: $!") foreach @@files;
  true;
a546 10
sub safestat($)
{
  my($file) = @@_;
  my(@@result) = stat($file);
  @@result || error("stat $file: $!");
  @@result;
}

sub getmode($) { (safestat($_[0]))[2] & 0x1777; }

d596 42
d1522 1
a1522 1
    # wget can't always get FTP directory listing correctly w/o trailing slash 
d2701 1
a2701 9
sub fixrootsubdir($)
{
  my($dir) = @@_;
  my(undef, undef, $mode) = safestat($dir);
  safechmod(0755, $dir) unless ($mode & 07777) == 0755;
  return true;
}

sub fixrootlink($)
d2717 7
d2732 1
a2732 1
  rmexisting(path($rootdir, "info", "dir"));
d2738 3
a2740 3
    sub { $count{$_} = $total; fixrootsubdir($_) },
    sub { fixrootlink($_) if -l && !-e; ++$total },
    sub { $count{$_} < $total || rd($_) }
d2762 1
a2762 1
    rmexisting($srcdir, $helperdir);
d2778 1
a2778 1
      rmexisting($archivedir);
d2869 5
a2873 1
        if(-l)
d2876 1
a2880 4
        else
        {
          return chown(0, 0, $_) || ($success = !($msg = "chown $_: $!"))
        }
d3000 3
d3005 1
a3005 1
    rmexisting($dirfile);
d3010 1
a3010 1
    rmexisting($tmpfile);
d3020 2
d3041 12
d3060 8
a3067 1
      -d($dir) || md($dir);
d3069 1
d3078 6
a3083 1
    sub { optmd(optpath(armdir, $_[0])) },
d3085 1
a3085 1
    sub { true }
d3118 1
d3122 11
a3132 1
      sub { true },
d3149 5
a3153 1
        rd($armdir) if -d($armdir) && isempty($armdir);
d3157 1
d3701 1
a3701 1
  
d4336 1
a4336 1
  
d5362 8
a5481 1
  - directories in armdir should be read-only (mode 0555) by default
@


1.268
log
@replaced --noverbose with --quiet
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.267 2003/12/10 06:22:00 zaphod Exp zaphod $;
d2971 1
a2971 1
sub postarm()
d2974 2
d3003 1
d3005 3
d3009 1
@


1.267
log
@improved handling of info pages; minor doc adjustments
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.266 2003/12/09 05:07:32 zaphod Exp zaphod $;
d226 1
a226 1
    "verbose" => true,
d365 1
a365 1
  print("# @@_\n") if verbose;
d370 1
a370 1
  print("@@_\n") if verbose;
d2811 1
a2811 1
    setopt("verbose", true);
d2839 1
a2839 1
    print("  $_\n") if verbose;
d4163 1
a4163 1
  setopt("verbose", true);
d5122 1
a5122 1
=item S<B<--verbose> | B<--noverbose>>
d5124 3
a5126 3
Enables or disables verbose command output.  When disabled, most commands
will produce output only on failure.  Some commands, such as B<toast
status>, are not affected by this flag.  Default: enabled.
@


1.266
log
@removed the seek() that was breaking rpm extraction on some systems;
cleaned up some related code a little bit
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.265 2003/12/09 02:49:47 zaphod Exp zaphod $;
d243 1
d645 1
d652 1
d2256 1
a2256 1
  helpnop($helperdir, $_) foreach (qw[chown ldconfig]);
d2624 1
d2719 2
d2971 34
d3037 1
a3037 1
  run(postarmprog) if postarmprog;
d3093 1
a3093 1
  run(postarmprog) if postarmprog;
d5275 1
a5275 1
related, even if B<crossversion> is enabled.
d5282 12
a5293 1
for that package was given explicitly on the command line.
d5303 1
a5390 1
  - toast arm/disarm can leave info.dir in the wrong state
d5406 1
d5415 1
@


1.265
log
@fixed error message line numbers (off since 1.257)
@
text
@d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.264 2003/12/08 04:42:53 zaphod Exp zaphod $;
d1163 8
a1170 4
  my($buf);
  my($result) = read(STDIN, $buf, $len);
  defined($result) || error("read stdin: $!");
  $result == $len || error("read stdin: unexpected eof");
a1176 2
  return true if seek(STDIN, $len, 1);

d1180 1
a1180 1
    readstdin($chunk);
d1197 1
a1197 1
  print($buf) while read(STDIN, $buf, 8192);
d1203 1
a1203 1
sub autoextractstdin()
d1205 5
a1209 2
  my($buf) = readstdin(magicbufsize);
  forkstdin ? extractstdin(magicstring($buf)) : dumpstdin($buf);
d1219 1
a1219 1
  while(magicstring($hdr = readstdin(16 + $pad)) !~ /^\..z/i)
d1221 1
d1228 1
a1228 1
  forkstdin ? extractstdin(magicstring($hdr)) : dumpstdin($hdr);
@


1.264
log
@"toast help noverbose" now does the same thing as "toast help verbose"
@
text
@d23 2
d41 1
a41 1
my($rcsid) = q$Id: toast,v 1.263 2003/12/08 01:04:45 zaphod Exp zaphod $;
d52 1
a52 1
sub trace(;$)
d54 3
a56 2
  my($i, $out, $prev) = (shift || 1, "", "");
  while(my($package, $file, $line) = caller($i++))
d58 18
a75 2
    $out .= ($prev eq $file ? "/" : $out ? "; $file: " : "$file: ") . $line;
    $prev = $file;
a76 1
  $out;
d81 6
a86 1
  die(join('', @@_) || "assertion failed", "\n[" . trace . " v$myversion]\n");
d4108 1
a4108 1
warn("$myname: returning failure ($result)") if $result != 0;
a5340 1
  - error message line numbers are too low by 19 or so due to perl -x
@


1.263
log
@busybox
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.262 2003/12/07 23:56:35 zaphod Exp zaphod $;
d3515 1
a3515 1
  my($item, @@cmds, @@opts, %head, %body);
d3524 3
a3526 2
        $head{$item = $1} .= $_;
        push(@@cmds, $item) unless $body{$item};
d3528 1
a3528 1
      elsif(/^=item \S*-(\w+)/)
d3530 9
a3538 2
        $head{$item = $1} .= $_;
        push(@@opts, $item) unless $body{$item};
d3542 5
a3546 1
        $body{$item} .= $_ if $item;
d5318 1
a5318 1
  - "toast help verbose" works but "toast help noverbose" doesn't
@


1.262
log
@recent versions of netpbm work now
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.261 2003/12/07 21:10:30 zaphod Exp zaphod $;
d2506 1
a2506 1
  my($figlet);
d2521 1
d2529 1
d2568 1
d2664 1
a2664 1
  # XFree86 gets (understandably) confused by stdlinks and makes broken links
d5302 1
a5302 1
  - build fails for: jikes, sirc, netcat, lcab, busybox (ow!), gv
@


1.261
log
@preserve any pre-existing LD_PRELOAD during build; misc. doc tweakage
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.260 2003/12/06 21:20:06 zaphod Exp zaphod $;
d2278 1
d2301 1
d2308 1
@


1.260
log
@fix "can't find perl" build bug w/ older perl (introduced in 1.257)
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.259 2003/12/04 07:03:43 zaphod Exp zaphod $;
a1814 12
sub helpnorewrite($$)
{
  my($helperdir, $cmd) = @@_;
  my($path) = quote($ENV{PATH});
  my($preload) = quote($ENV{LD_PRELOAD});
  writescript(path($helperdir, "$cmd.helper"), qq[#!/bin/sh
PATH=$path
LD_PRELOAD=$preload
exec $cmd \"\$\@@\"
]);
}

d1827 1
d1832 8
a1839 1
delete $ENV{LD_PRELOAD};
a2224 1
#  helpnorewrite($helperdir, $_) foreach (qw[gcc g++ cc]);
d2228 11
a2238 1
  $env{LD_PRELOAD} = $preload if $preload;
d5133 7
a5139 7
When B<strictpreload> is enabled, B<toast build> will fail unless it can
successfully compile a shared library for use with LD_PRELOAD during the
C<make install> phase.  If B<strictpreload> is disabled, B<toast build>
still tries to build and use the shared library, but will do the best
it can otherwise.  This may allow B<toast build> to succeed in the
absence of a suitable C compiler, but it may allow some packages to
build incorrectly in some situations.  Default: enabled.
d5157 8
a5164 8
extra files that the package itself may not build or install itself
by default.  This produces improved results for many specific packages
(such as QT and XFree86), and may make subsequent packages more likely to
build, but it can sometimes break things (usually in a straightforward
way), or it may be undesirable for other reasons.  If B<reconfigure> is
disabled, B<toast build> does not try to do anything beyond the minimum
steps required to correctly build and install whatever files the package
includes by default.  Default: enabled.
a5294 1
  - build overrides LD_PRELOAD instead of appending [space-separated]
d5300 1
d5304 1
a5304 1
  - work around lack of getenv() in microperl
@


1.259
log
@toast build now collects additional diagnostic and statistical info
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.258 2003/12/04 04:28:20 zaphod Exp zaphod $;
d1046 15
d1077 1
a1077 1
  optrun($^X, "-V");
d1831 1
a1831 1
  my($perl) = abspath($^X);
@


1.258
log
@don't create unnecessary temporary files;
reshuffled code to reduce number of places where open() is called;
added wishlist item
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.257 2003/12/01 19:19:28 zaphod Exp zaphod $;
d605 1
a605 1
sub run(@@)
d609 18
a626 1
  system(@@prog) == 0 || error("@@prog returned $?");
d1056 32
d2747 2
d2753 1
d2765 1
a5284 1
  - put version and additional information at the *top* of broken.log
@


1.257
log
@add shell script wrapper; always use actual path to perl in helper scripts;
add special case for toast to autofind; code cleanup; updated docs
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.256 2003/12/01 06:46:57 zaphod Exp zaphod $;
d160 20
a265 1
    local(*DOTFILE, $_);
d269 1
a269 2
    open(DOTFILE, $dotfile) || error("open $dotfile for read: $!");
    while(<DOTFILE>)
d273 1
a273 1
      next if $_ eq "" || /^\#/;
d282 2
a283 2
    }
    close(DOTFILE) || error("close $dotfile for read: $!");
d520 1
a520 2
  my($realname, $mode, @@contents) = @@_;
  my($tempname) = addtmp($realname);
d522 2
a523 2
  explain("creating $tempname");
  open(FILE, ">$tempname") || error("open $tempname for write: $!");
d525 2
a526 3
  close(FILE) || error("close $tempname for write: $!");
  safechmod($mode, $tempname) if $mode;
  mv($tempname, $realname);
a540 18
sub whilefile(&$)
{
  my($sub, $file) = @@_;
  local(*FILE, $_);
  open(FILE, "<$file") || error("open $file for read: $!");
  while(defined($_ = <FILE>) && &$sub($_)) { }
  close(FILE) || error("close $file for read: $!");
  !defined($_);
}

sub readfile($)
{
  my($file) = @@_;
  my(@@result);
  whilefile { push(@@result, $_) } $file;
  @@result;
}

d1481 3
a1483 1
  writefile($urlfile, map("$_\n", @@urls));
d5238 1
@


1.256
log
@UPX (binary)
@
text
@d1 1
a1 1
#!/usr/bin/perl
d16 7
d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.255 2003/12/01 04:22:31 zaphod Exp zaphod $;
d842 5
a846 1
  path(pwd, $_[0]);
d1386 31
a1416 23
  local(*XML, $_);
  my($sitename) = "freshmeat.net";
  openurl(*XML, "http://freshmeat.net/projects-xml/$lcname/$lcname.xml");
  my($notfound, %fmurl);
  while(<XML>)
  {
    $notfound = /^Error: project not found/i ? 1 : 0 unless defined($notfound);
    $fmurl{$1} = $2 while m!<url_(\w+)>([^<]+)</!g;
  }
  close(XML) || error;

  error("no listing for package $name on $sitename") if $notfound;

  my($redirurl);
  $redirurl ||= $fmurl{$_} for qw(bz2 tgz zip rpm homepage);
  $redirurl || error("no suitable URL for package $name on $sitename");

  my($redirhead) = httphead($redirurl);
  $redirhead =~ /^Location: ([^\r\n]+)/m ||
      error("unexpected response from $redirurl");
  my($url) = $1;
  # wget can't always get FTP directory listing correctly w/o trailing slash 
  $url .= "/" unless basename(stripquery($url)) =~ /\./; # e.g. atop
a1704 6
  if($0 eq "-") # e.g. "perl - arm foo < toast"
  {
    close(STDIN); # this step apparently matters; ignore spurious error
    open(STDIN, "</dev/null") || error("open stdin: $!");
  }

d1767 2
a1768 2
  my($perl) = $^X;
  $perl = "/usr/bin/perl" unless $perl =~ m!/!;
d3577 5
a3581 5
  local($_) = @@_;
  s/ /\+/g;
  s/[^\!-\~]/urlescapechar($&)/ge;
  s!^(ftp://[^/:]+):21(/|$)!$1$2!; # wget likes to emit redundant ftp port no.
  $_;
d3586 4
a3589 4
  local($_) = @@_;
  $_ = abspath($_) unless m|^/|;
  s/[\%]/urlescapechar($&)/ge;
  cleanurl("file://localhost$_");
d4572 2
a4573 4
second relies on the GET utility that comes with the LWP Perl module.

  sh -c 'u=ttp://toastball.net/toast;wget -O- h$u/toast|perl - arm h$u/'
  sh -c 'u=ttp://toastball.net/toast;GET h$u/toast|perl - arm h$u/'
d4575 8
a4582 4
If you ran either of the above commands as root, B<toast> should
now be installed in C</toast> with appropriate symlinks under
C</usr/local>, and you should be all set.  If you ran either command
as a non-root user, B<toast> will have installed itself and everything
a5241 1
  - wrap toast in #!/bin/sh: "sh configure" will work, find perl, etc.
@


1.255
log
@airhook
@
text
@d32 1
a32 1
my($rcsid) = q$Id: toast,v 1.254 2003/12/01 04:19:59 zaphod Exp zaphod $;
d2340 1
a2340 1
  # construct a Makefile for specific intransigent binary packages
d2345 2
d2349 5
a2353 1
    $name =~ /readme|flashplayer-installer/;
@


1.254
log
@toast now works a bit better under microperl
@
text
@d32 1
a32 1
my($rcsid) = q$Id: toast,v 1.253 2003/11/29 00:33:21 zaphod Exp zaphod $;
d2456 2
a2457 1
  announce("export", "$_=$ENV{$_}") foreach (qw[ROOT DESTDIR install_root]);
@


1.253
log
@fix directory permissions in rootdir
@
text
@d16 1
a16 1
use 5;
d18 1
d20 1
a20 3
BEGIN { $SIG{'__DIE__'} = sub { warn(@@_) } }
use strict; # if available
BEGIN { $SIG{'__DIE__'} = 'DEFAULT' }
d23 1
a23 1
if($^V) # 5.0 emits spurious message
d32 1
a32 1
my($rcsid) = q$Id: toast,v 1.252 2003/11/29 00:18:29 zaphod Exp zaphod $;
d2234 1
d2476 1
a2476 1
  run(@@trace, qw[cp -R], glob("$netpbm/*/"), $rootdir) if $netpbm;
d5205 1
d5209 1
@


1.252
log
@fixed rpm extraction bug
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.251 2003/11/28 22:27:31 zaphod Exp zaphod $;
d2559 8
d2595 1
a2595 1
    sub { $count{$_} = $total; true },
@


1.251
log
@zlib: build libz.so
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.250 2003/11/28 21:06:42 zaphod Exp zaphod $;
d1114 2
a1115 4
  autoextractstdin if forkstdin;

  local($_) = readstdin(96);
  /^\xed\xab\xee\xdb[\x03\x04]/ || error("not rpm v3 or v4");
d1118 2
a1119 1
  while(magicstring($_ = readstdin(16 + $pad)) !~ /^\..z/i)
d1121 1
a1121 1
    my($magic, $zero, $sections, $bytes) = unpack("x$pad N4", $_);
d1127 2
a1128 1
  dumpstdin($_);
a5191 1
  - can't extract nss-tools-3.4.1-2.i686.rpm in some environments (?)
d5195 1
a5195 1
  - "toast --autoremove --crossversion upgrade toast" fails w/ NFS
@


1.250
log
@add support for plugger; update bug list
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.249 2003/11/28 05:16:49 zaphod Exp zaphod $;
d2216 1
@


1.249
log
@glibc works much better now
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.248 2003/11/27 02:38:30 zaphod Exp zaphod $;
d2421 1
d5196 1
@


1.248
log
@ignorecase option was misbehaving when no explicit version was given
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.247 2003/11/27 02:33:02 zaphod Exp zaphod $;
d2148 2
a2149 1
      foreach (qw[mkdir rmdir touch cp rm ln install chmod test ranlib], "[");
d2263 30
d2295 2
a2335 28
  # Terrible, terrible hack to allow glibc+linuxthreads to compile:
  # Look for a situation where we have multiple subdirectories, but no files,
  # and only one of the subdirectories contains an executable configure script
  # that actually does something.  If that happens, move the other directories
  # into the directory with the non-broken configure script and run that.
  my($newdir);
  my(@@addons);
  my($addonsok) = whiledir
  {
    push(@@addons, $_);
    my($abs) = path($dir, $_);
    return false if !-d($abs) || -l($abs);
    my($cfg) = path($abs, "configure");
    if(-x($cfg))
    {
      return true if whilefile { /^\s*(\#|exit|$)/ } $cfg;
      return false if $newdir;
      $newdir = $abs;
      pop(@@addons);
    }
    true;
  } $dir;
  if($addonsok && @@addons && $newdir)
  {
    mv(path($dir, $_), path($newdir, $_)) foreach @@addons;
    return &configure($newdir, $prefix);
  }

d2461 1
a2461 1
    $usedestdir ||= /\bDESTDIR\b/; # atop needs this, but see libtiff above
d2471 1
a5194 1
  - glibc: libdl.so and other links point into ../../destdir/lib (?)
@


1.247
log
@fixed PATH quoting problems in toast build
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.246 2003/11/27 02:07:26 zaphod Exp zaphod $;
d3573 2
a3574 1
  return ($name, $version) if isversion($name, $version);
a5177 1
  - if packages foo and Foo exist, "foo" and "Foo" both refer to Foo
@


1.246
log
@add support for flash player 6; document new bugs
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.245 2003/11/24 00:46:28 zaphod Exp zaphod $;
d1710 1
a1710 1
  local($_) = @@_;
d1727 1
d1729 1
a1729 1
      "#!/bin/sh\nPATH=$ENV{PATH}\nexec $cmd \"\$\@@\"\n");
d1742 2
a1743 2
  my($path) = undeftoempty($ENV{PATH});
  my($preload) = undeftoempty($ENV{LD_PRELOAD});
a5176 1
  - toast build generates broken helper scripts if PATH contains spaces
@


1.245
log
@fixed spurious hyperlink in HTML docs; griped about toast upgrade
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.244 2003/11/23 23:49:36 zaphod Exp zaphod $;
d2333 21
d5176 2
d5186 1
a5186 1
  - autofind fails for: sleepycat db, gcc, latex, gv, GNU arch (?)
d5189 1
d5193 1
@


1.244
log
@many commands no longer require arguments;
toast arm now silently skips armed builds;
revised and updated docs
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.243 2003/11/23 00:34:30 zaphod Exp zaphod $;
d4515 2
a4516 2
  sh -c 'u=http://toastball.net/toast;wget -O- $u/toast|perl - arm $u/'
  sh -c 'u=http://toastball.net/toast;GET $u/toast|perl - arm $u/'
d5165 1
d5169 1
@


1.243
log
@messed with docs
@
text
@d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.242 2003/11/22 21:17:23 zaphod Exp zaphod $;
d2804 1
a2804 2
  isarmed($name, $version, $build) &&
      error(pkgname($name, $version, $build) . " is already armed");
d3749 5
d3757 6
a3762 3
sub parse_get(@@) { rejectempty(uselatestversion(rejectbuilds(parse(@@_)))); }
sub parse_build(@@) { rejectempty(uselatestversion(rejectbuilds(parse(@@_)))); }
sub parse_rebuild(@@) { rejectempty(uselatestversion(rejectbuilds(parse(@@_)))); }
a3763 3
sub parse_arm(@@) { rejectempty(uselatestversion(parse(@@_))); }
sub parse_upgrade(@@) { rejectempty(rejectmissing(uselatestversion(rejectbuilds(parse(@@_))))); }
sub parse_disarm(@@) { rejectempty(rejectmissing(parse(@@_))); }
d4513 1
a4513 1
second relies on the C<GET> utility that comes with the LWP Perl module.
d4518 8
a4525 7
If you ran either of the above commands as root, B<toast> should now be
installed in C</toast> with appropriate symlinks under C</usr/local>,
and you should be all set.  If you ran either command as a non-root
user, B<toast> will have installed itself and everything it needs under
C<$HOME/.toast>, and you'll probably need to add C<$HOME/.toast/armed/bin>
to your PATH environment variable in order to be able to use B<toast>
and any other packages it installs.  For example, in a Bourne-like shell:
d4530 7
a4536 6
files installed by B<toast>, you may also want to adjust MANPATH,
INFOPATH, LD_LIBRARY_PATH, or CFLAGS as appropriate.  Note that setting
LD_LIBRARY_PATH may have unintended consequences; for more information,
search the Web for <LD_LIBRARY_PATH considered harmful>.  If your C
compiler is gcc, you may be able to use the CPATH environment variable
instead of messing with CFLAGS; see the gcc documentation for details.
d4539 17
a4555 13
use B<toast>.  The unmodified B<toast> script can be copied to and run
from any location, and you can use B<toast man> to view the man page
without having to install it first.  The default option settings should
be sensible, and any necessary directories will be created on demand.

A GNU-like C<configure> wrapper script is also provided with the official
B<toast> distribution for your convenience.  You can supply an alternate
installation directory prefix with C<./configure --prefix=foo>, or keep
the default prefix of C</usr> by running C<./configure> without arguments.
Then run C<make>, become root if necessary, and run C<make install>, which
will install both the B<toast> script and a man page.  Sadly, B<toast>'s
C<configure> script does not support the other command-line options and
features of B<configure> scripts produced by the real GNU autoconf.
d4572 1
a4572 1
=item S<B<toast get> I<PACKAGE> ...>
d4574 77
a4650 36
Downloads the given packages' files into the repository.  Implies B<toast
add>.  After this command completes successfully, other commands will be
able to operate on the package without downloading any additional files
from the network.  If a given package is already C<stored>, the existing
downloaded files are silently preserved; use B<toast purge> to force
them to be downloaded afresh.  B<toast get> has rudimentary built-in
support for C<file> and C<http> URLs.  If GNU B<wget> is installed,
B<toast get> will use it to fetch C<http>, C<https>, and C<ftp> URLs.
If B<ssh> is available, B<toast get> can use it to fetch (non-standard)
URLs of the form C<ssh:/[username@@]hostname/absolute/path/to/file>.

=item S<B<toast build> I<PACKAGE> ...>

Ensures that the given packages are built.  Packages that already have
at least one C<built> or C<armed> build (as reported by B<toast status>)
are skipped by this command without causing an error; use B<toast rebuild>
to force such packages to be rebuilt.  Building may involve implicitly
invoking B<toast get>, decompressing and extracting archives, applying
patch files, compiling a new build of the package and installing it in
a build-specific directory tree.  Supported archive formats include
compress, gzip, bzip2, zip, rpm, cpio, tar, shar, patch, and most
combinations of the above.  You don't need to have RPM installed to
extract .rpm files; gzip and cpio usually suffice.  Archives should
contain either precompiled binaries or source code; in the latter case,
a C<configure> script, C<Makefile>, C<Imakefile>, C<install.sh> or similar
is usually, but not always, required.  Many options can influence this
command's behavior; see the options reference for full details.

=item S<B<toast rebuild> I<PACKAGE> ...>

Forces packages to be built or rebuilt.  A new build will be created
as if by B<toast build> for every package given, even if the package
has already been successfully built.  Each package can have any number
of independent builds.  Builds for a given package are automatically
assigned sequential numbers starting from 1.  Many options can influence
this command's behavior; see the options reference for complete details.
d4652 1
a4652 1
=item S<B<toast clean> [ I<BUILD> | I<PACKAGE> ...]>
d4654 6
a4659 41
Deletes files not required by B<toast arm> from builds.  If no explicit
version and/or build number is given, all matching versions and/or
builds are cleaned.  Cleaning a broken build removes the build entirely;
otherwise only files that are not required by B<toast arm> are removed
from the build.  These typically consist of files created directly by
B<toast> as part of the build environment, extracted source files, and
intermediate files created by the package itself during compilation.
The B<toast build> and B<toast rebuild> commands may perform this step
automatically for some kinds of binary packages that do not involve
intermediate files, as well as for other packages if the B<autoclean>
option is enabled.  Only builds that are not in the C<building> state
(as reported by B<toast status>) may be cleaned.  If no arguments are
given, all eligible builds are cleaned.

=item S<B<toast arm> I<BUILD> | I<PACKAGE> ...>

Creates symbolic links to each file in a build.  This step is normally
required before a package can be used.  The links are typically created
under a directory such as C</usr/local>.  Existing links to other builds
are moved out of the way if necessary, and the corresponding builds are
still considered to be armed.  A build must be in the C<built> state
(as reported by B<toast status>) before it can be armed.  If no explicit
build number is supplied on the command line, B<toast build> is implied,
and the latest C<built> or C<armed> build is armed.  If the build to be
armed is already in the C<armed> state, the command fails.

=item S<B<toast upgrade> I<PACKAGE> ...>

Checks for a later version of an existing package.  The existing
package's URLs are used as a starting point to locate the new version.
If the filename component of a given URL doesn't appear to contain the
package's version number, that URL will be left unmodified for the new
version; otherwise, the directory portion of the URL will be immediately
downloaded and searched for a similar URL containing a higher version
number.  The command fails if no URLs would change or if no single
consistent newer version for all version-containing URLs can be found;
otherwise, the highest eligible version is used for all modified URLs
and the package itself.  The command performs an implicit B<add>, B<get>,
B<build> or B<arm> on the extrapolated URLs so as to match the state of
the given existing version, except that the new package will never be
armed if the B<autoarm> option is disabled.
d4661 1
a4661 1
=item S<B<toast disarm> I<BUILD> | I<PACKAGE> ...>
d4663 13
a4675 5
Deletes symlinks created by B<toast arm>.  This works by removing symbolic
links to the given build and replacing any links that had been moved
out of the way.  If no build number is given, all C<armed> builds are
disarmed.  If the package version number is also omitted, all C<armed>
builds belonging to packages with the given name are disarmed.
d4711 2
a4712 2
I<PACKAGE>.  Attempting to rename an armed package causes B<toast rename>
to report an error.  This command can also be used to renumber builds.
d5138 3
a5140 2
By default, B<toast> writes only to the C<I<$HOME>/.toast> directory,
which will be created automatically if needed.
d5150 2
a5151 3
failures, and so on to C<pub.comp.toast> on the ofb.net Gale system
(preferred; see C<http://gale.org>), or via email to C<toast-bugs> at
the hostname of the toast distribution site, toastball.net.
a5167 1
  - "toast build" w/o arguments should build all unbuilt packages
@


1.242
log
@minor doc correction
@
text
@d5 4
a8 3
# This file (except for the GNU General Public License, if present)          #
# is toast, a program for installing and managing software packages.         #
# Copyright (C) 2003 Jacques Frechet                                         #
d10 3
a12 13
# This program is free software; you can redistribute it and/or modify       #
# it under the terms of the GNU General Public License as published by       #
# the Free Software Foundation; either version 2 of the License, or          #
# (at your option) any later version.                                        #
#                                                                            #
# This program is distributed in the hope that it will be useful,            #
# but WITHOUT ANY WARRANTY; without even the implied warranty of             #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
# GNU General Public License for more details.                               #
#                                                                            #
# You should have received a copy of the GNU General Public License          #
# along with this program; if not, write to the Free Software                #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  #
d33 1
a33 1
my($rcsid) = q$Id: toast,v 1.241 2003/11/21 05:29:46 zaphod Exp zaphod $;
d4454 5
d4499 5
a4503 2
of any Perl modules or other tools.  Additional requirements for B<toast
build> vary according to the package being built.
d4533 4
a4536 4
use B<toast>.  The unmodified script can be copied to and run from any
location, and you can use B<toast man> to view the man page without
having to install it first.  The default option settings should be
sensible, and any necessary directories will be created on demand.
d4565 9
a4573 5
add>.  After this command completes successfully, other commands will
be able to operate on the package without downloading any additional
files from the network.  If a given package is already C<stored>, the
existing downloaded files are silently preserved; use B<toast purge>
to force them to be downloaded afresh.
d4577 14
a4590 8
Ensures that the given packages are built.  Packages that already
have at least one C<built> or C<armed> build (as reported by B<toast
status>) are skipped by this command without causing an error; use
B<toast rebuild> to force such packages to be rebuilt.  Building may
involve implicitly invoking B<toast get>, extracting archives, applying
patch files, compiling a new build of the package and installing it
in a build-specific directory tree.  Many options can influence this
command's behavior; see the options reference for complete details.
a5161 2
  - What kinds of packages can be expected to build?
  - What protocols and archive formats are supported?
a5165 4
=head1 AUTHOR

Jacques Frechet

d5187 22
@


1.241
log
@version 1.2.3rc4 now precedes 1.2.3; also 1.2.3-{rc,test,pre}4
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.240 2003/11/21 05:05:47 zaphod Exp zaphod $;
d4947 1
a4947 1
disabled.
a5122 1
  - "toast --noautoarm build foo" disarms and demolishes old foo builds
@


1.240
log
@moved __END__ to EOF to help with bootstrapping;
added version sorting peeve to bug list
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.239 2003/11/09 23:43:26 zaphod Exp zaphod $;
d977 1
d979 1
a979 1
  join(' ', map(padsingle($_), @@n[0..max(padfactor, $#n)]));
d984 6
a989 2
  my($na, $nb) =
      map { my($x) = $_; $x =~ s/\d+(\.\d+)*/padnum($&)/ge; $x } ($a, $b);
a5132 1
  - version 1.2.3rc4 should precede 1.2.3; also 1.2.3-{rc,test,pre}4
@


1.239
log
@more docs
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.238 2003/11/08 21:52:54 zaphod Exp zaphod $;
a4435 1
__END__
a5118 1
  - __END__ causes trouble when piping toast to perl for bootstrapping
d5128 1
d5183 1
a5183 1
# toast: EOF
@


1.238
log
@fixed build/arm assertion failure introduced in 1.235
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.237 2003/11/04 03:26:24 zaphod Exp zaphod $;
d4457 87
d5107 1
a5107 4
the terms of the GNU GPL.  B<toast> itself is known to work with Perl
5.005_03 through 5.8.x under Linux, FreeBSD and Cygwin, without relying
on the presence or absence of any Perl modules or other tools.  Additional
requirements for B<toast build> vary according to the package being built.
a5149 2
  - For what purposes might one actually use toast?
  - What environment variables should I set?
@


1.237
log
@fixed opendir error when arming new packages (introduced in 1.235);
added opera complaint to buglist
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.236 2003/11/02 21:59:05 zaphod Exp zaphod $;
d2733 1
a2733 1
  $build = latestbuilt($name, $version);
@


1.236
log
@updated option docs
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.235 2003/11/02 20:36:31 zaphod Exp zaphod $;
d1263 1
d5038 1
a5038 1
  - sleepycat db utterly fails to build when already armed
@


1.235
log
@split toast build into build and rebuild; tweaked parsing and docs
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.234 2003/11/02 03:19:49 zaphod Exp zaphod $;
d4822 7
a4828 2
When B<autoclean> is enabled, B<toast build> performs an implicit B<toast
clean> on every newly created non-broken build.  Default: enabled.
d4832 2
a4833 3
When B<autopurge> is enabled, B<toast build> performs an implicit
B<toast purge> on every package with a newly created non-broken build.
Default: disabled.
d4837 3
a4839 3
When B<autoarm> is enabled, B<toast build> performs an implicit B<toast
arm> on every newly created non-broken build whose package already
contains another armed build.  Default: enabled.
d4851 5
a4855 3
When B<autodemolish> is enabled, B<toast build> performs an implicit
B<toast demolish> on every other build belonging to the same package
as a newly-created, non-broken build.  Default: disabled.
d4862 2
a4863 1
Default: disabled.
@


1.234
log
@autofind improvements (follow homedir link as last resort; prefer URLs
with same name as package); make cdrtools (a.k.a. cdrecord) build
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.233 2003/10/27 04:08:26 zaphod Exp zaphod $;
d1258 1
a1258 1
sub latestbuild($;$$)
d1261 7
a1267 1
  lastitem(allbuilds($name, $version, $build));
d2607 1
a2607 1
sub build(@@)
d2728 8
d2805 1
a2805 2
  ($name, $version, $build) = build($name, $version, undef, @@urls)
      if !defined($build) || !isbuilt($name, $version, $build);
a3752 15
sub uselatestbuild(@@)
{
  my(@@result);
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $version = latestversion($name, $version)
        if isname($name);
    $build = latestbuild($name, $version, $build)
        if isversion($name, $version);
    push(@@result, [$name, $version, $build, @@urls]);
  }
  @@result;
}

d3757 2
a3758 1
sub parse_build(@@) { allowempty(uselatestversion(rejectbuilds(parse(@@_)))); }
d3760 1
a3760 1
sub parse_arm(@@) { rejectempty(uselatestbuild(parse(@@_))); }
d4462 8
a4469 7
Adds new packages to the repository by storing URLs.  Use this command
to store package file locations without actually downloading anything.
Each I<PACKAGE> must specify at least one URL or file unless the
B<autofind> option is enabled.  Absolute and relative pathnames are
automatically translated into file URLs.  If the given package has
already been added, the command merely compares the given URLs against
those already stored and gives an error if they don't match.
d4476 3
a4478 1
files from the network.
d4482 16
a4497 7
Creates a new build for one or more packages.  This may involve
implicitly invoking B<toast add>, extracting archives, applying patch
files, compiling a new build of the package and installing it in
a build-specific directory tree.  Each package can have any number of
independent builds.  Builds for a given package are automatically assigned
sequential numbers starting from 1.  If the package is not stored, or
if URLs are given, B<toast get> is implied.  Many options can influence
d4502 1
a4502 1
Deletes and intermediate files created by B<toast build>.  If no explicit
d4509 6
a4514 5
The B<toast build> command may perform this step automatically for some
kinds of binary packages that do not involve intermediate files, as well
as for other packages if the B<autoclean> option is enabled.  Only builds
that are not in the C<building> state (as reported by B<toast status>) may
be cleaned.  If no arguments are given, all eligible builds are cleaned.
d4522 5
a4526 8
still considered to be armed.  A build must be in the C<built> state (as
reported by B<toast status>) before it can be armed.  If no explicit build
number is supplied on the command line, this command implicitly creates
a new build (as if by B<toast build>) if the package has no builds, or
arms the latest C<built> build if such a build exists and was created
later (numbered higher) than the latest C<armed> build for that package
(if any).  If the latest build is already armed, the command fails; you
probably meant to invoke B<toast build> with the C<autoarm> option set.
d4559 2
a4560 2
of B<toast build> (and, optionally, B<toast arm>), but never those of
B<toast get> or B<toast add>.
d4568 2
a4569 1
is enabled, B<toast build> may implicitly invoke this command.
d4587 1
a4587 3
to report an error.  Otherwise, renaming a package that contains builds
should be OK, though it could conceivably break ill-behaved packages.
This command can also be used to renumber builds.
d4607 4
a4610 4
is still running), C<broken> (if it failed), C<built> (if it succeeded),
or C<armed> (by B<toast arm>).  In the last two cases, the build will
be marked C<(not clean)> if intermediate files created by B<toast build>
have not yet been removed by C<toast clean>.
a5040 1
  - add "toast rebuild" command; "toast build" should just ensure built
@


1.233
log
@added copyright notice, GPL, and --version
@
text
@d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.232 2003/10/26 22:13:57 zaphod Exp zaphod $;
d1387 1
a1387 1
  $redirurl ||= $fmurl{$_} for qw(bz2 tgz zip rpm);
d1412 3
d1532 1
a1532 1
  ($name, $version);
d1633 1
a1633 1
  my($autorename) = !defined($version) && autorename;
d1635 1
a1635 1
  ($name, $version) = add(@@_) if @@urls || !isadded($name, $version);
d1665 1
a1665 1
  ($name, $version);
d2201 1
d2418 1
a2418 1
  my(@@trace, $man, $subdir, $netpbm, $usedestdir);
d2432 1
d2441 1
a2844 1
  @@urls && error;
@


1.232
log
@make "toast upgrade" a bit choosier
@
text
@d3 22
d42 1
a42 1
my($rcsid) = q$Id: toast,v 1.231 2003/10/26 21:43:17 zaphod Exp zaphod $;
d47 1
d3343 7
a3349 1
  print("\n$myname version $myversion -- $myurl\n\n");
d3479 16
d4059 1
d4082 348
@


1.231
log
@fixed trivial toast rename glitch; added wishlist item
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.230 2003/10/26 20:27:45 zaphod Exp zaphod $;
d2869 5
a2873 2
  my(%linkmap);
  my($verpat) = $version =~ /^\d/ ? '\d.*' : '.+';
d2875 1
a2875 2
  my(%candidates);
  my(@@newurls);
@


1.230
log
@improved name/version guessing
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.229 2003/10/26 18:12:46 zaphod Exp zaphod $;
d3174 3
a4623 1
  - "toast rename a/b c/d" doesn't remove a if b was the only version
d4636 1
@


1.229
log
@inconsequential doc changes
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.228 2003/10/26 02:04:12 zaphod Exp zaphod $;
d917 6
a922 5
  local($_) = @@_;
  s/\:/_/g;
  s/^[\W_]+//;
  s/[\W_]+$//;
  $_ eq "" ? undef : $_;
d927 7
a933 7
  my(@@sources) = @@_;
  local($_) = stripext(basename(stripquery(collapse(@@sources))));
  /^([\w]+[\w\-]*[a-z]+)[-_]v?(\d[\w\.\+\-]+)$/i || # Cryptix_src_3-1-1.zip
  /([^-]+)-(.*\d.+)/ ||                             # iputils-ss020124.tar.gz
  /^(\D+[^a-z])v(\d.*)$/ ||                         # TinyMAZEv2.4a.tar.gz
  /^(\D+)(\d.*)$/ ||                                # fceu019linux.tar.gz
  /^(.*)()$/;                                       # Xmerge.tar.gz
d935 2
a936 2
  $name =~ s/\./_/g;
  (sanitize($name), sanitize($version));
a4613 1
  - "toast add [ ftp://bar/bar.tar.gz bar.patch ]" guesses "f/unknown"
a4635 1
  - improve name-guessing: gtk+, mozilla-source, jpegsrc, X/430src (?)
@


1.228
log
@new doc sections: ENVIRONMENT, FILES, AVAILABILITY, BUGS, SEE ALSO
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.227 2003/10/25 22:43:34 zaphod Exp zaphod $;
d4077 1
a4077 1
files, compiling a new build of the package and "installing" it in
d4247 1
a4247 1
versions or operates on "sets of packages," in which case all versions
d4336 1
a4336 1
When invoked as root, B<toast build> will unpack, compile, and "install"
d4456 1
a4456 1
"make install" phase.  If B<strictpreload> is disabled, B<toast build>
d4608 1
a4608 1
(preferred; see C<http://gale.org>), or via email to "toast-bugs" at
d4625 1
a4625 1
  - autofind fails for: sleepycat db, gcc, latex, gv, arch (?)
d4674 1
a4674 1
  GNU stow       http://www.gnu.org/software/stow
@


1.227
log
@use full path to perl in wrappers even when bootstrapping
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.226 2003/10/25 22:38:34 zaphod Exp zaphod $;
d4558 2
a4559 2
from a line of the form I<NAME>B<=>I<VALUE>, if such a line exists,
in C<$HOME/.toast/conf>, if that file exists.  (C<$HOME> specifically
d4583 74
d4661 21
d4684 1
a4684 20
# questions still unanswered by man page:
# what protocols and archive formats are supported?
# what kinds of packages can be expected to build?
# how are storedir and armdir structured?
# how does this tool differ from similar tools?
# how might people actually use this thing?

# other ideas (stolen from real man pages observed in the wild):
# RETURN VALUE
# TIPS
# NOTES
# AVAILABILITY
# URL
# ENVIRONMENT
# FILES
# SEE ALSO
# DIAGNOSTICS
# BUGS
# VERSIONS

@


1.226
log
@toast's own Makefile now correctly honors DESTDIR
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.225 2003/10/25 02:51:52 zaphod Exp zaphod $;
d1724 3
a1726 1
  writescript(path($helperdir, "$cmd.helper"), "#!$^X\n# $genby\n", q[
@


1.225
log
@don't configure arch in source directory (tested)
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.224 2003/10/24 18:33:37 zaphod Exp zaphod $;
d3945 3
a3947 3
  $(MKINSTALLDIRS) $(bindir) $(man1dir)
  $(CP) $(prog) $(bindir)
  $(CP) $(manpage) $(man1dir)
@


1.224
log
@don't configure arch in source directory (untested)
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.223 2003/10/24 03:32:26 zaphod Exp zaphod $;
d2170 1
a2170 1
        $builddir ||= /unning configure in a source directory is not rec/;#arch
@


1.223
log
@work around wget FTP listing bug with no trailing slash on some servers;
autofind now chooses atop-1.10.tar.gz over atop-1.10-1.src.rpm;
conditionally set DESTDIR on make cmdline to fix atop w/o breaking libtiff
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.222 2003/10/23 05:46:34 zaphod Exp zaphod $;
d2170 1
@


1.222
log
@figlet
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.221 2003/10/20 22:07:50 zaphod Exp zaphod $;
d784 1
a784 1
  close(HANDLE) || error;
d1370 2
d1383 7
a1389 9
    my(@@exts) = (qw[.tar.bz2 .tar.gz .tgz .zip .rpm]);
    my($extpat) = '(' . join('|', map(quotemeta($_), @@exts)) . ')$';
    @@urls = grep(/$extpat/, @@urls);

    if(!defined($version))
    {
      my(@@versions) = map { my(undef, $v) = guessnv($_); $v } @@urls;
      @@versions = grep(defined($_), @@versions);
      if(@@versions)
d1391 3
a1393 3
        @@versions = reverse sort cmpab @@versions;
        $version = $versions[0];
        @@urls = grep
d1395 8
a1402 3
          my(undef, $v) = guessnv($_);
          defined($v) && $v eq $version;
        } @@urls;
a1403 1
    }
d1405 1
a1405 5
    my($ext);
    for $ext (@@exts)
    {
      my(@@matches) = grep(stripquery($_) =~ /\Q$ext\E$/i, @@urls);
      return ($name, $version, $matches[0]) if @@matches;
d2387 1
a2387 1
  my(@@trace, $man, $subdir, $netpbm);
d2391 1
a2391 1
  local($ENV{DESTDIR}) = $rootdir; # not on command line due to libtiff
d2400 1
d2408 1
@


1.221
log
@restored compatibility with older versions of perl (broken in 1.209?)
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.220 2003/10/20 00:32:55 zaphod Exp zaphod $;
d2346 1
d2353 1
d2356 1
a2356 1
  return false unless whilefile
d2364 3
a2366 1
    !/^all:[^\#]*\binstall\b/; # abort if all implies install (e.g. man-pages)
d2369 1
@


1.220
log
@look for install.pl (e.g. dailystrips)
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.219 2003/10/19 21:03:47 zaphod Exp zaphod $;
d3063 1
a3063 1
    last if mkdir($newverdir);
@


1.219
log
@autofind now tries harder (e.g. bzip2, pkgconfig)
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.218 2003/10/19 18:45:08 zaphod Exp zaphod $;
d2245 1
a2245 1
  for(qw[install.sh INSTALL])
@


1.218
log
@cleaned up spurious warnings emitted by autofind for some packages
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.217 2003/10/13 05:35:37 zaphod Exp zaphod $;
d761 1
a761 1
    push(@@links, $link);
d1371 1
a1371 1
  if(lookslikepkgurl($url))
d1373 5
a1377 3
    (undef, $version) = guessnv($url) unless defined($version);
    return ($name, $version, $url);
  }
d1379 5
a1383 4
  my(@@urls) = grep(lookslikepkgurl($_, $name, $version), linksfromurl($url));
  my(@@exts) = (qw[.tar.bz2 .tar.gz .tgz .zip .rpm]);
  my($extpat) = '(' . join('|', map(quotemeta($_), @@exts)) . ')$';
  @@urls = grep(/$extpat/, @@urls);
d1385 1
a1385 5
  if(!defined($version))
  {
    my(@@versions) = map { my(undef, $v) = guessnv($_); $v } @@urls;
    @@versions = grep(defined($_), @@versions);
    if(@@versions)
d1387 3
a1389 3
      @@versions = reverse sort cmpab @@versions;
      $version = $versions[0];
      @@urls = grep
d1391 15
a1405 3
        my(undef, $v) = guessnv($_);
        defined($v) && $v eq $version;
      } @@urls;
a1406 1
  }
d1408 3
a1410 5
  my($ext);
  for $ext (@@exts)
  {
    my(@@matches) = grep(stripquery($_) =~ /\Q$ext\E$/i, @@urls);
    return ($name, $version, $matches[0]) if @@matches;
d3447 1
@


1.217
log
@fixed more parsing flakiness with bare URLs and hard-to-guess names
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.216 2003/10/13 05:15:58 zaphod Exp zaphod $;
d1390 5
a1394 1
      @@urls = grep { my(undef, $v) = guessnv($_); $v eq $version } @@urls;
@


1.216
log
@include version number in stack trace
@
text
@d20 1
a20 1
my($rcsid) = q$Id: toast,v 1.215 2003/10/13 04:55:05 zaphod Exp zaphod $;
d1210 1
a1210 1
  -d(pkgpath($name));
d1216 1
a1216 1
  -d(pkgpath($name, $version));
d1222 2
a1223 1
  -d(pkgpath($name, $version, $build));
d3621 2
a3622 2
    error("no such package: ", pkgname($name, $version)) unless
        defined($version) ? isversion($name, $version) : isname($name)
@


1.215
log
@ocaml
@
text
@d20 11
a30 1
sub trace($)
d32 1
a32 1
  my($i, $out, $prev) = (shift, "", "");
d43 1
a43 1
  die(join('', @@_) || "assertion failed", "\n[" . trace(1) . "]\n");
a47 10
my($rcsid) = q$Id: toast,v 1.214 2003/10/13 04:34:23 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\S+) (\S+ \S+) (\S+) Exp (\S+ )?$/ || error;
my($myname, $myversion, $mytimestamp, $myauthor) = ($1, $2, $3, $4);
$myversion .= "+" if $5; # if this version may contain changes not in RCS
my($myurl) = "http://www.toastball.net/toast/";
my($genby) = "generated by $myname version $myversion [$myurl]";
$myname eq "toast" && $myauthor eq "zaphod" || error; # avoid accidents w/ CVS

##############################################################################

@


1.214
log
@improved tar file recognition (should work better with large buffer)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.213 2003/10/05 23:17:17 zaphod Exp zaphod $;
a2145 1
      my(@@confcmd) = ("./$cfg", "--prefix=$prefix");
d2149 1
d2155 1
d2170 1
d2174 1
d2337 1
d2347 1
d2357 1
@


1.213
log
@toast arm was failing for some packages with hard-to-guess names
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.212 2003/10/05 22:53:42 zaphod Exp zaphod $;
a1024 1
  return ".tar" if /^[^\x00]+(..)?\x00{5,}[\x00\s\d]*$/ || /\x00ustar[ \x00]/;
d1026 2
@


1.212
log
@use larger buffer when guessing file type (may help w/ some patches)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.211 2003/10/05 20:14:32 zaphod Exp zaphod $;
d2732 1
a2732 1
      if !isbuilt($name, $version, $build);
d3441 1
@


1.211
log
@added useflock option (disabled under cygwin); misc. minor tweaks
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.210 2003/10/05 19:08:29 zaphod Exp zaphod $;
d1013 2
a1014 1
sub magicbufsize { 128 }
@


1.210
log
@define missing RTLD_NEXT under cygwin if needed
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.209 2003/09/24 01:41:53 zaphod Exp zaphod $;
d175 1
d180 1
a180 1
    "debugrewrite" => false
d2708 1
d2721 1
a2721 1
    flock($lock, 8) || error("unlock $path: $!"); # LOCK_UN
d4092 1
a4092 1
and the package itself.  The command performs an implicit <add>, B<get>,
d4428 11
@


1.209
log
@added edit command (unfinished, undocumented, experimental, watch out, etc.)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.208 2003/09/22 19:00:19 zaphod Exp zaphod $;
d1787 6
@


1.208
log
@reconfigure option is now more conservative (fixes mplayer)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.207 2003/09/19 05:50:09 zaphod Exp zaphod $;
d161 1
d287 1
d3005 105
d3670 1
@


1.207
log
@mpg123
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.206 2003/09/17 02:58:57 zaphod Exp zaphod $;
a2138 1
      my($notboth) = false; # mozilla
d2151 1
a2151 1
          for $opt (qw[--enable-add-ons --enable-shared --enable-static])
d2153 1
a2153 1
            $confopts{$opt} ||= / \Q$opt\E\b/;
a2154 1
          $notboth ||= /Only one of --enable-shared or --enable-static must /i;
a2160 6

        if($notboth)
        {
          delete($confopts{"--enable-static"});
          delete($confopts{"--enable-shared"});
        }
a2161 1

@


1.206
log
@improved version comparison so that 1.1a < 1.1.1a
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.205 2003/09/16 20:47:02 zaphod Exp zaphod $;
d2329 1
a2331 1
  my($unzip) = false; # blatant special case for unzip
d2337 2
a2340 1
    $unzip ||= /If you're not sure about the characteristics of your system/;
d2347 1
a2349 1
  @@targets = $^O if $unzip;
@


1.205
log
@autofind now ignores version information in freshmeat.net records
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.204 2003/09/16 01:22:30 zaphod Exp zaphod $;
d937 3
a939 1
sub pad40($)
d942 1
d944 8
a951 1
  $len > 40 ? $arg : (' ' x (40 - $len)) . $arg;
d956 2
a957 1
  my($na, $nb) = map { my($x) = $_; $x =~ s/\d+/pad40($&)/ge; $x } ($a, $b);
@


1.204
log
@fixed spurious "can't find consistent URLs" error in toast upgrade
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.203 2003/09/15 22:20:09 zaphod Exp zaphod $;
d1309 1
a1309 1
sub lookslikepkgurl($;$$)
a1317 1
  error unless defined($version);
d1320 1
a1339 1
    $version = $1 if !defined($version) && m!<latest_version>([^<]+)</!;
a1347 1
  defined($version) || error("no version for package $name on $sitename");
d1354 5
a1358 1
  return ($name, $version, $url) if lookslikepkgurl($url);
d1361 15
d1378 1
a1378 1
  for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .rpm])
d1384 1
a1384 1
  error("can't find URLs for $name version $version at $url");
@


1.203
log
@treat .diff files as patches w/r/t order of extraction
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.202 2003/09/15 04:49:20 zaphod Exp zaphod $;
d2832 1
a2832 1
        if(/^\Q$dirname$pre\E($verpat)\Q$post\E(\?.*)?$/)
@


1.202
log
@samba
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.201 2003/09/12 00:52:29 zaphod Exp zaphod $;
d1600 1
a1600 1
  /\.patch\b/i;
@


1.201
log
@add armdir symlink: games -> bin
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.200 2003/09/10 23:09:32 zaphod Exp zaphod $;
d2160 8
@


1.200
log
@deal with acroread
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.199 2003/09/09 22:19:31 zaphod Exp zaphod $;
d2360 7
a2366 1
  ("usr" => ".", "local" => ".", "X11R6" => ".", "share/man" => "../man");
@


1.199
log
@toast demolish and toast purge now accept URLs correctly;
add symlink to armdir: X11R6 -> .
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.198 2003/09/09 01:19:04 zaphod Exp zaphod $;
d2191 1
a2191 1
  for(qw[install.sh])
d2197 10
a2206 2
      my($useprefix);
      whilefile { !($useprefix ||= /--prefix=/) } $script;
@


1.198
log
@added missing newline to "created directory" messages;
toast purge now accepts URLs correctly;
toast arm no longer forces redundant build when given URLs
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.197 2003/09/05 00:08:19 zaphod Exp zaphod $;
d2352 1
a2352 1
  ("usr" => ".", "local" => ".", "share/man" => "../man");
a2890 1
  @@urls && error;
a2898 1
  @@urls && error;
@


1.197
log
@look for install.sh (e.g. Opera)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.196 2003/09/04 02:51:19 zaphod Exp zaphod $;
d1714 1
a1714 1
            print("$myname: created directory $rootdir$dir");
a2474 1
  @@urls && error;
d2679 1
a2679 1
      if @@urls || !isbuilt($name, $version, $build);
@


1.196
log
@support non-gzip .rpm archives
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.195 2003/09/04 00:26:29 zaphod Exp zaphod $;
d2188 17
@


1.195
log
@handle binary packages with spurious parent directories
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.194 2003/09/03 05:08:59 zaphod Exp zaphod $;
d1070 6
d1078 1
a1078 1
  extractstdin(".gz") if forkstdin;
d1084 1
a1084 1
  while(magicstring($_ = readstdin(16 + $pad)) ne ".gz")
a1092 6
}

sub autoextractstdin()
{
  my($buf) = readstdin(magicbufsize);
  forkstdin ? extractstdin(magicstring($buf)) : dumpstdin($buf);
@


1.194
log
@fixed toast change
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.193 2003/09/03 02:41:43 zaphod Exp zaphod $;
d2196 16
a2211 18
  if
  (
    whiledir
    {
      push(@@addons, $_);
      my($abs) = path($dir, $_);
      return false if !-d($abs) || -l($abs);
      my($cfg) = path($abs, "configure");
      if(-x($cfg))
      {
        return true if whilefile { /^\s*(\#|exit|$)/ } $cfg;
        return false if $newdir;
        $newdir = $abs;
        pop(@@addons);
      }
      true;
    } $dir
  )
d2358 1
d2360 10
a2369 2
  abswhiledir(sub { $ok ||= m!/(usr|bin|etc|lib|sbin)$!; -d }, $srcdir) &&
      $ok && mv($srcdir, $rootdir);
@


1.193
log
@"perl - arm foo < toast" should work now
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.192 2003/09/02 18:03:09 zaphod Exp zaphod $;
d3458 1
@


1.192
log
@fixed typo in debugrewrite docs
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.191 2003/09/02 03:31:06 zaphod Exp zaphod $;
d1611 6
@


1.191
log
@debugged/extended command-line parsing; added defaultcmd option
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.190 2003/09/01 22:25:59 zaphod Exp zaphod $;
d4290 6
a4295 7
If B<debugrewrite> is enabled, B<toast build> will always generate
broken builds.  The builds will contain extra debugging information that
can be used to help diagnose problems involving packages that build
correctly outside of B<toast>, but refuse to build or build incorrect
files due to bugs in B<toast>'s path-rewriting mechanism.  This option
currently requires that the (for BSD) or C<strace> program be available
(or C<ktrace> for *BSD).
@


1.190
log
@bend over backwards for netpbm
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.189 2003/08/31 23:25:35 zaphod Exp zaphod $;
d161 1
d211 6
d252 1
a252 1
    exists($optdefault{$name}) || error("no such option: $name");
d3548 1
a3548 3
sub nocmd() { help; }

sub defaultcmd(@@)
d3550 1
d3554 9
a3562 1
  error("no such command: $cmd");
d3567 1
a3567 1
  my($opt);
d3570 1
d3573 1
a3573 1
      setopt($1, $2);
d3575 1
a3575 1
    elsif($opt =~ /^--?no(\w+)$/)
d3577 1
a3577 1
      setopt($1, false);
d3581 2
a3582 6
      my($name, $val) = ($1, @@_);
      if(isboolopt($name) && !(defined($val) && isboolean($val)))
      {
        setopt($name, true);
      }
      elsif(!defined($val))
d3584 3
a3586 5
        error("option $name requires an argument");
      }
      elsif($val =~ /^-/)
      {
        error("option $name requires an argument; found \"$val\" instead");
d3590 18
a3607 2
        setopt($1, $val);
        shift;
d3615 5
a3619 1
  return defined($opt) && $opt eq "--" ? @@_ : ($opt, @@_);
d3624 3
a3626 3
  return nocmd unless @@_;
  my($cmd, @@args) = parseopts(@@_);
  error("no arguments found after options") unless defined($cmd);
d3630 1
a3630 1
  return defaultcmd($cmd, @@args) unless $parser;
d3647 7
d3659 1
a3659 1
  my($result) = cmd(@@_) ? 0 : 1;
d3822 1
a3822 1
B<toast> S<[ I<OPTION> ... ]> I<COMMAND> S<[ I<ARGUMENT> ... ]>
d4133 11
d4347 6
@


1.189
log
@refuse to upgrade packages with version-neutral URLs
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.188 2003/08/31 23:03:34 zaphod Exp zaphod $;
d2288 1
a2288 1
  my(@@trace, $man, $subdir);
d2300 1
d2303 1
d2306 1
d2309 1
@


1.188
log
@added toast change and autochange option
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.187 2003/08/31 20:18:38 zaphod Exp zaphod $;
a2744 2
  my($pkgname) = pkgname($name, $version);

d2750 1
d2762 1
d2802 7
a2808 2
  error("URLs for $pkgname all seem version-neutral and " .
      "autorename is off; aborting") if !defined($version) && !autorename;
a2812 1
    error("can't find alternate version for $pkgname") unless defined($newver);
a2816 8
  if(defined($newver))
  {
    error("$pkgname appears to be the latest available version")
        if $version eq $newver;
    my(@@vers) = sort cmpab ($version, $newver);
    error("only found older versions of $pkgname") if $vers[1] eq $version;
  }

d2830 1
a2830 1
  else # not eligible for autorename
a2831 2
    error("URLs for unstored package $pkgname seem version-neutral; aborting")
        unless defined($newver);
d3857 13
a3869 12
Checks for a later version of an existing package.  The existing package's
URLs are used as a starting point to locate the new version.  If the
filename component of a given URL doesn't appear to contain the package's
version number, that URL will be left unmodified for the new version;
otherwise, the directory portion of the URL will be immediately downloaded
and searched for a similar URL containing a higher version number.
The command fails if a single newer version for all version-containing
URLs cannot be found; otherwise, the highest eligible version is used
for all modified URLs and the package itself.  The command performs an
implicit <add>, B<get>, B<build> or B<arm> on the extrapolated URLs so
as to match the state of the given existing version, except that the
new package will never be armed if the B<autoarm> option is disabled.
@


1.187
log
@toast get no longer chases URLs in a loop (e.g. apache)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.186 2003/08/30 06:47:16 zaphod Exp zaphod $;
d163 1
d1373 12
a1405 1
  my($urlfile) = path($verdir, urlfile);
d1450 1
a1450 1
  writefile($urlfile, map { "$_\n" } @@urls);
d1497 1
a1497 1
    return true unless $redir;
d1507 1
a1507 1
sub autorenamepkg($$)
d1509 23
a1531 1
  my($name, $version) = @@_;
a1532 1
  my($namedir) = pkgpath($name);
d1543 2
a1544 9
    if(defined($newname) && defined($newversion))
    {
      my($newnamedir) = pkgpath($newname);
      my($newverdir) = pkgpath($newname, $newversion);
      optmd($newnamedir);
      mv($verdir, $newverdir);
      rmdir($namedir) && announce("rmdir", $namedir);
      return ($newname, $newversion);
    }
d1568 13
a1580 1
  smartgeturl($_, $tempdir) foreach @@urls;
d1582 2
a1583 1
  ($name, $version) = autorenamepkg($name, $version) if $autorename;
d2960 14
d3439 10
d3489 1
d3911 21
a3944 11
=item S<B<toast rename> I<PACKAGE> ... I<NEWNAME>>

Renames an existing package or set of packages.  The package or packages
must already exist.  I<NEWNAME> uses the same syntax used to refer to
an existing package or build, except that the destination package must
not already exist and must contain the same number of slash characters as
I<PACKAGE>.  Attempting to rename an armed package causes B<toast rename>
to report an error.  Otherwise, renaming a package that contains builds
should be OK, though it could conceivably break ill-behaved packages.
This command can also be used to renumber builds.

d4112 13
d4127 14
a4140 11
When B<autorename> is enabled, B<toast get> may try to use the contents of
the files it downloads to attempt to guess a new name for any implicitly
added package for which no name and/or version number was specified on
the command line or could be guessed from the URLs given.  If this method
results in a new name being guessed, the package is renamed automatically
as if by B<toast rename>, and any further processing continues under
the new name.  If B<autorename> is disabled, packages with unguessed
or partially guessed names always keep the unique names automatically
assigned by B<toast add> based on URLs alone (version number will be
C<unknown> optionally followed by a serial number for uniqueness; name
may have been guessed or may also be C<unknown>).  Default: enabled.
@


1.186
log
@added toast upgrade; exposed (and documented!) autorename option
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.185 2003/08/26 23:21:16 zaphod Exp zaphod $;
d1447 1
a1447 7
  my($url, $dir, $ttl) = @@_;
  $ttl = 5 unless defined($ttl);
  error("too many links: $url") unless $ttl;

  my($basename) = basename(stripquery($url));
  $basename = "index" if $basename eq "";
  my($file) = path($dir, $basename);
d1449 16
a1464 17
  geturl($url, $file);

  local(*FILE);
  open(FILE, "<$file") || error("open $file: $!");
  my($header);
  read(FILE, $header, 128) || error("read $file: $!");
  my($redir);
  if($header =~ /^\<.*\bHTML\b/i)
  {
    seek(FILE, 0, 0) || error("rewind $file: $!");
    my(@@links) = reverse(sort cmpab linksfromstream(*FILE, $url));
    for (@@links)
    {
      $redir = $_ if !$redir && basename(stripquery($_)) eq $basename;
    }
    my($ext);
    for $ext (qw[.tar.bz2 .tar.gz .tgz .zip .rpm])
d1466 2
d1470 11
a1480 1
        $redir = $_ if !$redir && stripquery($_) =~ /\Q$ext\E$/i;
d1483 7
a1490 3
  close(FILE) || error("close $file: $!");

  return true unless $redir;
d1492 1
a1492 2
  rm($file);
  return &smartgeturl($redir, $dir, $ttl - 1);
@


1.185
log
@don't wrap dlopen() under FreeBSD; use ktrace -i for debugrewrite
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.184 2003/08/26 18:47:29 zaphod Exp zaphod $;
d163 1
d1487 1
a1487 1
sub autorename($$)
d1519 1
a1519 1
  my($autorename) = !defined($version);
d1536 1
a1536 1
  ($name, $version) = autorename($name, $version) if $autorename;
d2688 109
d3412 1
d3789 15
d4029 14
@


1.184
log
@allow dashes in autofind package names (e.g. man-pages)
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.183 2003/08/26 18:44:01 zaphod Exp zaphod $;
d1871 2
d2242 1
a2242 1
  @@trace = qw[ktrace -f make.install.ktrace] if @@trace && $^O =~ /bsd/i;
@


1.183
log
@debugrewrite now uses ktrace instead of strace under *BSD
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.182 2003/08/25 23:51:27 zaphod Exp zaphod $;
d1320 1
a1320 1
  $name =~ /^\w+$/ || error("invalid package name: $name");
@


1.182
log
@improved handling of URLs that end in slash and/or point to HTML
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.181 2003/08/25 17:23:59 zaphod Exp zaphod $;
d2238 3
a2240 2
  my(@@strace, $man, $subdir);
  @@strace = qw(strace -s 256 -f -F -o make.install.strace) if debugrewrite;
d2255 1
a2255 1
  cdrun($makedir, @@strace, "make", @@targets);
d4004 7
a4010 6
If B<debugrewrite> is enabled, B<toast build> will always generate broken
builds.  The builds will contain extra debugging information that can be
used to help diagnose problems involving packages that build correctly
outside of B<toast>, but refuse to build or build incorrect files due
to bugs in B<toast>'s path-rewriting mechanism.  This option currently
requires that the C<strace> program be available.
@


1.181
log
@removed autofind debug spew
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.180 2003/08/25 05:06:36 zaphod Exp zaphod $;
d1451 1
d1464 2
a1465 2
    my($link);
    for $link (linksfromstream(*FILE, $url))
d1467 9
a1475 1
      $redir = $link if !$redir && basename(stripquery($link)) eq $basename;
d1480 4
a1483 1
  return $redir ? &smartgeturl($redir, $dir, $ttl - 1) : true;
a2400 1
  $name || error;
@


1.180
log
@greatly improved autofind logic
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.179 2003/08/24 23:48:52 zaphod Exp zaphod $;
a744 5
warn("url = $url");
warn("proto = $proto");
warn("host = $host");
warn("parent = $parent");
warn("link = $link");
a745 1
warn("link = $link");
a746 1
warn("link = $link");
a747 1
warn("link = $link");
a748 1
warn("link = $link");
@


1.179
log
@corrected man page
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.178 2003/08/24 23:44:33 zaphod Exp zaphod $;
d625 1
a625 1
sub openhttpurl(*$)
d628 2
a629 1
  my($url) = @@_;
d635 2
a636 2
  my($request) = "GET $path HTTP/1.0\nHost: $host\nUser-Agent: $uagent\n\n";
  local($_);
d642 18
d735 50
d1309 16
d1346 3
a1348 3
  my($listurl);
  $listurl ||= $fmurl{$_} for qw(bz2 tgz zip rpm);
  $listurl || error("no suitable URL for package $name on $sitename");
d1351 8
a1358 19
  local(*LIST);
  openurl(*LIST, $listurl);
  my(@@urls);
  while(<LIST>)
  {
    while(m!\bhref\s*=\s*"([^"]+)"!gi)
    {
      my($url) = $1;
      next unless $url =~ m!^(http|ftp)://!;
      next if $url =~ m/\#/;
      my($noquery) = stripquery($url);
      next unless $noquery =~ m!\.\w+$!;
      my($basename) = basename($noquery);
      next unless $basename =~ /\Q$name\E/i;
      next unless $basename =~ /\Q$version\E/i;
      push(@@urls, $url);
    }
  }
  close(LIST) || error;
d1367 1
a1367 1
  error("can't find URLs for $name version $version at $listurl");
a1458 3
  $url =~ m!^(\w+:)(//[^/]+)(([^\?]*)/[^/\?](\?|$))?!
      || error("bad url: $url");
  my($proto, $host, $parent) = ($1, $1.$2, $1.$2.undeftoempty($4));
d1472 2
a1473 2
    local($_);
    while(<FILE>)
d1475 1
a1475 11
      while(m!\b(href\s*\=\s*\"?|((http|ftp)://))([^\s\>\"]+)!ig)
      {
        my($link) = join("", undeftoempty($2, $4));
        next if $link =~ /^mailto:/i;

        $link = $proto . $link if $link =~ m!^//!;
        $link = $host . $link if $link =~ m!^/!;
        $link = $parent . $link unless $link =~ m!^(\w+)://!;

        $redir = $link if !$redir && basename(stripquery($link)) eq $basename;
      }
@


1.178
log
@-B doesn't work on filehandles in old versions of perl
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.177 2003/08/24 23:37:53 zaphod Exp zaphod $;
d3655 1
a3655 1
is still running), C<broken> (if it failed), C<broken> (if it succeeded),
@


1.177
log
@parse package names even if storedir doesn't exist
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.176 2003/08/24 23:31:55 zaphod Exp zaphod $;
d1269 1
a1269 1
  if(!-B(LIST))
d1271 1
a1271 1
    while(<LIST>)
d1273 9
a1281 12
      while(m!\bhref\s*=\s*"([^"]+)"!gi)
      {
        my($url) = $1;
        next unless $url =~ m!^(http|ftp)://!;
        next if $url =~ m/\#/;
        my($noquery) = stripquery($url);
        next unless $noquery =~ m!\.\w+$!;
        my($basename) = basename($noquery);
        next unless $basename =~ /\Q$name\E/i;
        next unless $basename =~ /\Q$version\E/i;
        push(@@urls, $url);
      }
@


1.176
log
@more Makefile fixes; work with ancient pod2man
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.175 2003/08/24 23:25:11 zaphod Exp zaphod $;
d345 6
d1104 1
a1104 1
  @@_ && defined($_[0]) ? @@_ : sort cmpab ls(pkgpath);
@


1.175
log
@make toast's Makefile more portable; let toast build under itself
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.174 2003/08/24 22:44:22 zaphod Exp zaphod $;
d3436 1
a3436 1
  $(POD2MAN) $(prog) $(manpage)
d3439 1
a3439 1
  ./$(prog) tarself < $(prog) > $(tarball)
@


1.174
log
@added autofind option; tweaked man page
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.173 2003/08/12 01:00:13 zaphod Exp zaphod $;
d1978 1
d1986 1
d2002 3
a2004 1
      next if $bogus;
d2006 6
a2011 6
      if($notboth)
      {
        delete($confopts{"--enable-static"});
        delete($confopts{"--enable-shared"});
      }
      push(@@confcmd, sort(grep($confopts{$_}, keys(%confopts))));
d2013 12
a2024 11
      if($builddir)
      {
        $confcmd[0] = "../$cfg";
        $dir = path($dir, "$myname-build.d");
        md($dir);
      }
      elsif($cfg eq "configure.gnu")
      {
        # force perl to install files it thinks are already installed
        optpatch { s/^use File::Compare;$/sub compare(\$\$){1}; #$genby/ }
            path($dir, "installperl");
d3433 1
a3433 1
  $(CP) $< $@@
d3436 1
a3436 1
  $(POD2MAN) $< $@@
d3439 1
a3439 1
  ./$< tarself < $< > $@@
@


1.173
log
@provide non-root users with sensible defaults
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.172 2003/08/11 21:05:01 zaphod Exp zaphod $;
d162 1
d1171 6
d1185 2
a1186 1
  return !whilebuild
d1234 59
d1310 6
a1315 1
  @@urls || error;
d1453 1
a1453 1
  ($name, $version) = add(@@_) if @@urls;
d3048 1
a3048 1
    my($name, $version, $build, @@urls, $exists, $multi, $split);
d3053 1
a3053 1
      ($oname, $oversion, $build, $exists) = ($1, $3, $5, !$6);
d3055 1
a3055 1
      if(!$exists)
d3059 1
a3059 1
        @@_ || error("expected file after \"$_\"");
d3064 1
a3064 2
        $exists = false;
        -e || error("no such file or package: \"$_\"");
a3067 1
        defined($name) || error("no such package: $oname");
d3071 1
d3074 1
a3074 1
    if(!$exists)
d3123 24
d3172 1
a3172 1
sub requireurls(@@)
d3177 2
a3178 11
    @@urls || error(pkgname($name, $version) . " already exists");
  }
  @@_;
}

sub rejecturls(@@)
{
  for(@@_)
  {
    my($name, $version, $build, @@urls) = @@$_;
    @@urls && error("unexpected URL: $urls[0]");
d3200 1
a3200 1
    $version = latestversion($name, $version) unless @@urls;
d3212 4
a3215 2
    $version = latestversion($name, $version) unless @@urls;
    $build = latestbuild($name, $version, $build) unless @@urls;
d3223 1
a3223 1
sub parse_add(@@) { rejectempty(requireurls(parse(@@_))); }
d3226 1
a3226 1
sub parse_clean(@@) { allowempty(rejecturls(parse(@@_))); }
d3228 4
a3231 4
sub parse_disarm(@@) { rejectempty(rejecturls(parse(@@_))); }
sub parse_demolish(@@) { rejectempty(rejecturls(parse(@@_))); }
sub parse_purge(@@) { rejectempty(rejecturls(rejectbuilds(parse(@@_)))); }
sub parse_remove(@@) { rejectempty(rejecturls(parse(@@_))); }
d3233 1
a3233 1
sub parse_status(@@) { allowempty(parse(@@_)); }
d3548 7
a3554 6
Adds new packages to the repository by storing URLs.  Use this command to
store package file locations without actually downloading anything.  Each
I<PACKAGE> must specify at least one URL or file; existing package names
are not allowed here.  Absolute and relative pathnames are automatically
translated into file URLs.  If the given package already exists, the
command succeeds only if the given URLs match those stored previously
d3558 4
a3561 2
Downloads the given packages' files into the repository.  If a I<PACKAGE>
specifies a file or URL, B<toast add> is implied.
d3565 8
a3572 8
Creates a new build for one or more packages.  This involves extracting
archives, applying patch files, compiling a new build of the package
and "installing" it in a build-specific directory tree.  Each package
can have any number of independent builds.  Builds for a given package
are automatically assigned sequential numbers starting from 1.  If the
package is not stored, or if URLs are given, B<toast get> is implied.
Many options can influence this command's behavior; see the options
reference for complete details.
d3606 1
a3606 1
Deletes symlinks craated by B<toast arm>.  This works by removing symbolic
d3705 5
a3709 2
This syntax is used to refer to an existing package.  If the version
number is omitted, the latest existing version is used, except when
d3725 8
a3732 5
URL, though certain commands also allow it to be used to refer to
an existing package.  If the package name and version are omitted,
they will be guessed based on the filename in the URL.  Examples:
C<ftp://alpha.gnu.org/gnu/tar/tar-1.13.25.tar.gz>,
S<C<ps/3.1.8: http://procps.sf.net/procps-3.1.8.tar.gz>>.
d3738 3
a3740 3
Unlike a file URL, the path will be checked as soon as it is parsed to
ensure that it refers to a readable file; if it does not, a fatal parse
error will be displayed and the entire command will not be invoked,
d3821 8
@


1.172
log
@link rewrite.so with -ldl under Linux only;
toast build URL for existing broken pkg no longer tries to re-get
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.171 2003/08/11 20:36:42 zaphod Exp zaphod $;
d142 12
d156 3
a158 2
    "storedir" => "/toast",
    "armdir" => "/usr/local",
d160 1
a160 1
    "postarmprog" => "/sbin/ldconfig",
d251 6
a886 10
BEGIN
{
  my($uid, $euid) = ($<, $>);

  sub superuser()
  {
    $uid == 0 || $euid == 0;
  }
}

d3681 4
a3684 3
all packages.  I<STOREDIR> should be given as an absolute path.  B<toast
add> and commands that explicitly invoke it will create I<STOREDIR>
if it doesn't already exist.  Default: C</toast>.
d3692 8
a3699 5
that was used when building that package.  I<ARMDIR> should be given as
an absolute path, and should probably not contain, be contained by, or
be the same as I<STOREDIR>, though these restrictions are not enforced.
It's usually a good idea for I<ARMDIR> to be C</usr> or C</usr/local>
if feasible, since some packages are broken.  Default: C</usr/local>.
d3716 2
a3717 1
the command will also fail.  Default: C</sbin/ldconfig>.
@


1.171
log
@work under perl 5.005_03; don't rely on warnings.pm or strict.pm
@
text
@d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.170 2003/08/10 23:50:48 zaphod Exp zaphod $;
d1797 2
d1801 1
a1801 1
  if(optcdrun($helperdir, @@socc, qw[rewrite.c -ldl -o rewrite.so.helper]))
d2251 1
a2251 1
  ($name, $version) = get(@@_) if @@urls || !isstored($name, $version);
@


1.170
log
@tweaked man page
@
text
@d3 14
a16 7
require 5.6.0;  # eval { open(1,2,3) } if 0;
use strict;     # $^H |= 0x602;
use warnings;   # $^W = 1;

eval('$dummy = 1') && warn("use strict");
{ my($ok); { local $SIG{'__WARN__'} = sub { die }; $ok = !eval('1 + "a"') }
    $ok || warn("use warnings"); }
d38 1
a38 1
my($rcsid) = q$Id: toast,v 1.169 2003/08/09 19:33:29 zaphod Exp zaphod $;
d347 1
a347 1
  mkdir($_) || error("mkdir $_: $!") foreach @@_;
d357 1
a357 1
    if(!mkdir($_))
d448 1
a448 1
  open(FILE, ">", $tempname) || error("open $tempname for write: $!");
d471 1
a471 1
  open(FILE, "<", $file) || error("open $file for read: $!");
d585 1
a585 1
  return true if open(HANDLE, "-|", "$prog @@args");
d631 1
a631 1
  open(HANDLE, "<", $source) || error("open $source for read: $!");
d674 1
a674 1
  open(DEST, ">", $dest) || error("open $dest for write: $!");
d937 1
a937 1
  open(FILE, "<", $file) || error("open $file for read: $!");
d1050 1
a1050 1
    open(STDIN, "<", $infile) || error("open $infile for stdin: $!");
d1075 1
a1075 1
  open(STDIN, "<", $file) || error("open $file: $!");
d1282 1
a1282 1
      $errmsg = mkdir($verdir) ? false : $!;
d1310 1
a1310 1
  open(FILE, "<", $file) || error("open $file: $!");
d1504 1
a1504 1
        $dir ne "" && mkdir("$rootdir$dir") &&
d2263 1
a2263 1
    $errmsg = mkdir($builddir) ? false : $!;
d2301 1
a2301 1
  open(LOG, ">", $tmplogname) || error("open $tmplogname for write: $!");
d2410 1
a2410 1
    open(LOCK, "<", $path) || error("open $path: $!");
d2746 1
a2746 1
  open(SCRIPT, "<", $file) || error("open $file for read: $!");
d2873 1
a2873 1
    return false unless open(PAGER, "|-", $pager);
@


1.169
log
@fixed make dist bug: strip leading 0 from date components to force decimal
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.168 2003/08/09 02:32:50 zaphod Exp zaphod $;
d3484 1
a3484 1
under a directory such as F</usr/local>.  Existing links to other builds
d3487 7
a3493 9
reported by B<toast status>) before it can be armed.

If no explicit build number is supplied on the command line, this
command implicitly creates a new build (as if by B<toast build>) if the
package has no builds, or arms the latest B<built> build if such a build
exists and was created later (numbered higher) than the latest C<armed>
build for that package (if any).  If the latest build is already armed,
the command fails; you probably meant to invoke B<toast build> with the
C<autoarm> option set.
d3570 12
a3581 13
the C<toast> man page to be installed.

If standard output is a tty, the man page is formatted using
C<Pod::Text::Overstrike>, C<Pod::Termcap>, C<Pod::Text> or the rudimentary
internal formatting routine used by B<toast help>, and the formatted page
is piped to C<$MANPAGER>, C<$PAGER>, C<less -ir>, or C<more>, or dumped
directly to the terminal as a last resort.  If output is redirected to a
file or pipe, the man page is rendered as plain text using C<Pod::Text>
if available or the internal routine otherwise.  If you want more control
over the output, try feeding the C<toast> script itself to S<C<pod2text>>,
C<pod2html>, C<pod2man>, or C<pod2latex>, all of which are command-line
utilities that accepts lots of exciting switches and things and that
come bundled with recent versions of Perl.
d3648 4
a3651 4
Every command that accepts one package as an argument will also take
several packages, so multiple files or URLs will always be treated
as distinct packages unless they are explicitly grouped into a single
package using square brackets as shown above.  For instance,
d3840 13
a3852 12
The configuration file.  If option I<NAME> has not been assigned a value
through any of the above methods, its value will be taken from a line of
the form I<NAME>=I<VALUE>, if such a line exists, in C<$HOME/.toast/conf>,
if that file exists.  (C<$HOME> specifically represents the value
of the C<HOME> environment variable.)  I<NAME> is case-insensitive
in this context.  Any whitespace before or after I<NAME> or I<VALUE>
will be ignored, as will blank lines, lines containing only whitespace,
and lines with B<#> as their first non-whitespace character.  If the file
exists but cannot be read or contains invalid syntax, an invalid I<NAME>,
or an illegal I<VALUE> for a boolean option (an explicit value must be
given; see item 1 for allowed forms), B<toast> will normally give an
error message at startup and refuse to execute any commands.
@


1.168
log
@add + to version number for my checked-out copy (may contain changes);
rejigger make dist so it's easier for me to snarf tarballs from toast,v
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.167 2003/08/07 06:18:52 zaphod Exp zaphod $;
d3341 2
d3346 1
a3346 1
  my($yr, $mo, $day, $hr, $min, $sec) = ($1, $2-1, $3, $4, $5, $6);
@


1.167
log
@turned all options representing pathname components or suffices into
constants; renamed debug option to debugrewrite; overhauled man page
@
text
@d31 2
a32 2
my($rcsid) = q$Id: toast,v 1.166 2003/08/07 02:14:55 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\S+) (\S+ \S+) (\S+)/ || error;
d34 1
d3301 1
d3317 1
d3327 3
d3335 1
a3335 2
dist: $(prog)
  ./$< tarself
d3375 1
a3375 1
  rejectall(@@_);
a3378 2
  my($ofile) = "$tarfile.gz";
  explain("creating $ofile");
d3385 1
a3385 4
    local(*SELF);
    selfopen(*SELF);
    my($contents) = join('', (<SELF>));
    close(SELF) || error("close self: $!");
a3396 2
    local(*TGZ);
    open(TGZ, ">", "$namever.tar.gz") || error("open $ofile: $!");
d3403 2
a3404 5
    error("write $ofile: $!") unless print TGZ
        pack("a2 C C L C C Z* Z*", $id, $cm, $flg, $mtime, $xfl, $os,
        $tarfile, $myname);
    error("write $ofile: $!") unless print TGZ (<GZIP>);
    close(TGZ) || error("close $ofile: $!");
@


1.166
log
@improved toast man
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.165 2003/08/06 22:41:32 zaphod Exp zaphod $;
a135 2
    "verbose" => true,
    "username" => "toast",
d138 1
a138 11
    "pkgdir" => "pkg",
    "archivedir" => "archive",
    "urlfile" => "url",
    "srcdir" => "src",
    "helperdir" => "helpers",
    "rootdir" => "root",
    "buildlog" => "build.log",
    "brokenlog" => "broken.log",
    "offsuffix" => ".off",
    "tmpsuffix" => ".tmp",
    "baksuffix" => ".orig",
d140 1
d153 1
a153 1
    "debug" => false
d247 14
d1529 1
a1529 1
  $defdebug = "/* $defdebug */" unless debug;
d2076 1
a2076 1
  @@strace = qw(strace -s 256 -f -F -o make.install.strace) if debug;
d2092 1
a2092 1
  error("trace complete; aborting") if debug;
d3445 2
a3446 2
Adds new packages to the repository by storing URLs.  Use this command
to store package file locations without actually downloading them.  Each
d3450 1
a3450 1
command succeeds if the given URLs match those stored previously
d3465 2
a3466 2
More than half of the documented options affect this command's behavior;
see the options reference for complete details.
d3470 12
a3481 11
Deletes and intermediate files created by B<toast build>.  Cleaning a
broken build removes the build entirely; otherwise only files that are not
required by B<toast arm> are removed from the build.  These typically
consist of files created directly by B<toast> as part of the build
environment, extracted source files, and intermediate files created
by the package itself during compilation.  The B<toast build> command
may perform this step automatically for some kinds of binary packages
that do not involve intermediate files, as well as for other packages
if the B<autoclean> option is enabled.  Only builds that are not in
the C<building> state (as reported by B<toast status>) may be cleaned.
If no arguments are given, all eligible builds are cleaned.
d3510 7
a3516 6
Deletes one or more builds.  If one of the builds to be ddemolished
is currently armed and the B<autodisarm> option is disabled, B<toast
demolish> reports an error and no builds are deleted; otherwise, B<toast
disarm> is implied.  Demolishing a package reverses the effects of B<toast
build> (and, optionally, B<toast arm>), but never those of B<toast get>
or B<toast add>.
d3520 2
a3521 2
Deletes files downloaded by B<toast get>.  Deletes toast's local copy
of the original archive used to build the given package or packages.
d3559 1
a3559 1
=item S<B<toast help> [ I<COMMAND> ] ...>
d3563 5
a3567 4
If invoked with arguments, displays a longer summary of the given
commands.  If B<toast> itself is invoked without any arguments, B<toast
help> is assumed.  Note that the information displayed by this command
is parsed directly from the same source used by B<toast man>.
d3571 17
a3587 9
Displays the complete B<toast> man page.  You're either reading the
man page now, or reading something that was derived from it (such as
the output of B<toast help>).  If standard output is a terminal and
the C<Pod::Text::Termcap> Perl module is installed, the output will
be formatted using additional attributes such as bold and underline.
Otherwise, if C<Pod::Text> is installed, the output is formatted as
plain text.  If the appropriate C<Pod::I<foo>> module is not available
for some bizarre reason, the rudimentary internal formatting routines
used by B<toast help> will be borrowed to format the entire page.
d3591 6
a3596 1
=head2 Options
d3600 53
a3652 1
=item S<B<--verbose> | B<--noverbose>>
d3654 7
a3660 3
Enables or disables verbose command output.  When disabled, most commands
will produce output only on failure.  Some commands, such as B<toast
status>, are not affected by this flag.  Default: enabled.
d3662 1
a3662 1
=item B<--username=>I<USER>
d3664 1
a3664 5
When invoked as root, B<toast build> will unpack, compile, and "install"
packages under I<USER>'s UID and GID as returned by C<getpwnam(3)>.
Note that any additional groups (such as those in C</etc/groups>) will
be ignored, as will I<USER>'s password, home directory, shell, and so on.
Default: C<toast>.
d3685 8
d3702 6
d3808 1
a3808 46
=back

=head1 SYNTAX

=head2 Commands

Allowed forms should be I<COMMAND>, B<->I<COMMAND>, and B<-->I<COMMAND>.
Commands should be case-insensitive.  However, as I write this, commands
are case-sensitive (all lowercase) and may not be preceded by any dashes.

=head2 Arguments

Most commands accept one or more arguments denoting packages or builds.
Such arguments usually follow one or more of the forms below.  Note that
not all commands accept all forms.

=over 4

=item I<NAME>[B</>I<VERSION>]

This syntax is used to refer to an existing package.  If the version
number is omitted, the latest existing version is used, except when the
documentation for the command specifically says otherwise.

=item I<NAME>B</>I<VERSION>B</>I<BUILDNUM>

This syntax is used to refer to an existing build of an existing
package.  Most commands don't accept individual builds as arguments; the
documentation for those commands that do accept builds say so explicitly.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] I<URL>>

This syntax is used to implicitly add a new package by URL.  If the
package name and version are omitted, they will be guessed based on
the filename in the URL.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] I<PATH>>

This syntax is used to add a new package from a local file.  The given
path is automatically translated into an absolute file URL.  Unlike a
URL, the path will be checked as soon as it is parsed to ensure that it
refers to a readable file; if it does not, a fatal parse error will be
displayed and the entire command will not be invoked, even if previous
arguments were parsed without error.

=item S<[ I<NAME>B</>I<VERSION>B<:> ] B<[> I<URL> | I<PATH> ... B<]>>
d3810 6
a3815 7
This syntax is used to add a package that requires multiple URLs and/or
local files by grouping them between literal square brackets.  As with
the previous two forms, the name and version number may be omitted,
in which case they will be guessed from the given filenames.  If the
filenames are very dissimilar, only the first will be used to guess the
package name and version number.  Otherwise, the order of URLs and/or
paths is not significant.
d3819 2
a3820 3
=head2 Options

Option values are taken from one of the following sources:
d3826 9
a3834 8
On the command line.  All options support standard
B<-->I<NAME>B<=>I<VALUE> and S<B<-->I<NAME> I<VALUE>> syntax.  For boolean
options, I<VALUE> can be B<true>, B<yes>, B<on>, B<enabled>, or B<1>
to enable the option or B<false>, B<no>, B<off>, B<disabled>, or B<0>
to disable it.  Alternately, B<-->I<NAME> can be used to enable a boolean
option or B<--no>I<NAME> to disable it.  In all cases, the leading double
dash (B<-->) may be replaced by a single dash (B<->), and I<NAME> is
case-insensitive (as is the B<no> prefix used to disable boolean options).
d3838 5
a3842 4
In the environment.  If option I<NAME> is not given a value on the
command line, will be read from the environment variable B<TOAST_>I<NAME>
(all uppercase) if it exists.  Note that environment variables whose
names contain lowercase letters will be silently ignored!
d3846 12
a3857 12
From a configuration file.  If option I<NAME> has not been assigned
a value through any of the above methods, its value will be taken
from a line of the form I<NAME>=I<VALUE>, if such a line exists, in
C<$HOME/.toast/conf>, if that file exists.  (C<$HOME> specifically
represents the value of the C<HOME> environment variable.)  I<NAME> is
case-insensitive in this context.  Any whitespace before or after I<NAME>
or I<VALUE> will be ignored, as will blank lines, lines containing only
whitespace, and lines with B<#> as their first non-whitespace character.
If the file exists but cannot be read or contains invalid syntax,
an invalid I<NAME>, or an illegal I<VALUE> for a boolean option (see
item 1), B<toast> will normally give an error message at startup and
refuse to execute any commands.
d3861 2
a3862 67
From a built-in default value.  See the full list of options elsewhere
in this document for the specific default value used for each option.

=back

=head1 EXAMPLES

=over 4

=item B<toast add http://download.ofb.net/gale/gale-0.99egg.tar.bz2>

Adds a new entry in the package repository with name C<gale> and version
number C<0.99egg>.  The newly added entry will contain the given URL
and very little else.  Note that this command does not access the web
site in question and will succeed even if the web site is down or the
filename is misspelled.

=item B<toast get ssh://foo/bar-3.1.tgz ftp://gnu.org/bc-1.06.tar.gz>

Adds and gets two distinct packages, C<bar/3.1> and C<bc/1.06>, using the
C<ssh> and C<ftp> protocols.  If a package C<bc/1.06> already exists,
the command will fail and no entries will be created.  If C<gnu.org>
is not a valid FTP site, but everything else is in order, the command
will first add package C<bar/3.1>, then retrieve F<bar-3.1.tgz> using
the C<scp> command, then add package C<bc/1.06>, then attempt to download
F<bc-1.06.tar.gz> and issue an error message when the download fails.

=item B<toast add less-358.tar.gz libjpeg-6a.tar.gz make-3.79.1.tar.gz>

Adds three different packages.  Because this command gives local file
paths rather than URLs, the command will fail without adding any packages
unless all three files exist and are readable.  Assuming the files exist,
each package entry will contain an absolute file URL that points into
the current directory.  The files themselves will not be copied into
the package repository until they are needed.

=item B<toast build [ linux-2.4.18.tar.gz linux-2.4.18.tar.gz.sign ]>

Adds, gets, and builds a single package C<linux/2.4.18> from two files:
a source archive and a PGP signature for the archive.  The signature
will be checked before the archive is uncompressed.

=item B<toast arm [ popa3d-0.5.1.tar.gz popa3d-0.5.1-linux.patch ]>

Adds, downloads, gets and arms a single package C<popa3d/0.5.1> from a
compressed source archive and a patch file.  The patch will be applied
after the archive is uncompressed.

=item B<toast add m4-1.4.tar.gz [ bind-8.2.5-{src,doc}.tar.gz ]>

Adds two packages: C<m4/1.4> (one file) and C<bind/8.2.5> (two files).
This example assumes the use of the Bourne shell or one of its variants.
Most such shells do not require any special quoting for the square
brackets in the above example.  However, the shell would likely have
become confused if the spaces just inside the square brackets had been
omitted.

=item B<toast add midimod/4.2.5: mm.zip XFree86/4.10: [ X410src-[123].tgz ]>

Adds two packages with explicit names.  XFree86 comes in three parts;
C<[123]> is a glob pattern expanded by the shell.

=item B<toast arm XFree86>

Finds an existing entry in the package repository with the name C<XFree86>
and arms the package, first getting and building it if necessary.  If more
than one version of XFree86 has been added, only latest version is armed.
d3872 8
a3879 1
# other ideas:
d3891 1
@


1.165
log
@check RCS Id tag; improve toast help; fix showurls documentation
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.164 2003/08/06 06:04:24 zaphod Exp zaphod $;
d2825 1
a2825 1
sub tryman($)
d2827 7
a2833 10
  my($type) = @@_;
  $type =~ /^[\w\:]+$/ || error("bad parser: $type");
  my($parser) = eval("use IO::Handle; use Pod::$type; Pod::$type->new()");
  return false unless $parser;

  local(*SCRIPT);
  selfopen(*SCRIPT);
  $parser->parse_from_filehandle(*SCRIPT);
  close(SCRIPT) || error;
  true;
d2836 1
a2836 1
sub fakeman()
d2838 2
a2839 1
  local(*SCRIPT);
d2848 1
d2850 21
d2875 6
a2880 1
  -t(STDOUT) && tryman("Text::Termcap") || tryman("Text") || fakeman;
@


1.164
log
@more man page revisions: overall description and individual commands
@
text
@d31 3
a33 3
my($rcsid) = q$Id: toast,v 1.163 2003/08/06 02:20:08 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\d+\.\d+) (\S+ \S+)/ || error;
my($myname, $myversion, $mytimestamp) = ($1, $2, $3);
d36 1
d2752 3
d2767 2
d2770 2
a2771 3
  my($on, $cmd, @@cmds, %head, %body);
  while(<SCRIPT>) { last if /^=head\d commands$/i }
  while(<SCRIPT>)
d2773 2
a2774 2
    last if /^=(back|cut)/;
    if(/^=item .*\Q$myname\E (\w+)/)
d2776 15
a2790 6
      $head{$cmd = $1} .= $_;
      push(@@cmds, $cmd) unless $body{$cmd};
    }
    else
    {
      $body{$cmd} .= $_ if $cmd;
d2795 16
a2810 4
  print($head{$_} ? depodify($head{$_} . $body{$_}) : "no such command: $_\n")
      foreach @@_;

  if(!@@_)
d2812 2
a2813 10
    $usage =~ /^\s*(\S.*\S)\s*$/ || error;
    print("usage:\n\n  ", depodify($1),
        "\n\nwhere *COMMAND* is one of the following words:\n\n");
    my($maxcmdlen) = max(map { length } @@cmds);
    for(@@cmds)
    {
      $body{$_} =~ /\w[^\.]+\./;
      print("  $_  ", " " x ($maxcmdlen - length), depodify($&), "\n");
    }
    print("\nFor command usage:  $myname help *COMMAND*\n\n");
d2815 2
d2818 3
a2820 1
  true;
d3691 1
a3691 1
=item S<B<--ignorecase> | B<--noignorecase>>
@


1.163
log
@added option descriptions to man page; reorganized and tweaked a bit
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.162 2003/08/05 21:52:21 zaphod Exp zaphod $;
d3384 4
a3387 3
traditional package-management systems, B<toast> is intended to work
directly with software distributed as source code, rather than in some
precompiled or specialized binary format, such as RPM.
d3396 5
a3400 4
to store package file locations without actually downloading them.
Each I<PACKAGE> must specify at least one URL or file; existing package
names are not allowed here.  Absolute and relative pathnames are
automatically translated into file URLs.
d3405 1
a3405 2
specifies a file or URL, the package will be implicitly added as if by
B<toast add>.
d3407 1
a3407 1
=item S<B<toast build> [ I<PACKAGE> ... ]>
d3410 21
a3430 6
archives, applying patch files, compiling a new build of the package and
"installing" it in a build-specific directory tree.  Each package can
have any number of independent builds.  Builds for a given package are
automatically assigned sequential numbers starting from 1.  If no packages
are specified, a build will be created for each existing package that
has been downloaded by B<toast get> but does not yet have any builds.
d3432 1
a3432 5
=item S<B<toast clean> I<BUILD> | I<PACKAGE> ...>

Deletes intermediate files created by B<toast build>.

=item S<B<toast arm> [ I<BUILD> | I<PACKAGE> ] ...>
d3441 7
a3447 7
If no explicit build number is supplied on the command line, this command
implicitly creates a new build (as if by B<toast build>) if the package
has no builds, or arms the latest B<built> build if such a build exists
and was created later than the latest C<armed> build for that package
(if any).  If no packages are specified on the command line at all,
the latest C<built> build of every package that has at least one such
build but no C<armed> builds will be armed.
d3459 6
a3464 4
Deletes one or more builds.  If one of the builds to be deleted is
currently armed, B<toast demolish> reports an error and no builds are
deleted.  Demolishing a package deletes all of its builds, but does not
remove the package itself.
d3470 3
a3472 1
Existing builds are not affected by this command.
d3476 6
a3481 5
Deletes a build, a package, or a set of packages.  Removing a build
has the same effect as B<toast demolish>.  Removing a package deletes
all of its builds and additionally reverses the effects of B<toast get>
and B<toast add>.  If any of the builds to be deleted is currently armed,
B<toast remove> reports an error and nothing is removed.
d3486 20
a3505 15
arguments, displays information about all packages and builds.

Each build can be in one of four states: C<building>, C<built>, C<broken>,
or C<armed>.

=item S<B<toast rename> I<PACKAGE> I<NEWNAME>>

Renames an existing package.

=item S<B<toast check>>

Checks the integrity of the package repository.  Also checks the directory
containing the forest of symlinks created by B<toast arm>.  Reports any
problems found, but takes no other action.  This command isn't done yet,
and probably shouldn't be listed here until it's ready.
d3518 4
a3521 2
Displays the complete B<toast> man page.  If standard output is a terminal
and the C<Pod::Text::Termcap> Perl module is installed, the output will
@


1.162
log
@added dist target to Makefile
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.161 2003/08/05 01:40:01 zaphod Exp zaphod $;
d3378 1
a3378 1
B<toast> I<COMMAND> S<[ I<ARGUMENT> ... ]>
d3482 2
a3483 1
problems found, but takes no other action.
d3500 3
a3502 2
plain text.  If the appropriate C<Pod::I<foo>> module is not available,
a rudimentary internal formatting routine will be used instead.
d3506 156
d3706 46
@


1.161
log
@replaced bootstrap command with GNU configure script emulator
@
text
@d31 3
a33 3
my($rcsid) = q$Id: toast,v 1.160 2003/07/30 21:20:14 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\d+\.\d+) (\S+)/ || error;
my($myname, $myversion, $mydate) = ($1, $2, $3);
d3278 3
d3282 81
@


1.160
log
@properties are now known as options and have a different syntax and
stricter type checking; also move some tangentially related code around
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.159 2003/07/28 04:46:50 zaphod Exp zaphod $;
a2837 67
sub bootstrap(@@)
{
  my($filename) = @@_;
  my($basename) = basename($filename);
  if($basename eq "configure")
  {
    print "#!/bin/sh\n# $genby" . q[

for perl in /usr/bin/perl perl perl5; do
  echo "$0: checking $perl"
  if $perl -e 'require 5.6.0'; then
    exec $perl -x $0 "$@@"
  fi
done

echo "$0: giving up"
exit 1

#!perl

print("$0: using perl $^X\n");

my($prefix, $arg);
while(defined($arg = shift))
{
  $arg =~ /^--?prefix$/ ? ($prefix = shift) :
      $arg =~ /^--?prefix=(.*)$/ ? ($prefix = $1) :
      print("$0: ignoring argument $arg\n");
}

$prefix = "/usr" unless defined($prefix);
print("$0: using prefix $prefix\n");

system

];
  }
  elsif($basename eq "Makefile")
  {
    my($targets) = "configure Makefile $myname.1 $myname.html";
    print qq[# $genby

prefix = /usr
exec_prefix = \$(prefix)
bindir = \$(exec_prefix)/bin
mandir = \$(prefix)/man
man1dir = \$(mandir)/man1

DESTDIR =

targets = $targets

all: \$(targets)

\$(targets): $myname
\t./$myname bootstrap make \$@@

install: $myname $myname.1
\tmkdir -p \$(DESTDIR)\$(bindir) \$(DESTDIR)\$(man1dir)
\tcp $myname \$(DESTDIR)\$(bindir)/$myname
\tcp $myname.1 \$(DESTDIR)\$(man1dir)/$myname.1
];
  }
}

##############################################################################

a3079 1
sub parse_bootstrap(@@) { allowall(@@_); }
d3217 67
a3283 1
main(@@ARGV);
a3416 6

=item S<B<toast bootstrap> B<configure> | B<make> I<FILE> ...>

Generates a file from the B<toast> distribution.  The final pathname
component of each I<FILE> must be one of B<configure>, B<Makefile>,
B<toast.1>, B<toast.html>, B<toast.txt>, or B<README>.
@


1.159
log
@locking in toast get seems to be broken; don't bother for now
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.158 2003/07/27 00:26:00 zaphod Exp zaphod $;
d42 72
d133 1
a133 1
  my(%propdefault) =
d166 1
a166 1
  sub envprop($)
d171 19
a189 1
  my(%proploaded);
d191 1
a191 1
  sub loadprop($)
d194 9
a202 2
    return $proploaded{$name} if %proploaded;
    $proploaded{1} = 1;
d216 5
a220 3
      $propdefault{$name} ||
          error("$dotfile: line $.: unknown property name \"$name\"");
      $proploaded{$name} = $val;
d223 1
a223 1
    $proploaded{$name};
d226 1
a226 1
  my(%propcurrent);
d228 1
a228 1
  sub setprop($$)
d231 11
a241 4
    defined($propdefault{$name}) || error("no such property: $name");
    my($result) = $propcurrent{$name};
    $propcurrent{$name} = $val;
    $result;
d244 1
a244 1
  sub getprop($)
d247 3
a249 5
    my($val) = $propcurrent{$name};
    return $val if defined($val);
    $val = envprop($name) || loadprop($name) || $propdefault{$name};
    setprop($name, $val);
    $val;
d252 1
a252 1
  checkedeval("sub $_() { getprop('$_') }") foreach keys(%propdefault);
a268 71
sub max(@@)
{
  my($result);
  for(@@_)
  {
    $result = $_ if !defined($result) || $result < $_;
  }
  $result;
}

sub min(@@)
{
  my($result);
  for(@@_)
  {
    $result = $_ if !defined($result) || $result > $_;
  }
  $result;
}

##############################################################################

sub emptytoundef(@@) { map { defined($_) && $_ eq "" ? undef : $_ } @@_; }
sub undeftoempty(@@) { map { defined($_) ? $_ : "" } @@_; }

sub dirname($) { my($arg) = @@_; $arg =~ s|/[^/]*$|| ? $arg : "."; }
sub basename($) { my($arg) = @@_; $arg =~ s|.*/||g; $arg; }
sub stripext($) { my($arg) = @@_; $arg =~ s/(\.tar)?(\.[a-z]\w*)?$//i; $arg; }
sub stripquery($) { my($arg) = @@_; $arg =~ s/\?.*$//; $arg; }

sub samelist(\@@\@@)
{
  my($x, $y) = @@_;
  my($size) = scalar(@@$x);
  return false if $size != scalar(@@$y);
  return true unless $size > 0;
  for(0..$size-1)
  {
    my($vx, $vy) = ($$x[$_], $$y[$_]);
    my($dx, $dy) = map { defined($_) ? 1 : 0 } ($vx, $vy);
    return false if $dx != $dy || $dx & $vx ne $vy;
  }
  return true;
}

sub path(@@)
{
  defined($_) || error("undefined path component in @@_") foreach @@_;
  local($_) = join("/", @@_);
  m|//| && error("double slash in path(@@_): $_");
  m|/$| && error("final slash in path(@@_): $_");
  $_;
}

sub optpath(@@)
{
  path(grep { defined($_) && $_ ne "" } @@_);
}

sub unpath($)
{
  my($path) = @@_;
  $path =~ s|^/|| || error;
  $path =~ m|^/| && error;
  $path =~ m|/$| && error;
  $path =~ m|//| && error;
  return split(/\//, $path);
}

##############################################################################

d749 1
d756 1
d763 1
d2269 1
a2269 1
    setprop("verbose", true);
d3207 42
d3252 2
a3253 3
  my($cmd);
  setprop($1, $2) while ($cmd = shift) && $cmd =~ /^(\w+)=(.*)$/;
  error("no arguments found after property assignments") unless defined($cmd);
d3255 1
a3255 1
  return &$cmdsub(@@_) if $cmdsub;
d3257 1
a3257 1
  return defaultcmd($cmd, @@_) unless $parser;
d3261 1
a3261 1
  for(&$parser(@@_))
@


1.158
log
@added "verbose" flag which now defaults to false
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.157 2003/07/27 00:12:34 zaphod Exp zaphod $;
a1336 1
  lock($tempdir);
a1338 1
  unlock($tempdir);
@


1.157
log
@try to make toast get retry if first attempt fails
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.156 2003/07/26 03:12:09 zaphod Exp zaphod $;
d39 20
d61 32
a92 1
  my($verbose) = 1;
d94 1
a94 1
  sub explain(@@)
d96 1
a96 1
    print("# @@_\n") if $verbose;
d99 3
a101 1
  sub announce(@@)
d103 22
a124 1
    print("@@_\n") if $verbose;
d127 3
a129 1
  sub setverbose($)
d131 4
a134 2
    my($result) = $verbose;
    $verbose = !!$_[0];
d137 24
a186 3
sub true() { 1 }
sub false() { "" }

d323 6
d332 6
a337 1
  unlink || error("rm $_: $!") foreach @@_;
d344 1
a344 2
  rmdir || error("rmdir $_: $!") foreach @@_;
  true;
d351 1
a351 3
  my($oldverbose) = setverbose(false);
  dfs($_, sub { true }, sub { rm($_) }, sub { rd($_) }) foreach @@_;
  setverbose($oldverbose);
a646 108
sub checkedeval($)
{
  my($code) = @@_;
  my($result) = eval($code);
  if($@@)
  {
    local($_) = $code;
    s/\s+/ /g;
    error($@@, $_);
  }
  $result;
}

##############################################################################

BEGIN
{
  my(%propdefault) =
  (
    "username" => "toast",
    "storedir" => "/toast",
    "armdir" => "/usr/local",
    "pkgdir" => "pkg",
    "archivedir" => "archive",
    "urlfile" => "url",
    "srcdir" => "src",
    "helperdir" => "helpers",
    "rootdir" => "root",
    "buildlog" => "build.log",
    "brokenlog" => "broken.log",
    "offsuffix" => ".off",
    "tmpsuffix" => ".tmp",
    "baksuffix" => ".orig",
    "postarmprog" => "/sbin/ldconfig",
    "autoclean" => true,
    "autopurge" => false,
    "autoarm" => true,
    "autodisarm" => true,
    "autodemolish" => true,
    "autoremove" => false,
    "crossversion" => false,
    "strictpreload" => true,
    "reconfigure" => true,
    "stoponerror" => true,
    "ignorecase" => true,
    "showurls" => true,
    "debug" => false
  );

  sub envprop($)
  {
    $ENV{uc("${myname}_$_[0]")};
  }

  my(%proploaded);

  sub loadprop($)
  {
    my($name) = @@_;
    return $proploaded{$name} if %proploaded;
    $proploaded{1} = 1;
    local(*DOTFILE, $_);
    return unless $ENV{HOME};
    my($dotfile) = "$ENV{HOME}/.$myname/conf";
    return unless -e($dotfile);
    open(DOTFILE, $dotfile) || error("open $dotfile for read: $!");
    while(<DOTFILE>)
    {
      s/^\s+//;
      s/\s+$//;
      next if $_ eq "" || /^\#/;
      /^([^\=]*?)\s*\=\s*(.*)$/ ||
          error("$dotfile: line $.: missing \"=\"");
      my($name, $val) = ($1, $2);
      $propdefault{$name} ||
          error("$dotfile: line $.: unknown property name \"$name\"");
      $proploaded{$name} = $val;
    }
    close(DOTFILE) || error("close $dotfile for read: $!");
    $proploaded{$name};
  }

  my(%propcurrent);

  sub setprop($$)
  {
    my($name, $val) = @@_;
    defined($propdefault{$name}) || error("no such property: $name");
    my($result) = $propcurrent{$name};
    $propcurrent{$name} = $val;
    $result;
  }

  sub getprop($)
  {
    my($name) = @@_;
    my($val) = $propcurrent{$name};
    return $val if defined($val);
    $val = envprop($name) || loadprop($name) || $propdefault{$name};
    setprop($name, $val);
    $val;
  }

  checkedeval("sub $_() { getprop('$_') }") foreach keys(%propdefault);
}

##############################################################################

d2233 1
d2235 1
d2261 1
a2261 1
    print("  $_\n");
@


1.156
log
@attempted fix for spurious rename failures
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.155 2003/07/26 02:43:37 zaphod Exp zaphod $;
d1337 2
a1338 1
  md($tempdir);
d1341 1
@


1.155
log
@added postarmprog (runs /sbin/ldconfig on arm/disarm);
fixed some stray whitespace
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.154 2003/07/26 00:09:22 zaphod Exp zaphod $;
d2590 3
a2592 1
  ($dname, $dversion, $dbuild);
@


1.154
log
@build from Imakefile
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.153 2003/07/24 04:07:23 zaphod Exp zaphod $;
d573 1
d871 1
a871 1
  local($_) = @@_; 
d1491 1
a1491 1
  
d1669 1
a1669 1
  
d2004 1
a2004 1
  my($ok) = true; 
d2183 1
a2183 1
  
d2415 2
d2472 2
d2583 1
a2583 1
      
@


1.153
log
@added flags: autoarm, autodemolish, autoremove, crossversion
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.152 2003/07/21 03:12:03 zaphod Exp zaphod $;
d1902 4
@


1.152
log
@sub configure was rejecting gcc's configure script as bogus; fixed
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.151 2003/07/21 00:08:16 zaphod Exp zaphod $;
d575 5
a579 1
    "autodisarm" => false,
d2292 15
d2411 13
@


1.151
log
@added autodisarm flag (disabled by default)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.150 2003/07/20 04:48:37 zaphod Exp zaphod $;
d1851 1
a1851 1
        $bogus ||= /There is no .{0,3}\bconfigure\b.{0,3} script /i; # libpng
@


1.150
log
@toast status was flagging spurious url mismatch when no urls were given
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.149 2003/07/19 05:42:47 zaphod Exp zaphod $;
d575 1
d2440 10
d2455 1
a2455 2
  isarmed($name, $version, $build) &&
      error(pkgname($name, $version, $build) . " is armed");
a2462 1
  isarmed(@@_) && error(pkgname($name, $version, $build) . " is armed");
@


1.149
log
@most commands are now much more tolerant of being fed urls
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.148 2003/07/19 04:44:30 zaphod Exp zaphod $;
d2493 2
a2494 2
        my($mismatch) =
            samelist(@@haveurls, @@urls) ? "" : " differ from those specified";
@


1.148
log
@added showurls flag (now enabled by default)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.147 2003/07/19 02:38:29 zaphod Exp zaphod $;
d96 15
d1164 12
d1190 1
d1194 19
a1212 1
    md($verdir);
a1234 1
  my($urlfile) = path($verdir, urlfile);
d1325 2
a1327 1
  my($urlfile) = path($verdir, urlfile);
a1330 1
  @@urls = map { chomp; $_ } readfile($urlfile) unless @@urls;
d2479 1
a2479 1
  @@urls && error;
d2490 1
a2490 1
      if(showurls)
d2492 5
a2496 2
        my($urlfile) = path(pkgpath($name, $version), urlfile);
        if(-r($urlfile))
d2498 2
a2499 2
          print("    urls:\n");
          print("      $_") foreach readfile($urlfile);
d2511 1
a2511 1
  return true;
d3054 1
a3054 1
sub parse_status(@@) { allowempty(rejecturls(parse(@@_))); }
@


1.147
log
@added ignorecase flag (defaults to on)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.146 2003/07/19 02:03:45 zaphod Exp zaphod $;
d564 1
d2444 10
@


1.146
log
@turned some stray calls to die() into calls to error()
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.145 2003/07/16 03:32:27 zaphod Exp zaphod $;
d563 1
d2792 28
d2830 3
a2832 1
      ($name, $version, $build, $exists) = ($1, $3, $5, !$6);
d2835 1
a2835 1
        defined($version) || error("missing version number: \"$_\"");
d2840 1
a2840 1
      elsif(defined($version) && !isversion($name, $version))
d2842 1
a2842 1
        ($exists, $name, $version) = ();
d2847 1
a2847 1
        isname($name) || error("no such package: $name");
@


1.145
log
@blatant pandering to xdaliclock
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.144 2003/07/12 23:00:58 zaphod Exp zaphod $;
d2303 2
a2304 2
    flock($lock, 8) || die("unlock $path: $!"); # LOCK_UN
    close($lock) || die("close $path: $!");
@


1.144
log
@halfhearted attempts to deal with file/directory confusion
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.143 2003/07/12 22:28:31 zaphod Exp zaphod $;
d1951 1
d1959 1
d1968 1
d1979 1
a1979 1
  my(@@strace, $man);
d1986 7
a1992 1
  whilefile { $man ||= /^install\.man:/; true } $mf;
@


1.143
log
@two fixes that help XFree86: attempt to fix or remove broken symlinks,
make install install.man if Makefile seems to support it
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.142 2003/07/07 06:08:55 zaphod Exp zaphod $;
d1994 2
a1995 1
      map(path("man", "man$_"), 1..9), path(qw[var spool]));
d2242 1
@


1.142
log
@recognize old-style "compress" archives (e.g. rcs-5.7.tar.Z)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.141 2003/06/29 05:31:24 zaphod Exp zaphod $;
d1975 2
a1976 1
  my(@@strace);
d1982 5
a1986 3
  my($target) = "install";
  $target = "upgrade" if -r(path($makedir, "postfix-install")); # postfix
  cdrun($makedir, @@strace, "make", $target);
d2053 16
d2082 1
a2082 1
    sub { ++$total },
@


1.141
log
@improved identification of tar files (e.g. tomsrtbt-2.0.103.tar.gz)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.140 2003/06/29 05:22:45 zaphod Exp zaphod $;
d850 1
d951 1
a951 1
  if($type eq ".gz" || $type eq ".bz2")
d953 1
a953 1
    my($prog) = $type eq ".gz" ? "gzip" : "bzip2";
@


1.140
log
@added stoponerror flag (still poorly tested)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.139 2003/06/27 00:00:48 zaphod Exp zaphod $;
d854 1
a854 1
  return ".tar" if /^[^\x00]+\x00{5,}[\x00\s\d]*$/ || /\x00ustar[ \x00]/;
@


1.139
log
@don't pass both --enable-static and --enable-shared to mozilla
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.138 2003/06/25 07:32:11 zaphod Exp zaphod $;
d562 1
d3009 11
a3019 1
  &$doer(@@$_) || ($result = false) foreach (&$parser(@@_));
@


1.138
log
@special case for unzip
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.137 2003/06/25 06:32:50 zaphod Exp zaphod $;
d1795 1
d1811 1
d1816 6
@


1.137
log
@fix longstanding assertion failure when disarming broken builds
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.136 2003/06/25 06:21:21 zaphod Exp zaphod $;
d1940 1
d1947 1
d1955 1
@


1.136
log
@force mkdir -p
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.135 2003/06/17 05:17:10 zaphod Exp zaphod $;
d175 1
d2316 1
a2316 1
    dfs
@


1.135
log
@added utime() and utimes() to list of wrapped syscalls, for python
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.134 2003/06/17 03:08:02 zaphod Exp zaphod $;
d1382 1
d1386 1
d1409 5
@


1.134
log
@strictpreload is now enabled by default, to catch rewrite.c bugs quicker;
added chmod to list of rewritten shell commands;
abort build after strace-ing make install rather than assuming success;
add opendir() and dlopen() to list of rewritten, er... syscalls...
so that gtk+ will correctly build its various lists of shared library
module doodads in etc/gtk2.0/.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.133 2003/06/16 03:18:17 zaphod Exp zaphod $;
d1600 2
@


1.133
log
@some gnome package was failing to install due to mkdir failure on an
existing directory (probably implicitly created by rewrite.c); fixed by
adding mkdir to the list of wrap0 syscalls and crossing fingers
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.132 2003/06/16 00:43:07 zaphod Exp zaphod $;
d559 1
a559 1
    "strictpreload" => false,
d1584 2
d1738 1
a1738 1
      foreach (qw[mkdir rmdir touch cp rm ln install test ranlib], "[");
d1961 1
@


1.132
log
@sub unlock was not marking things as unlocked, causing toast arm/disarm
with multiple packages to fail; fixed
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.131 2003/06/15 22:39:25 zaphod Exp zaphod $;
d1593 1
a1593 1
    wrap int mkdir(const char *pathname, int mode);
@


1.131
log
@major change: merged destdir into rootdir (simpler; makes tiff work)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.130 2003/06/15 22:03:25 zaphod Exp zaphod $;
d2249 1
@


1.130
log
@cleaned up rewrite.c debug code
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.129 2003/06/12 06:29:40 zaphod Exp zaphod $;
a551 1
    "destdir" => "destdir",
d1362 1
a1362 1
sub helprewrite($$$$$$)
d1364 1
a1364 1
  my($srcdir, $rootdir, $destdir, $helperdir, $cmd, $force) = @@_;
a1369 1
$destdir = ], quote($destdir), q[;
d1392 1
a1392 2
    if(m|^/| &&
        !m!^(\Q$srcdir\E|\Q$rootdir\E|\Q$destdir\E|/tmp|/dev|/proc)($|/)!)
d1422 1
a1422 1
sub helplib($$$$)
d1424 1
a1424 1
  my($srcdir, $rootdir, $destdir, $helperdir) = @@_;
a1452 1
static const char *destdir = ] . cquote($destdir) . qq[;
a1484 5
  else if(startswith(pathname, destdir))
  {
    debug("pathname in destdir: %s", pathname);
    return 0;
  }
a1489 15
  else if(startswith(pathname, "/tmp"))
  {
    debug("pathname in /tmp: %s", pathname);
    return 0;
  }
  else if(startswith(pathname, "/dev"))
  {
    debug("pathname in /dev: %s", pathname);
    return 0;
  }
  else if(startswith(pathname, "/proc"))
  {
    debug("pathname in /proc: %s", pathname);
    return 0;
  }
d1696 1
a1696 1
sub helphome($$$$)
d1698 1
a1698 1
  my($srcdir, $rootdir, $destdir, $helperdir) = @@_;
d1728 1
a1728 1
sub inithelpers($$$$)
d1730 1
a1730 1
  my($srcdir, $rootdir, $destdir, $helperdir) = @@_;
d1735 1
a1735 1
  helprewrite($srcdir, $rootdir, $destdir, $helperdir, $_, false)
d1737 1
a1737 1
  helprewrite($srcdir, $rootdir, $destdir, $helperdir, $_, true)
d1743 1
a1743 1
  my($preload) = helplib($srcdir, $rootdir, $destdir, $helperdir);
d1746 1
a1746 1
  $env{HOME} = helphome($srcdir, $rootdir, $destdir, $helperdir);
d1947 1
a1947 1
sub install($$$)
d1949 1
a1949 1
  my($makedir, $rootdir, $destdir) = @@_;
d1953 2
a1954 2
  local($ENV{DESTDIR}) = $destdir; # not on command line due to libtiff
  local($ENV{install_root}) = $destdir;
d1974 8
a1981 1
sub mkrootdir($)
d1983 1
a1983 1
  my($rootdir) = @@_;
d1986 1
a1986 1
  my(%link) = stdlinks;
d1988 1
a1988 17
}

sub mkdestdir($$$)
{
  my($destdir, $rootdir, $armdir) = @@_;

  my($dir) = $destdir;
  for(unpath($armdir))
  {
    md($dir);
    optmd(path($dir, $_)) foreach stddirs;
    $dir = path($dir, $_);
  }
  ln($rootdir, $dir);

  my(%link) = stdlinks;
  optln($link{$_}, path($destdir, $_)) foreach keys(%link);
d1999 1
a1999 1
sub compilehelp($$$$)
d2001 1
a2001 1
  my($srcdir, $rootdir, $destdir, $helperdir) = @@_;
d2004 1
a2004 1
  my(%initenv) = inithelpers($srcdir, $rootdir, $destdir, $helperdir);
d2013 1
a2013 2
  mkrootdir($rootdir);
  mkdestdir($destdir, $rootdir, armdir);
d2015 1
a2015 1
  install($makedir, $rootdir, $destdir);
d2024 1
a2024 25
sub polishdestdir($$$)
{
  my($destdir, $rootdir, $armdir) = @@_;
  if(-d($destdir))
  {
    rm("$destdir$armdir");
    my(%link) = stdlinks;
    -l && rm($_) foreach map { path($destdir, $_) } keys(%link);
    dfs
    (
      $destdir,
      sub { optmd(optpath($rootdir, $_[0])) },
      sub
      {
        my($rel) = @@_;
        my($dest) = path($rootdir, $rel);
        return rm($_) if -l && optsamefile($_, $dest); # e.g. XFree86
        mv($_, $dest);
      },
      sub { rd($_) }
    );
  }
}

sub polishrootdir($)
d2026 1
a2026 1
  my($rootdir) = @@_;
d2028 3
a2030 2
  my(%link) = stdlinks;
  -l && rm($_) foreach map { path($rootdir, $_) } keys(%link);
d2043 1
a2043 1
sub compile($$$$)
d2045 3
a2047 5
  my($srcdir, $rootdir, $destdir, $helperdir) = @@_;
  compilebin($srcdir, $rootdir) ||
      compilehelp($srcdir, $rootdir, $destdir, $helperdir);
  polishdestdir($destdir, $rootdir, armdir);
  polishrootdir($rootdir);
a2128 1
    my($destdir) = path($builddir, destdir);
d2132 1
a2132 1
    compile($srcdir, $rootdir, $destdir, $helperdir);
@


1.129
log
@export DESTDIR and similar make variables in the environment, rather than
passing them on the command line, to accomodate libtiff MAKEFLAGS idiocy
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.128 2003/06/12 04:27:26 zaphod Exp zaphod $;
d1446 6
d1463 1
a1463 6

#if 0 /* ifdef DEBUG */
  fprintf(DEBUG, "$myname: startswith(%s, %s) = %d\\n", s, prefix, result);
  fflush(DEBUG);
#endif /* DEBUG */

d1471 1
a1471 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: NULL pathname\\n");
    fflush(DEBUG);
#endif /* DEBUG */

d1476 1
a1476 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: relative pathname: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1481 1
a1481 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in srcdir: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1486 1
a1486 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in rootdir: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1491 1
a1491 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in destdir: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1496 1
a1496 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in helperdir: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1501 1
a1501 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in /tmp: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1506 1
a1506 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in /dev: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1511 1
a1511 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: pathname in /proc: %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

d1518 1
a1518 5
#ifdef DEBUG
      fprintf(DEBUG, "$myname: pathname in armdir: %s\\n", pathname);
      fflush(DEBUG);
#endif /* DEBUG */

d1520 1
a1520 5

#ifdef DEBUG
      fprintf(DEBUG, "$myname: stripping armdir: %s\\n", pathname);
      fflush(DEBUG);
#endif /* DEBUG */
d1525 1
a1525 5
#ifdef DEBUG
      fprintf(DEBUG, "$myname: pathname is too long: %s\\n", pathname);
      fflush(DEBUG);
#endif /* DEBUG */

d1530 1
a1530 5
#ifdef DEBUG
      fprintf(DEBUG, "$myname: pathname is rewritable: %s\\n", pathname);
      fflush(DEBUG);
#endif /* DEBUG */

d1543 1
a1543 4
#ifdef DEBUG
    fprintf(DEBUG, "$myname: not creating parents for %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */
d1566 1
a1566 5

#ifndef DEBUG
        (void) ret;
#else
        if(ret)
d1568 1
a1568 1
          fprintf(DEBUG, "$myname: can't create parent directory %s\\n", buf);
d1572 1
a1572 1
          fprintf(DEBUG, "$myname: created parent directory %s\\n", buf);
a1573 2
        fflush(DEBUG);
#endif /* DEBUG */
d1589 1
a1589 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: not rewriting pathname %s\\n", pathname);
    fflush(DEBUG);
#endif /* DEBUG */

a1595 1

d1598 1
a1598 6

#ifdef DEBUG
    fprintf(DEBUG, "$myname: rewriting %s -> %s\\n", pathname, buffer);
    fflush(DEBUG);
#endif /* DEBUG */

d1667 1
a1667 5
#ifdef DEBUG
  fflush(DEBUG);
  fprintf(DEBUG, "$myname: rewriting $name\\n");
  fflush(DEBUG);
#endif /* DEBUG */
d1672 1
a1672 5

#ifdef DEBUG
  fprintf(DEBUG, "$myname: rewritten $name returned $retfmt\\n", result);
  fflush(DEBUG);
#endif /* DEBUG */
d1676 1
a1676 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: retrying $name with original args\\n");
    fflush(DEBUG);
#endif /* DEBUG */

d1678 1
a1678 5

#ifdef DEBUG
    fprintf(DEBUG, "$myname: original $name returned $retfmt\\n", result);
    fflush(DEBUG);
#endif /* DEBUG */
d1683 1
a1683 5
#ifdef DEBUG
    fprintf(DEBUG, "$myname: suppressing $name\\n");
    fflush(DEBUG);
#endif /* DEBUG */

d1693 1
a1693 6
#ifdef DEBUG
  fflush(DEBUG);
  fprintf(DEBUG, "$myname: suppressing $name\\n");
  fflush(DEBUG);
#endif /* DEBUG */

@


1.128
log
@toast demolish no longer requires explicit build or version number
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.127 2003/06/12 02:09:17 zaphod Exp zaphod $;
d2071 4
a2074 3
  my(@@destargs) = map("$_=$destdir", qw[DESTDIR install_root]);
  $ENV{ROOT} = $rootdir; # lilo
  announce("export", "ROOT=$rootdir");
d2077 1
a2077 1
  cdrun($makedir, @@strace, "make", @@destargs, $target);
@


1.127
log
@remove gcc and friends from the list of commands exempted from rewriting
rules, thereby allowing pcre's libtool to successfully find the libpcre.so
it just installed while attempting to relink libpcreposix.so, which should
in turn allow libpcreposix.so to be correctly installed, which should allow
kdelibs to build, which will lead to all sorts of wonderful, terrible things.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.126 2003/06/12 01:08:22 zaphod Exp zaphod $;
d2503 2
a2504 2
  $build || error;
  remove(@@_);
@


1.126
log
@first attempt at advisory locking for arm/disarm
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.125 2003/06/11 05:46:25 zaphod Exp zaphod $;
d1859 1
a1859 1
  helpnorewrite($helperdir, $_) foreach (qw[gcc g++ cc]);
@


1.125
log
@attempting to turn glibc add-ins special case into general case including
building jpeg libraries by default; added reconfigure flag
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.124 2003/06/11 04:58:28 zaphod Exp zaphod $;
d2378 28
d2416 1
d2440 2
d2450 2
d2481 2
@


1.124
log
@reenable qt multithread support by default (as long as we're patching the
configure script anyway...); better comments for prior qt hack; document
mysterious disarm bug
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.123 2003/06/10 03:53:04 zaphod Exp zaphod $;
d561 1
a1905 1
        $confopts{"--enable-add-ons"} = true if / --enable-add-ons\[/; # glibc
d1908 10
a1917 2
        s/(^\s*)read\s+(acceptance)(\s*$)/$1$2=yes$3/; # qt-x11-free license
        s/^\s*AUTOTHREAD=no\s+\#+ leave off for now/\#$&/; # qt thread support
d1921 1
a1921 1
      push(@@confcmd, sort(keys(%confopts)));
@


1.123
log
@genericize part of libpng hack to make it work for zip also
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.122 2003/06/09 05:13:29 zaphod Exp zaphod $;
d1908 2
a1909 1
        s/(^\s*)read\s+(acceptance)(\s*$)/$1$2=yes$3/; # qt-x11-free
d2422 1
a2422 1
        my($armfile) = path(armdir, $rel);
@


1.122
log
@sub safechmod was not so safe; fixed.
fixed sub patch to preserve permissions, so as to be able to patch
qt-x11-free's configure script to be noninteractive (was looping).
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.121 2003/06/09 04:10:33 zaphod Exp zaphod $;
d1939 2
a1940 1
  # look for OS-specific Makefile in a subdir and mv it here (e.g. libpng)
d1945 1
a1945 1
    sub { !/makefile.*$^O/i || !mv($_, path($dir, "Makefile")); },
@


1.121
log
@robustified sub isarmed
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.120 2003/06/08 02:24:39 zaphod Exp zaphod $;
d268 1
a268 1
  $mode | 01777 == 01777 || error("unsafe mode: $txtmode");
d317 27
d360 1
d362 1
a362 1
    writefile($file, @@contents);
a622 25
sub safestat($)
{
  my($file) = @@_;
  my(@@result) = stat($file);
  @@result || error("stat $file: $!");
  @@result;
}

sub samefile($$)
{
  my($a, $b) = @@_;
  my($da, $ia) = safestat($a);
  my($db, $ib) = safestat($b);
  $da eq $db && $ia eq $ib;
}

sub optsamefile($$)
{
  my($a, $b) = @@_;
  my($da, $ia) = stat($a);
  return false unless defined($da);
  my($db, $ib) = stat($b);
  defined($db) && $da eq $db && $ia eq $ib;
}

d1900 1
d1903 1
a1903 2
      explain("examining $confprog...");
      next unless whilefile
d1907 2
a1908 1
        !/There is no .{0,3}\bconfigure\b.{0,3} script /i; # libpng
d1910 2
@


1.120
log
@dummy.c no longer spews warnings; cosmetic improvements to rewrite.c
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.119 2003/06/08 02:06:37 zaphod Exp zaphod $;
d1128 1
a1128 2
          my($target) = readlink($armfile);
          return false if defined($target) && $target eq $_;
@


1.119
log
@fix wrap0 to work with syscalls that take fewer than two pathname args;
add unlink to list of wrap0 syscalls (simulate success if failure occurs
when all pathname arguments are eligible for rewriting) so that when
a package (e.g. sysklogd) explicitly invokes /usr/bin/install to install
a file that already exists (e.g. /usr/man/man8/syslogd.8, from man-pages),
/usr/bin/install will be fooled into thinking its unlink succeeded and
will proceed to install the right file in the right place.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.118 2003/06/08 01:47:58 zaphod Exp zaphod $;
d1705 1
a1705 1
    my($allrewritten) = join(" && ", map("check_strip_armdir($_)",
d1716 1
a1716 1
static $rettype (*next_$name)($proto) = 0;
d1718 1
a1718 1
static $rettype real_$name($proto)
d1730 1
a1730 1
$rettype $name($proto)
d1732 1
a1732 1
  $rettype result;
d1764 1
a1764 1
  if(result == $retfailed && $allrewritten )
d1778 1
a1778 1
$rettype $name($proto)
d1795 1
a1795 1
  writefile(path($helperdir, "dummy.c"), "static int dummy(int x) { }\n");
@


1.118
log
@make postfix work
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.117 2003/06/08 00:37:18 zaphod Exp zaphod $;
a1683 1
    wrap0 int rename(const char *pathname1, const char *pathname2);
a1685 1
    wrap int unlink(const char *pathname);
d1687 2
d1705 2
d1764 1
a1764 1
  if(result == $retfailed && check_strip_armdir(pathname1) && check_strip_armdir(pathname2))
@


1.117
log
@special case for Sleepycat DB
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.116 2003/06/08 00:26:45 zaphod Exp zaphod $;
d2057 3
a2059 1
  cdrun($makedir, @@strace, "make", @@destargs, "install");
d2064 3
a2066 2
  my(@@result) = (qw[bin boot etc include info lib libexec man sbin share src],
      map(path("man", "man$_"), 1..9));
@


1.116
log
@deal more gracefully with programs (such as XFree86) that seem to like
to put symlinks from destdir to rootdir.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.115 2003/06/06 05:17:49 zaphod Exp zaphod $;
d1940 6
@


1.115
log
@added hacks to handle libpng; tweaked nearby code
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.114 2003/06/06 04:40:11 zaphod Exp zaphod $;
d611 9
d2138 7
a2144 1
      sub { mv($_, path($rootdir, $_[0])) },
@


1.114
log
@fixed brokenness introduced in previous revision
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.113 2003/06/06 02:10:38 zaphod Exp zaphod $;
d1890 1
a1890 1
      whilefile
d1893 2
a1894 3
        $builddir = true if
            /error: you must configure in a separate build directory/; # glibc
        true;
d1917 2
a1918 3
  my($sd) = path($dir, qw[config cf site.def]);
  return $dir if -w($sd) &&
      patch { s!(\#\s*define\s+ProjectRoot\s+)(/usr/X\S+)!$1$prefix!; } $sd;
d1922 9
@


1.113
log
@blatant special treatment for XFree86
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.112 2003/05/08 03:24:40 zaphod Exp zaphod $;
d2005 1
a2005 1
  my($ok) = true; # skip make if "all" implies "install" (e.g. man-pages)
d2010 1
a2010 1
  whilefile
a2011 1
    /^all:[^\#]*\binstall\b/ ? ($ok = false) : true;
d2014 1
a2015 1
  return false unless $ok;
d2017 1
a2020 1
  my(@@prog) = "make";
d2024 1
@


1.112
log
@force rewritten mv to return success (for e.g. man)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.111 2003/05/05 03:27:50 zaphod Exp zaphod $;
d1917 5
d2007 1
d2012 1
d2014 1
a2014 1
    /^all:[^\#]*\binstall\b/ ? ($ok = false) : true;
d2020 1
@


1.111
log
@don't install Linux source
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.110 2003/05/01 03:33:01 zaphod Exp zaphod $;
d1351 1
a1351 1
sub helprewrite($$$$$)
d1353 1
a1353 1
  my($srcdir, $rootdir, $destdir, $helperdir, $cmd) = @@_;
d1402 6
d1840 4
a1843 2
  helprewrite($srcdir, $rootdir, $destdir, $helperdir, $_)
      foreach (qw[mkdir rmdir touch cp rm mv ln install test ranlib], "[");
@


1.110
log
@never rewrite paths under /tmp, /dev, or /proc
(previously, a number of programs were creating amusing .../dev/null files)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.109 2003/04/23 20:20:19 zaphod Exp zaphod $;
a1809 1
  my($ksrcdir) = path($rootdir, "src", "linux");
d1821 1
a1821 5
make -C $makedir clean
mkdir -p $ksrcdir
(cd $makedir; tar cf - .) | (cd $ksrcdir; tar xf - .)
ln -s ../src/linux/include/asm $rootdir/include/asm
ln -s ../src/linux/include/linux $rootdir/include/linux
@


1.109
log
@removed unused sub compilenohelp;
linux install script now installs full source tree and header files
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.108 2003/04/22 22:11:16 zaphod Exp zaphod $;
d1382 2
a1383 1
    if(m|^/| && !m!^(\Q$srcdir\E|\Q$rootdir\E|\Q$destdir\E|/tmp)($|/)!)
d1499 27
@


1.108
log
@resorted to patching the installer to get perl to rebuild properly
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.107 2003/04/22 20:24:18 zaphod Exp zaphod $;
d1767 1
a1767 1
sub helphome($$)
d1769 2
a1770 1
  my($helperdir, $rootdir) = @@_;
d1775 1
d1782 2
d1794 5
d1820 1
a1820 1
  $env{HOME} = helphome($helperdir, $rootdir);
a2070 13
sub compilenohelp($$$)
{
  my($srcdir, $rootdir, $destdir) = @@_;
  my($makedir) = makedir($srcdir);

  configure($makedir, armdir);
  make($makedir);
  mkrootdir($rootdir);
  mkdestdir($destdir, $rootdir, armdir);
  configure($makedir, $rootdir);
  install($makedir, $rootdir, $destdir);
}

a2109 1

d2111 1
a2111 3
      compilehelp($srcdir, $rootdir, $destdir, $helperdir) ||
      compilenohelp($srcdir, $rootdir, $destdir);

@


1.107
log
@Pretend that calls to rename(2) with two rewritable arguments succeeded,
even if both rewritten and non-rewritten attempts failed.  This seems to
help perl install its man pages even though it tries to save backup copies
of existing man pages for some bizarre reason.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.106 2003/04/22 17:47:06 zaphod Exp zaphod $;
d317 29
d529 1
d689 6
d1864 6
@


1.106
log
@add fopen/freopen to list of rewritten libc calls (for e.g. groff)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.105 2003/04/21 20:56:16 zaphod Exp zaphod $;
d1403 1
a1403 1
#ifdef DEBUG
d1605 1
a1605 1
    wrap int rename(const char *pathname1, const char *pathname2);
d1619 3
a1621 2
    /^(wrap|suppress) (int |\w+ \*)(\w+)\((.*)\)$/ || error;
    my($iswrap, $rettype, $basename, $proto) = ($1 eq "wrap", $2, $3, $4);
d1682 7
d1690 4
@


1.105
log
@rewrite.so: create later subdirs even if earlier subdirs already exist
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.104 2003/04/21 20:37:10 zaphod Exp zaphod $;
d1594 19
a1612 17
    wrap creat(const char *pathname, int flags);
    wrap open(const char *pathname, int flags, int mode);
    wrap access(const char *pathname, int flags);
    wrap chdir(const char *pathname);
    wrap xstat(int version, const char *pathname, void *foo);
    wrap lxstat(int version, const char *pathname, void *foo);
    wrap readlink(const char *pathname, char *buf, int size);
    wrap link(const char *pathname1, const char *pathname2);
    wrap symlink(const char *pathname1, const char *pathname2);
    wrap rename(const char *pathname1, const char *pathname2);
    wrap mkdir(const char *pathname, int mode);
    wrap rmdir(const char *pathname);
    wrap unlink(const char *pathname);
    wrap chmod(const char *pathname, int mode);
    suppress chown(const char *pathname, int user, int group);
    suppress lchown(const char *pathname, int user, int group);
    suppress fchown(int fd, int user, int group);
d1619 3
a1621 2
    /^(wrap|suppress) (\w+)\((.*)\)$/ || error;
    my($iswrap, $basename, $proto) = ($1 eq "wrap", $2, $3);
d1634 1
a1634 1
static int (*next_$name)($proto) = 0;
d1636 1
a1636 1
static int real_$name($proto)
d1648 1
a1648 1
int $name($proto)
d1650 1
a1650 1
  int result;
d1663 1
a1663 1
  fprintf(DEBUG, "$myname: rewritten $name returned %d\\n", result);
d1667 1
a1667 1
  if(result < 0)
d1677 1
a1677 1
    fprintf(DEBUG, "$myname: original $name returned %d\\n", result);
d1685 1
a1685 1
int $name($proto)
@


1.104
log
@more rewrite.so improvements: autocreate parent dirs, don't rewrite helperdir
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.103 2003/04/20 02:55:45 zaphod Exp zaphod $;
d1537 1
a1537 1
        done = real_mkdir(buf, 0755) != 0;
d1539 4
a1542 2
#ifdef DEBUG
        if(done)
@


1.103
log
@reorganized rewrite.c; added strictpreload option for testing
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.102 2003/04/20 00:59:23 zaphod Exp zaphod $;
d1381 3
a1385 2
#include <dlfcn.h>
#include <assert.h>
d1396 1
d1411 146
d1561 1
a1561 1
  char *buffer = buffers[whichbuf];
d1563 1
a1563 5
  whichbuf ^= 1;

  if(!pathname || pathname[0] != '/' || startswith(pathname, srcdir) ||
      startswith(pathname, rootdir) || startswith(pathname, destdir) ||
      BUFSIZE < strlen(rootdir) + strlen(pathname) + 1)
d1574 2
a1575 2
    const char *suffix =
        startswith(pathname, armdir) ? pathname + strlen(armdir) : pathname;
d1578 1
a1578 1
    strcat(buffer, suffix);
d1620 1
d1653 2
d1695 1
a1695 1
  my(@@socc) = qw[gcc -shared];
d1700 1
a1700 1
  push(@@socc, qw[-Wall -Werror]) if strictpreload;
@


1.102
log
@autoclean both before and after build (so new build will be cleaned too!)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.101 2003/04/20 00:57:43 zaphod Exp zaphod $;
d502 1
a1449 1
    wrap open64(const char *pathname, int flags, int mode);
a1452 1
    wrap xstat64(int version, const char *pathname, void *foo);
a1453 1
    wrap lxstat64(int version, const char *pathname, void *foo);
d1472 1
a1472 1
    my($iswrap, $name, $proto) = ($1 eq "wrap", $2, $3);
d1477 1
a1477 1
    my($nameprefix);
d1480 1
a1480 2
      my($fullname) = $nameprefix . $name;
      if($iswrap)
d1482 17
a1498 2
        $code .= qq[
int $fullname($proto)
a1499 1
  static int (*next)($proto) = 0;
d1508 1
a1508 7
  if(!next)
  {
    next = dlsym(RTLD_NEXT, "$fullname");
    assert(next);
  }

  result = next($newargs);
d1522 1
a1522 1
    result = next($args);
d1532 2
a1533 6
];
      }
      else
      {
        $code .= qq[
int $fullname($proto)
d1548 2
d1551 4
a1554 1
  cdrun($helperdir, qw[gcc -shared dummy.c -o rewrite.so]);
d1556 9
a1564 4
  optcdrun($helperdir, qw[gcc -shared rewrite.c -ldl -o rewrite.so.helper])
      || return undef;

  return path($helperdir, "rewrite.so");
@


1.101
log
@rewritten commands now autocreate parent directories;
added ranlib to list of rewritten commands (e.g. binutils)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.100 2003/04/20 00:17:15 zaphod Exp zaphod $;
d2040 1
@


1.100
log
@added rm to list of rewritten commands
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.99 2003/04/19 23:32:38 zaphod Exp zaphod $;
d1349 7
a1356 4
# this doesn't work right -- LD_PRELOAD is still in effect for this process...
#      my($dir) = "";
#      $' && mkdir($dir .= $1) && print("$myname: created dir $dir\n")
#          while m|(/[^/]+)|g;
d1592 1
a1592 1
      foreach (qw[mkdir rmdir touch cp rm mv ln install test], "[");
@


1.99
log
@autoclean before building, not after
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.98 2003/04/19 04:59:01 zaphod Exp zaphod $;
d1589 1
a1589 1
      foreach (qw[mkdir rmdir touch cp mv ln install test], "[");
@


1.98
log
@fixed another case where toast arm failed to deal with broken symlinks
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.97 2003/04/19 04:08:39 zaphod Exp zaphod $;
d1947 2
a2036 1
  clean($name, $version) if autoclean;
@


1.97
log
@attempt to fix a bug in previous destdir fix if armdir is a stdlink
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.96 2003/04/18 21:54:10 zaphod Exp zaphod $;
d2046 1
a2046 1
  if(-e)
@


1.96
log
@recognize handmade single-file unified diff patches
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.95 2003/04/18 04:23:49 zaphod Exp zaphod $;
d1860 1
a1862 1
    rm("$destdir$armdir");
@


1.95
log
@install packages that support DESTDIR but not PREFIX (e.g. man)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.94 2003/04/15 05:07:50 zaphod Exp zaphod $;
d806 1
a806 1
  return ".patch" if /^(diff |\*\*\* |Only in |Common subdirectories: )/m;
@


1.94
log
@fixed sorting bug
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.93 2003/04/15 04:59:15 zaphod Exp zaphod $;
d255 6
d1794 2
d1798 3
a1800 2
    md($destdir);
    $destdir = path($destdir, $_);
d1802 4
a1805 1
  ln($rootdir, $destdir);
d1860 2
@


1.93
log
@no, really, I mean it this time
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.92 2003/04/15 04:53:39 zaphod Exp zaphod $;
d717 3
a719 2
  my($len) = length($_[0]);
  $len > 40 ? $_[0] : (' ' x (40 - $len)) . $_[0];
d724 1
a724 1
  my($na, $nb) = map { my($x) = $_; $x =~ s/\d+/pad40($&)/ge } ($a, $b);
@


1.92
log
@strip query string from URL before guessing name/version
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.91 2003/04/12 00:06:27 zaphod Exp zaphod $;
d702 1
a702 1
  local($_) = stripquery(stripext(basename(collapse(@@sources))));
@


1.91
log
@suppress attempted execution of ldconfig in make install for e.g. procps
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.90 2003/04/11 02:56:49 zaphod Exp zaphod $;
d702 1
a702 1
  local($_) = stripext(basename(collapse(@@sources)));
@


1.90
log
@don't rewrite shell commands that are trying to access /tmp (e.g. ncurses)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.89 2003/04/11 02:52:16 zaphod Exp zaphod $;
d1583 1
a1583 1
  helpnop($helperdir, "chown");
@


1.89
log
@try to fix problems with broken symlinks in toast disarm/status
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.88 2003/04/11 02:33:21 zaphod Exp zaphod $;
d1338 1
a1338 1
    if(m|^/| && !m!^(\Q$srcdir\E|\Q$rootdir\E|\Q$destdir\E)($|/)!)
@


1.88
log
@autopurge is no longer enabled by default;
fixed bug in toast clean that made it stop after encountering a clean build
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.87 2003/04/09 05:35:13 zaphod Exp zaphod $;
d1073 1
a1073 1
        while(-e($armfile))
d2114 1
a2114 1
        while(-e($armfile))
@


1.87
log
@fixed bug in sub uselatestversion that caused many toast commands to
ignore version or build numbers given explicitly on the command line
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.86 2003/04/05 02:41:06 zaphod Exp zaphod $;
d236 1
d495 1
a495 1
    "autopurge" => true,
@


1.86
log
@fixed some problems preventing internal http fallback from working
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.85 2003/04/04 04:03:16 zaphod Exp zaphod $;
d2689 2
a2690 2
    $version = latestversion($name) unless @@urls;
    $build = latestbuild($name, $version) unless @@urls;
@


1.85
log
@fixed some problems with toast disarm
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.84 2003/04/02 05:56:50 zaphod Exp zaphod $;
d354 2
a355 2
  return false if $? == -1; # program not found
  error("exec $prog: $!");
d387 1
@


1.84
log
@added info to stddirs; autoclean now removes old broken builds;
toast arm now builds correctly in presence of broken builds (I think);
toast clean no longer returns failure
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.83 2003/04/02 05:07:29 zaphod Exp zaphod $;
d2100 21
a2120 11
  my($rootdir) = path(pkgpath($name, $version, $build), rootdir);
  my($ok);
  dfs
  (
    $rootdir,
    sub { true },
    sub
    {
      my($rel) = @@_;
      my($armfile) = path(armdir, $rel);
      while(-e($armfile))
d2122 4
a2125 3
        my($target) = readlink($armfile);
        return replace($ok = $armfile) if defined($target) && $target eq $_;
        $armfile = addoff($armfile);
d2127 4
a2130 10
      return true;
    },
    sub
    {
      my($rel) = @@_;
      my($armdir) = optpath(armdir, $rel);
      rd($armdir) if -d($armdir) && isempty($armdir);
    }
  );
  defined($ok) || error("$name version $version build $build not armed");
@


1.83
log
@implemented toast purge; added autopurge setting
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.82 2003/04/02 04:25:19 zaphod Exp zaphod $;
d1763 1
a1763 1
  my(@@result) = (qw[bin boot etc include lib libexec man sbin share src],
d1898 2
d2018 1
a2018 1
  clean($name, $version, $build) if autoclean;
d2062 1
a2062 1
  ($name, $version, $build) = build(@@_)
@


1.82
log
@prefer wget to built-in http
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.81 2003/04/01 04:56:55 zaphod Exp zaphod $;
d493 1
d1900 18
d2017 1
a2126 5

sub purge(@@)
{
  error("purge nyi");
}
@


1.81
log
@fixed cosmetic bug in sub rmexisting
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.80 2003/04/01 04:52:26 zaphod Exp zaphod $;
d353 3
a355 1
  open(HANDLE, "-|", "$prog @@args") || error("exec $prog: $!");
d427 6
a432 4
  return openhttpurl(*HANDLE, $url) if $proto eq "http";
  return openfileurl(*HANDLE, $url) if $proto eq "file";
  return opensshurl (*HANDLE, $url) if $proto eq "ssh";
  return openwgeturl(*HANDLE, $url);
@


1.80
log
@toast arm: parsing improvements
toast clean: handle missing srcdir correctly
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.79 2003/03/31 03:33:38 zaphod Exp zaphod $;
d224 1
d234 2
a235 1
  rmall(grep(-e || -l, @@_));
d1054 1
a1054 1
  !whilebuild
@


1.79
log
@toast status improvements: flag unclean builds
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.78 2003/03/31 03:24:10 zaphod Exp zaphod $;
d231 5
d721 1
a721 1
  @@_ ?  $_[$#_] : error;
d994 6
d1017 2
a1018 1
  true;
d1889 1
a1889 1
    rmall($srcdir, $helperdir);
d2046 6
a2051 1
    -e($abs) || -l($abs) || ln($link{$_}, $abs);
d2648 14
a2661 1
    $version = latestversion($name) unless @@urls || defined($version);
d2673 1
a2673 1
sub parse_arm(@@) { rejectempty(uselatestversion(parse(@@_))); }
@


1.78
log
@toast status improvements: flag stored versions
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.77 2003/03/31 03:15:03 zaphod Exp zaphod $;
d1014 1
a1014 1
  -d(path(pkgpath($name, $version), archivedir));
d1019 1
a1019 1
  !whilebuild
d1022 1
a1022 1
    !-f(path(pkgpath($name, $version, $build), buildlog));
d1029 7
a1035 1
  -f(path(pkgpath($name, $version, $build), brokenlog));
d2121 4
a2124 3
  return "armed" if isarmed($name, $version, $build);
  return "built" if isbuilt($name, $version, $build);
  return "building";
@


1.77
log
@renamed toast forget to toast purge
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.76 2003/03/30 02:48:20 zaphod Exp zaphod $;
d1011 1
a1011 1
sub isgotten($$)
d1881 1
a1881 1
  ($name, $version) = get(@@_) if @@urls || !isgotten($name, $version);
d2104 7
d2114 4
a2117 4
  isbroken($name, $version, $build) && "broken" ||
  isarmed($name, $version, $build) && "armed" ||
  isbuilt($name, $version, $build) && "built" ||
  "building";
d2128 1
d2131 3
a2133 1
      print("  version $version\n");
d2142 1
a2142 1
  true;
@


1.76
log
@made toast clean more flexible; added autoclean flag;
quick and dirty toast demolish; extra assertion for toast remove;
code cleanup for toast status
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.75 2003/03/30 02:13:43 zaphod Exp zaphod $;
d2079 1
a2079 1
sub forget(@@)
d2081 1
a2081 1
  error("forget nyi");
d2629 1
a2629 1
sub parse_forget(@@) { rejectempty(rejecturls(rejectbuilds(parse(@@_)))); }
d2808 1
a2808 1
=item S<B<toast forget> I<PACKAGE> ...>
@


1.75
log
@incompatible change: added pkgdir under storedir
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.74 2003/03/30 00:54:25 zaphod Exp zaphod $;
d481 1
d1861 14
d1973 2
a1979 12
sub clean(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  @@urls && error;
  my($builddir) = pkgpath($name, $version, $build);
  my($srcdir) = path($builddir, srcdir);
  my($helperdir) = path($builddir, helperdir);
  rmall($srcdir, $helperdir);
}

##############################################################################

a2083 5
sub demolish(@@)
{
  error("demolish nyi");
}

d2088 1
d2094 8
d2116 1
d2118 1
a2118 1
  for $name (defined($name) ? ($name) : allnames)
d2121 1
a2121 1
    for $version (defined($version) ? ($version) : allversions($name))
d2124 1
a2124 1
      for $build (defined($build) ? ($build) : allbuilds($name, $version))
d2625 1
a2625 1
sub parse_clean(@@) { rejectempty(rejecturls(parse(@@_))); }
@


1.74
log
@fix ownership on rootdir symlinks when building as root
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.73 2003/03/30 00:23:01 zaphod Exp zaphod $;
d470 1
d618 1
a618 1
sub storepath($;$$)
d622 1
a622 1
  optpath(storedir, $name, defined($version) && "v$version", $build);
d944 1
a944 1
  @@_ && defined($_[0]) ? @@_ : sort cmpab ls(storedir);
d950 1
a950 1
  @@_ && defined($_[0]) ? @@_ : sort cmpab grep { s/^v// } ls(storepath($name));
d957 1
a957 1
      ls(storepath($name, $version));
d965 1
a965 1
  -d(storepath($name));
d971 1
a971 1
  -d(storepath($name, $version));
d977 1
a977 1
  -d(storepath($name, $version, $build));
d1013 1
a1013 1
  -d(path(storepath($name, $version), archivedir));
d1021 1
a1021 1
    !-f(path(storepath($name, $version, $build), buildlog));
d1028 1
a1028 1
  -f(path(storepath($name, $version, $build), brokenlog));
d1036 1
a1036 1
    my($rootdir) = path(storepath($name, $version, $build), rootdir);
d1069 2
a1070 2
  my($namedir) = storepath($name);
  optmd(storedir, $namedir);
d1074 1
a1074 1
  my($verdir) = storepath($name, $version);
d1093 1
a1093 1
        $verdir = storepath($name, $version);
d1156 2
a1157 2
  my($namedir) = storepath($name);
  my($verdir) = storepath($name, $version);
d1169 2
a1170 2
      my($newnamedir) = storepath($newname);
      my($newverdir) = storepath($newname, $newversion);
d1192 1
a1192 1
  my($verdir) = storepath($name, $version);
d1870 1
a1870 1
  my($verdir) = storepath($name, $version);
d1967 1
a1967 1
  my($builddir) = storepath($name, $version, $build);
d2027 1
a2027 1
  my($rootdir) = path(storepath($name, $version, $build), rootdir);
d2044 1
a2044 1
  my($rootdir) = path(storepath($name, $version, $build), rootdir);
d2090 1
a2090 1
  rmall(storepath($name, $version, $build));
d2137 2
a2138 2
  my($sdir) = storepath($sname, $sversion, $sbuild);
  my($ddir) = storepath($dname, $dversion, $dbuild);
d2145 1
a2145 1
  my($namedir) = storepath($dname);
d2147 1
a2147 1
  my($versiondir) = storepath($dname, $dversion);
d2170 1
a2170 1
    my($path) = storepath($name, $version, $build);
d2186 1
a2186 1
    my($path) = storepath($name, $version);
d2208 1
a2208 1
    my($path) = storepath($name);
d2221 1
a2221 1
    my($path) = storedir;
@


1.73
log
@install Linux kernel properly
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.72 2003/03/28 04:28:35 zaphod Exp zaphod $;
d1930 1
a1930 1
    announce("chown", "-R", "root:root", $builddir);
d1935 14
a1948 1
      sub { -l || chown(0, 0, $_) || ($success = !($msg = "chown $_: $!")) },
@


1.72
log
@improved handling of Linux kernel
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.71 2003/03/21 22:04:01 zaphod Exp zaphod $;
d1517 28
d1561 2
d1736 1
a1736 1
  my(@@result) = (qw[bin etc include lib libexec man sbin share src],
@


1.71
log
@added yes subprocess
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.70 2003/03/21 01:38:59 zaphod Exp zaphod $;
d1672 4
d1677 6
a1682 4
  # try to skip this step if "all" implies "install" (e.g. man-pages):
  my($mf) = makefile($dir) || error("no Makefile found");
  my($ok) = true;
  whilefile { /^all:[^\#]*\binstall\b/ ? ($ok = false) : true } $mf;
d1685 6
a1690 1
  cdrun($dir, "make");
@


1.70
log
@export ROOT=$rootdir for lilo
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.69 2003/03/20 22:37:06 zaphod Exp zaphod $;
d758 12
d1855 1
@


1.69
log
@ln -s ../man /FOO/share/man; look in src subdir [both changes for sysvinit]
suppress a warning due to unset LD_PRELOAD; fiddle with comments 'n things
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.68 2003/03/20 19:16:28 zaphod Exp zaphod $;
d1670 1
a1670 1
sub install($$)
d1672 1
a1672 1
  my($makedir, $destdir) = @@_;
d1676 2
d1738 1
a1738 1
  install($makedir, $destdir);
d1757 1
a1757 1
  install($makedir, $destdir);
@


1.68
log
@merge destdir into rootdir; glibc builds at last!
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.67 2003/03/20 02:07:53 zaphod Exp zaphod $;
d1257 2
d1260 2
a1261 2
PATH=$ENV{PATH}
LD_PRELOAD=$ENV{LD_PRELOAD}
d1612 3
d1636 1
a1636 1
  # give up if our Makefile is looking too implausible
d1681 2
a1682 2
  my(@@result) = qw[bin etc include lib libexec man sbin share src],
      map { path("man", "man$_") } (1..9);
d1688 1
a1688 1
  ("usr", "local");
d1696 2
a1697 1
  ln(".", path($rootdir, $_)) foreach stdlinks;
d1778 2
a1779 1
  -l && rm($_) foreach map { path($rootdir, $_) } stdlinks;
d1948 7
a1954 1
  -e || ln(".", $_) foreach map { path(armdir, $_) } stdlinks;
@


1.67
log
@set install_root as well as DESTDIR during make install (for e.g. glibc)
wrapped Unix commands no longer produce spurious output when not rewriting
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.66 2003/03/19 04:31:45 zaphod Exp zaphod $;
d1757 8
a1764 8
    my(@@rmdirs);
    for(unpath($armdir))
    {
      push(@@rmdirs, $destdir);
      $destdir = path($destdir, $_);
    }
    rm($destdir);
    rd(reverse(@@rmdirs));
@


1.66
log
@failed attempt at automatically creating directories, commented out
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.65 2003/03/17 04:13:11 zaphod Exp zaphod $;
d1290 1
d1297 1
d1310 1
a1310 1
print("$myname: rewriting $cmd @@oldargs -> $cmd @@newargs\n");
d1670 2
a1671 1
  cdrun($makedir, @@strace, "make", "DESTDIR=$destdir", "install");
@


1.65
log
@add open64 to list of wrapped syscalls
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.64 2003/03/14 03:24:04 zaphod Exp zaphod $;
d1268 1
a1268 1
  writescript(path($helperdir, "$cmd.helper"), "#!$^X", q[
d1298 4
@


1.64
log
@toast build now sets DESTDIR when running make install
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.63 2003/03/09 08:37:37 zaphod Exp zaphod $;
d1390 1
@


1.63
log
@Don't try to apply insane preload rewriting to gcc, if the install target
should stupidly try to compile stuff, as binutil's does.
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.62 2003/03/09 08:11:54 zaphod Exp zaphod $;
d110 10
d475 1
d1264 1
a1264 1
sub helprewrite($$$$)
d1266 1
a1266 1
  my($srcdir, $rootdir, $helperdir, $cmd) = @@_;
d1272 1
d1294 1
a1294 1
    if(m|^/| && !m!^\Q$srcdir\E($|/)!)
d1310 1
a1310 1
sub helplib($$$)
d1312 1
a1312 1
  my($srcdir, $rootdir, $helperdir) = @@_;
d1334 1
d1358 1
d1496 1
a1496 1
sub inithelpers($$$)
d1498 1
a1498 1
  my($srcdir, $rootdir, $helperdir) = @@_;
d1503 1
a1503 1
  helprewrite($srcdir, $rootdir, $helperdir, $_)
d1509 1
a1509 1
  my($preload) = helplib($srcdir, $rootdir, $helperdir);
d1658 1
a1658 1
sub install($)
d1660 1
a1660 1
  my($dir) = @@_;
d1663 1
a1663 1
  cdrun($dir, @@strace, "make", "install");
d1686 11
d1705 1
a1705 1
sub compilehelp($$$)
d1707 1
a1707 1
  my($srcdir, $rootdir, $helperdir) = @@_;
d1710 1
a1710 1
  my(%initenv) = inithelpers($srcdir, $rootdir, $helperdir);
d1720 1
d1722 1
a1722 1
  install($makedir);
d1731 1
a1731 1
sub compilenohelp($$)
d1733 1
a1733 1
  my($srcdir, $rootdir) = @@_;
d1739 1
d1741 17
a1757 1
  install($makedir);
d1777 1
a1777 1
sub compile($$$)
d1779 1
a1779 1
  my($srcdir, $rootdir, $helperdir) = @@_;
d1782 2
a1783 2
      compilehelp($srcdir, $rootdir, $helperdir) ||
      compilenohelp($srcdir, $rootdir);
d1785 1
d1831 1
d1835 1
a1835 1
    compile($srcdir, $rootdir, $helperdir);
@


1.62
log
@implement toast clean
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.61 2003/03/09 07:29:04 zaphod Exp zaphod $;
d1243 10
d1492 1
@


1.61
log
@more glibc hacks; misc. tweaks and cleanups; fix sub whiledir return value;
be less eager to construct a Makefile from whole cloth
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.60 2003/03/09 01:57:25 zaphod Exp zaphod $;
d1824 6
a1829 1
  error("clean nyi");
@


1.60
log
@improved output format for sub explain;
examine configure script so as to be able to treat glibc specially
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.59 2003/03/09 01:13:00 zaphod Exp zaphod $;
d282 1
d1512 1
d1526 3
a1528 2
        $confopts{"--enable-add-ons"} = true if / --enable-add-ons\[/;
        $builddir = true if /error: you must configure in a separate build di/;
d1540 2
a1541 1
      return cdrun($dir, @@confcmd);
d1545 2
a1546 1
  return true if makefile($dir);
d1548 32
a1579 1
  my($prog, @@sources, @@man);
d1590 2
a1591 2
        $prog = stripext(basename($_))
            if !$prog && grep { /\bmain\b/ } readfile($_);
d1598 4
a1601 1
  error("can't figure out how to compile") unless $prog && @@sources;
d1609 1
a1609 1
$prog: @@sources
d1611 2
a1612 2
install: $prog
\tcp $prog \$(BINDIR)
d1617 1
d1625 1
a1625 1
  my($mf) = makefile($dir) || error;
d1681 1
a1681 1
  configure($makedir, armdir);
d1874 1
@


1.59
log
@rewrite calls to chdir(2) (gcc seems to require this?);
don't put literal newlines in C string constants
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.58 2003/03/09 00:53:52 zaphod Exp zaphod $;
d45 1
a45 1
    print("[@@_]\n") if $verbose;
d1511 2
a1512 1
  for(qw[configure configure.gnu])
d1514 25
a1538 1
    return cdrun($dir, "./$_", "--prefix=$prefix") if(-x path($dir, $_));
@


1.58
log
@print un-rewritten command arguments properly;
add libexec to stddirs (for e.g. GNU tar)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.57 2003/03/09 00:50:21 zaphod Exp zaphod $;
d1318 1
a1318 1
  fprintf(DEBUG, "$myname: startswith(%s, %s) = %d\n", s, prefix, result);
d1337 1
a1337 1
    fprintf(DEBUG, "$myname: not rewriting pathname %s\n", pathname);
d1352 1
a1352 1
    fprintf(DEBUG, "$myname: rewriting %s -> %s\n", pathname, buffer);
d1366 1
d1408 1
a1408 1
  fprintf(DEBUG, "$myname: rewriting $name\n");
d1421 1
a1421 1
  fprintf(DEBUG, "$myname: rewritten $name returned %d\n", result);
d1428 1
a1428 1
    fprintf(DEBUG, "$myname: retrying $name with original args\n");
d1435 1
a1435 1
    fprintf(DEBUG, "$myname: original $name returned %d\n", result);
d1451 1
a1451 1
  fprintf(DEBUG, "$myname: suppressing $name\n");
@


1.57
log
@suppress owner/group options of install command
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.56 2003/03/09 00:33:45 zaphod Exp zaphod $;
d1258 3
d1281 1
a1281 1
print("$myname: rewriting $cmd @@ARGV -> $cmd @@newargs\n");
d1577 1
a1577 1
  my(@@result) = qw[bin etc include lib man sbin share src],
@


1.56
log
@correct dlfcn.h fix
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.55 2003/03/08 04:39:58 zaphod Exp zaphod $;
d1259 1
a1259 2
@@newargs = @@ARGV;
for(@@newargs)
d1261 2
a1262 1
  if(m|^/| && !m!^\Q$srcdir\E($|/)!)
d1264 10
a1273 2
    s!^\Q$armdir\E($|/)!$1!;
    $_ = "$rootdir$_";
@


1.55
log
@allow toast build to proceed if rewrite.so breaks;
fixed rewrite.so to work with more modern GNU dlfcn.h (?);
fixed a bug in sub stripext that caused extensions to appear in version #'s
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.54 2003/03/08 03:16:17 zaphod Exp zaphod $;
d1285 1
a1285 1
#define __USE_GNU
@


1.54
log
@moved dotfile; changed some defaults; chown builddir when running as root
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.53 2003/03/07 04:42:28 zaphod Exp zaphod $;
d93 1
a93 1
sub stripext($) { my($arg) = @@_; $arg =~ s/\.[a-z]\w*$//i; s/\.tar//i; $arg; }
d306 1
a306 1
sub cdrun($@@)
d314 1
a314 1
    $? && error("@@prog returned $?");
d324 6
d1285 2
d1453 2
a1454 1
  cdrun($helperdir, qw[gcc -shared rewrite.c -ldl -o rewrite.so.helper]);
@


1.53
log
@replace toast emit with toast bootstrap (?)
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.52 2002/12/29 23:59:35 zaphod Exp zaphod $;
d451 2
a452 2
    "storedir" => "/home/zaphod/toast2/storedir",
    "armdir" => "/home/zaphod/toast2/armdir",
d479 1
a479 1
    my($dotfile) = "$ENV{HOME}/.$myname";
d716 8
d729 1
a729 2
  my($name, $passwd, $uid, $gid) = getpwnam($username);
  error("getpwnam($username): $!") unless defined($name);
d1670 6
@


1.52
log
@reordered and renamed a couple of things; filled in nyi stubs
@
text
@d31 5
a35 3
my($rcsid) = q$Id: toast,v 1.51 2002/12/29 01:36:49 zaphod Exp zaphod $;
$rcsid =~ /^Id: (.+),v (\d+\.\d+)/ || error;
my($myname, $myversion, $myurl) = ($1, $2, "http://www.toastball.net/toast/");
d1270 1
a1270 1
  my($code) = qq[/* generated by $myname */
d1511 1
a1511 1
  my($mftext) = qq[# generated by $myname
d2108 1
a2108 1
sub emit(@@)
d2110 61
a2170 1
  error("emit nyi");
d2374 1
a2374 1
sub parse_emit(@@) { allowall(@@_); }
d2596 1
a2596 1
=item S<B<toast emit> I<FILE> ...>
@


1.51
log
@build now chowns when run as root; various man page updates
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.50 2002/12/28 23:38:23 zaphod Exp zaphod $;
a1167 40
sub remove(@@)
{
  my($name, $version, $build, @@urls) = @@_;
  @@urls && error;
  isarmed($name, $version, $build) &&
      error(pkgname($name, $version, $build) . " is armed");
  rmall(storepath($name, $version, $build));
}

##############################################################################

sub rename(@@)
{
  my($sname, $sversion, $sbuild, $dname, $dversion, $dbuild) = @@_;

  defined($sname) == defined($dname) || error;
  defined($sversion) == defined($dversion) || error;
  defined($sbuild) == defined($dbuild) || error;
  defined($sname) || error;
  defined($sbuild) && !defined($sversion) && error;

  my($sdir) = storepath($sname, $sversion, $sbuild);
  my($ddir) = storepath($dname, $dversion, $dbuild);

  -d($sdir) || error(pkgname($sname, $sversion, $sbuild) . " does not exist");
  -d($ddir) && error(pkgname($dname, $dversion, $dbuild) . " already exists");
  isarmed($sname, $sversion, $sbuild) &&
      error(pkgname($sname, $sversion, $sbuild) . " is armed");
      
  my($namedir) = storepath($dname);
  optmd($namedir) unless $ddir eq $namedir;
  my($versiondir) = storepath($dname, $dversion);
  optmd($versiondir) unless $ddir eq $versiondir;
  mv($sdir, $ddir);

  ($dname, $dversion, $dbuild);
}

##############################################################################

d1721 7
d1820 21
d1873 29
a2016 32
sub tryman($)
{
  my($type) = @@_;
  $type =~ /^[\w\:]+$/ || error("bad parser: $type");
  my($parser) = eval("use IO::Handle; use Pod::$type; Pod::$type->new()");
  return false unless $parser;
  local(*SCRIPT);
  selfopen(*SCRIPT);
  $parser->parse_from_filehandle(*SCRIPT);
  close(SCRIPT) || error;
  true;
}

sub fakeman()
{
  local(*SCRIPT);
  selfopen(*SCRIPT);
  my($pod);
  while(<SCRIPT>)
  {
    $pod .= $_ if $pod || /^=\w+/;
    last if /^=cut/;
  }
  close(SCRIPT) || error;
  print(depodify($pod));
}

sub man()
{
  -t(STDOUT) && tryman("Text::Termcap") || tryman("Text") || fakeman;
}

d2071 42
d2304 2
a2307 2
sub parse_demolish(@@) { rejectempty(rejecturls(parse(@@_))); }
sub parse_forget(@@) { rejectempty(rejecturls(rejectbuilds(parse(@@_)))); }
a2309 1
sub parse_meta(@@) { allowall(@@_); }
d2312 1
d2534 1
a2534 1
=item S<B<toast make> I<FILE> ...>
@


1.50
log
@command-line parsing randomness and other old bugfixes (?);
some work on toast check; added sub dropprivs
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.49 2002/09/26 23:11:29 zaphod Exp zaphod $;
d704 10
d716 1
a716 1
  return unless $> == 0 || $< == 0;
d1737 1
a1737 1
  my($code) = $?;
d1740 12
d1754 1
a1754 1
  $success || error("child returned $code");
d2283 1
a2283 1
sub parse_self(@@) { allowall(@@_); }
d2399 1
a2399 1
Add new packages to the repository by storing URLs.  Use this command
d2421 4
d2444 1
a2444 1
Reverses the effects of B<toast arm>.  This works by removing symbolic
d2450 13
d2465 5
a2469 5
Removes a build, a package, or a set of packages.  Removing a build
reverses the effects of B<toast build>.  Removing a package automatically
removes all of its builds and additionally reverses the effects of
B<toast get> and B<toast add>.  If one of the builds to be removed is
currently armed, B<toast remove> reports an error and nothing is removed.
d2479 4
d2506 6
@


1.49
log
@added rudimentary support for rpm and binary packages
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.48 2002/09/26 01:37:15 zaphod Exp zaphod $;
d129 9
a137 1
  !$_;
d448 1
d575 22
d704 17
d1672 3
d1676 2
a1677 1
  $build && error;
d1699 1
d1857 2
d1863 1
a1863 1
sub check()
d1865 64
a1928 1
  warn("nyi: check");
d1930 25
a1954 13
  # make sure everything in armdir is either:
  # 1. a well-formed arm link whose target exists;
  # 2. explicitly listed on a user-configurable whitelist
  # 3. a directory that contains at least one of the above two things
  # check armdir directory owners, groups, and modes

  # check owner group mode for everything under storedir
  # names versions builds must be directories
  # names versions builds must be well-formed
  # currently, names must have no non-version contents
  # each version must have archive, url, zero or more builds, nothing else
  # each build must have src, root, build.log or broken.log
  # all of above should take plausible intermediate states into account
d2058 2
d2252 1
a2253 1
sub parse_status(@@) { allowempty(rejecturls(parse(@@_))); }
d2256 4
d2261 2
a2263 1
sub parse_help(@@) { allowall(@@_); }
d2313 1
a2313 4
sub nocmd()
{
  help;
}
d2334 3
a2336 1
  &$doer(@@$_) foreach (&$parser(@@_));
d2344 2
a2345 1
  cmd(@@_);
d2347 1
@


1.48
log
@added rudimentary HTML parsing code to toast get
toast build can now extract based on magic numbers rather than suffixes
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.47 2002/09/24 22:29:38 zaphod Exp zaphod $;
d702 1
a702 1
sub autoextractstdin()
d704 1
d706 5
a710 1
  read(STDIN, $buf, magicbufsize) || error("read stdin: $!");
d712 4
a715 2
  my($pid) = open(STDIN, "-|");
  defined($pid) || error("fork: $!");
d717 1
a717 1
  if($pid)
d719 3
a721 2
    &extractstdin(magicstring($buf));
    error;
d723 29
a751 1
  else
d753 4
a756 3
    print($buf);
    print($buf) while read(STDIN, ($buf = ""), 16384);
    exit(0);
d758 8
d777 2
d1170 1
a1170 1
sub effsrcdir($)
d1176 1
a1176 1
  return $ok ? &effsrcdir($subdir) : $dir;
d1528 12
d1543 24
d1568 5
a1572 3
  my(@@stddirs) = qw[bin etc include lib man sbin share src];
  push(@@stddirs, path("man", "man$_")) foreach (1..9);
  my(@@stdlinks) = qw[usr local];
d1574 17
a1590 3
  md($rootdir);
  md(path($rootdir, $_)) foreach sort @@stddirs;
  ln(".", path($rootdir, $_)) foreach @@stdlinks;
d1597 1
a1597 2
  my(@@stdlinks) = qw[usr local];
  rm(path($rootdir, $_)) foreach @@stdlinks;
a1612 1
  my($effsrcdir) = effsrcdir($srcdir);
d1614 3
a1616 23
  my(%initenv) = inithelpers($srcdir, $rootdir, $helperdir);
  if(%initenv)
  {
    defined($ENV{$_}) && $ENV{$_} eq $initenv{$_} ||
        announce("export", "$_=$initenv{$_}") foreach keys(%initenv);
    local(%ENV) = %initenv;
    configure($effsrcdir, armdir);
    make($effsrcdir);
    mkrootdir($rootdir);
    armhelpers($helperdir);
    install($effsrcdir);
    !defined($ENV{$_}) ? announce("unset", $_) :
        ($ENV{$_} eq $initenv{$_} || announce("export", "$_=$ENV{$_}"))
        foreach keys(%initenv);
  }
  else
  {
    configure($effsrcdir, armdir);
    make($effsrcdir);
    mkrootdir($rootdir);
    configure($effsrcdir, $rootdir);
    install($effsrcdir);
  }
d1727 4
@


1.47
log
@implemented autorename in toast get; fixed bug in sub parse
@
text
@d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.46 2002/09/24 20:32:50 zaphod Exp zaphod $;
d87 1
d89 4
a92 3
sub basename($) { local($_) = @@_; s|.*/||g; $_; }
sub stripext($) { local($_) = @@_; s/\.[a-z]\w*$//i; s/\.tar//i; $_; }
sub stripbase($) { stripext(basename($_[0])); }
d635 1
a635 1
  local($_) = stripbase(collapse(@@sources));
d673 94
a794 19
sub extractfile($$)
{
  my($infile, $outdir) = @@_;

  local($_) = $infile;
  s/\.tgz$/.tar.gz/i;
  my(@@filter) = s/\.gz$//i ? ("gzip", "-cd", $infile) :
      s/\.bz2$//i ? ("bzip2", "-cd", $infile) : ();
  my($inarg) = @@filter ? "-" : $infile;
  my($pipe, @@prog) =
      /\.(zip|bin)$/i ? (0, "unzip", "-qo", $inarg) :
      /\.patch$/i ? (1, "patch", "-p0") :
      ("", "tar", "xf", $inarg);
  $pipe eq 0 && @@filter && error("intermediate file not supported: $infile");
  @@filter = ("cat", $infile) if $pipe eq 1 && !@@filter;

  cdrun($outdir, @@filter ? mkcmdline(@@filter)." | ".mkcmdline(@@prog) : @@prog);
}

d964 43
d1013 1
a1013 1
  my($tempdir) = addtmp(path($verdir, archivedir));
d1016 1
a1016 1
  for(absls($tempdir))
d1054 1
a1054 10
  geturl($_, path($tempdir, basename($_))) foreach @@urls;

  if($autorename)
  {
    ($name, $version) = autorename($name, $version);
    $verdir = storepath($name, $version);
    $realdir = path($verdir, archivedir);
    $tempdir = addtmp($realdir);
  }

d1056 1
d1434 2
a1435 1
        $prog = stripbase($_) if !$prog && grep { /\bmain\b/ } readfile($_);
@


1.46
log
@added toast rename; removed latestversion reference from sub parse
@
text
@d2 1
d31 1
a31 1
my($rcsid) = q$Id: toast,v 1.45 2002/09/24 02:25:18 zaphod Exp zaphod $;
d86 2
d664 54
d887 29
d919 2
d922 1
d935 9
a990 24
sub mkcmdline(@@)
{
  join(' ', map { my($a) = $_; $a =~ s/[^\w_\-\.\/]/\\$&/g; $a; } @@_);
}

sub extractfile($$)
{
  my($infile, $outdir) = @@_;

  local($_) = $infile;
  s/\.tgz$/.tar.gz/i;
  my(@@filter) = s/\.gz$//i ? ("gzip", "-cd", $infile) :
      s/\.bz2$//i ? ("bzip2", "-cd", $infile) : ();
  my($inarg) = @@filter ? "-" : $infile;
  my($pipe, @@prog) =
      /\.(zip|bin)$/i ? (0, "unzip", "-qo", $inarg) :
      /\.patch$/i ? (1, "patch", "-p0") :
      ("", "tar", "xf", $inarg);
  $pipe eq 0 && @@filter && error("intermediate file not supported: $infile");
  @@filter = ("cat", $infile) if $pipe eq 1 && !@@filter;

  cdrun($outdir, @@filter ? mkcmdline(@@filter)." | ".mkcmdline(@@prog) : @@prog);
}

d1793 1
a1793 1
        $exists = false;
a1934 5

sub emptytoundef(@@)
{
  map { defined($_) && $_ eq "" ? undef : $_ } @@_;
}
@


1.45
log
@tweaks to prevent unknown-version-number collisions
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.44 2002/09/23 23:12:01 zaphod Exp zaphod $;
d864 29
a1724 1
        $version = latestversion($name) unless defined($version);
d1859 42
@


1.44
log
@rejiggered command-line parsing; got rid of @@-notation
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.43 2002/09/21 01:00:29 zaphod Exp zaphod $;
d624 1
a624 1
  $_ eq "" ? "unknown" : $_;
d785 1
a785 2
  defined($name) || error;
  defined($version) || error;
d789 1
d791 4
d796 26
a822 3

  optmd(storedir, $namedir);
  md($verdir);
d1345 1
@


1.43
log
@s/cwd/dir; skip make if "all" implies "install" (e.g. man-pages)
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.42 2002/09/20 23:20:06 zaphod Exp zaphod $;
d703 1
a703 1
sub latestversion($)
d705 2
a706 2
  my($name) = @@_;
  lastitem(allversions($name));
a1641 9
sub expandmetaurl($)
{
  my($url) = @@_;
  warn("expandmetaurl nyi");
  ("$url/dummy1", "$url/dummy2", "$url/dummy3");
}

##############################################################################

d1644 1
a1644 1
  my(@@parsed) = ();
a1687 12
        my($at);
        if(s/^\@@//)
        {
          if($_ eq "")
          {
            @@_ || error("expected file after \"\@@\"");
            $_ = shift;
          }
          error("multiple \"\@@\" are not allowed") if $at || /^\@@/;
          $at = 1;
        }

a1689 1
          error("expected file after \"\@@\"") if $at;
d1704 1
a1704 1
        push(@@urls, $at ? [$url, !$multi && !defined($name)] : $url);
d1714 1
d1717 1
a1717 1
    push(@@parsed, [$name, $version, $build, @@urls]);
d1720 1
a1720 39
  # finished checking command-line syntax; now start expanding meta-urls
  # and filling in guessed names and version numbers

  my(@@expanded);
  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    my(@@expandedurls, $metaurl, $span);

    for(@@urls)
    {
      if(!ref)
      {
        push(@@expandedurls, $_);
      }
      else
      {
        ($metaurl, $span) = @@$_;
        push(@@expandedurls, expandmetaurl($metaurl));
      }
    }

    if(!$span)
    {
      ($name, $version) = guessnv(@@expandedurls) unless defined($name);
      push(@@expanded, [$name, $version, $build, @@expandedurls]);
    }
    else
    {
      error if $name || $version || $build;
      for(@@expandedurls)
      {
        ($name, $version, $build) = guessnv($_);
        push(@@expanded, [$name, $version, $build, $_]);
      }
    }
  }

  @@expanded;
d1725 1
a1725 1
sub parse_add(@@)
d1727 2
a1728 10
  @@_ || error;
  my(@@parsed) = parse(@@_);

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    @@urls || error("URL required to add package ", pkgname($name, $version));
  }

  @@parsed;
d1731 1
a1731 1
sub parse_get(@@)
d1733 2
a1734 11
  @@_ || error;
  my(@@parsed) = parse(@@_);

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $build && error("unexpected build number: ",
        pkgname($name, $version, $build));
  }

  @@parsed;
d1737 1
a1737 1
sub parse_build(@@)
d1739 2
a1740 2
  my(@@parsed) = parse_get(@@_);
  @@parsed ? @@parsed : \@@parsed;
d1743 1
a1743 1
sub parse_arm(@@)
d1745 1
a1745 2
  @@_ || error;
  parse(@@_);
d1748 1
a1748 1
sub parse_status(@@)
d1750 1
a1750 3
  my(@@parsed) = parse(@@_);

  for(@@parsed)
d1753 1
a1753 1
    @@urls && error("unexpected URL: ", $urls[0]);
d1755 1
a1755 2

  @@parsed ? @@parsed : \@@parsed;
d1758 1
a1758 1
sub parse_disarm(@@)
d1760 6
a1765 2
  @@_ || error;
  parse_status(@@_);
d1768 1
a1768 1
sub parse_remove(@@)
d1770 7
a1776 2
  @@_ || error;
  parse_status(@@_);
d1779 1
a1779 1
sub parse_check(@@)
d1781 8
a1788 2
  @@_ && error;
  [];
d1791 1
a1791 4
sub parse_man(@@)
{
  parse_check(@@_);
}
d1793 10
a1802 5
sub parse_help(@@)
{
  my(@@args) = @@_;
  \@@args;
}
@


1.42
log
@fixed bug in sub openprog that prevented wget from working
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.41 2002/09/20 22:44:00 zaphod Exp zaphod $;
d260 9
d271 1
a271 1
  my($name) = @@_;
d273 1
a273 7
  local(*FILE, $_);
  open(FILE, "<", $name) || error("open $name for read: $!");
  while(<FILE>)
  {
    push(@@result, $_);
  }
  close(FILE) || error("close $name for read: $!");
d1141 2
a1142 2
  helprewrite($srcdir, $rootdir, $helperdir, $_) foreach
      ("mkdir", "rmdir", "touch", "cp", "mv", "ln", "install", "test", "[");
d1159 11
d1172 1
a1172 1
  my($cwd, $prefix) = @@_;
d1176 1
a1176 1
    return cdrun($cwd, "./$_", "--prefix=$prefix") if(-x path($cwd, $_));
d1179 1
a1179 4
  for(qw[Makefile makefile GNUmakefile])
  {
    return true if -r path($cwd, $_);
  }
d1184 1
a1184 1
    $cwd,
d1214 1
a1214 1
  writefile(path($cwd, "Makefile"), $mftext);
d1219 9
a1227 2
  my($cwd) = @@_;
  cdrun($cwd, "make");
d1232 1
a1232 1
  my($cwd) = @@_;
d1235 1
a1235 1
  cdrun($cwd, @@strace, "make", "install");
@


1.41
log
@added code to generate simple makefiles; fixed two minor bugs
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.40 2002/09/15 04:26:05 zaphod Exp zaphod $;
d311 1
a311 2
warn(*HANDLE, " [", trace(0), "]\n");
  open(HANDLE, "-|", $prog, @@args) || error("exec $prog: $!");
@


1.40
log
@flattened storedir structure by replacing vdir with a prefix
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.39 2002/09/14 01:11:13 zaphod Exp zaphod $;
d87 1
d264 1
a264 1
  local(*FILE);
d628 1
a628 1
  local($_) = stripext(basename(collapse(@@sources)));
d1160 7
a1166 1
  for("configure", "configure.gnu")
d1168 9
a1176 1
    if(-x "$cwd/$_")
d1178 27
a1204 4
      return cdrun($cwd, "./$_", "--prefix=$prefix");
    }
  }
  return false;
d1388 1
a1388 1
      error("$name version $version build $build is already armed");
@


1.39
log
@added missing "mode" syscall parameters
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.38 2002/09/13 22:01:25 zaphod Exp zaphod $;
a433 1
    "vdir" => "v",
d558 18
a575 3
sub storepath(@@) { path(storedir, @@_); }
sub addoff($) { $_[0] . offsuffix; }
sub addtmp($) { $_[0] . tmpsuffix; }
d662 1
a662 1
  @@_ ? @@_ : sort cmpab ls(storepath);
d668 1
a668 1
  @@_ ? @@_ : sort cmpab ls(storepath($name, vdir));
d675 1
a675 1
      ls(storepath($name, vdir, $version));
d689 1
a689 1
  -d(storepath($name, vdir, $version));
d695 1
a695 1
  -d(storepath($name, vdir, $version, $build));
d731 1
a731 1
  -d(storepath($name, vdir, $version, archivedir));
d739 1
a739 1
    !-f(storepath($name, vdir, $version, $build, buildlog));
d746 1
a746 1
  -f(storepath($name, vdir, $version, $build, brokenlog));
d754 1
a754 1
    my($rootdir) = storepath($name, vdir, $version, $build, rootdir);
d788 1
a788 2
  my($vdir) = path($namedir, vdir);
  my($verdir) = path($vdir, $version);
d791 1
a791 1
  optmd(storedir, $namedir, $vdir);
d808 1
a808 3
  my($namedir) = storepath($name);
  my($vdir) = path($namedir, vdir);
  my($verdir) = path($vdir, $version);
d827 3
a829 12

  for $version (defined($version) ? ($version) : allversions($name))
  {
    for $build (defined($build) ? ($build) : allbuilds($name, $version))
    {
      isarmed($name, $version, $build) &&
          error("$name version $version build $build is armed");
    }
  }

  rmall(storepath(defined($build) ? ($name, vdir, $version, $build) :
      defined($version) ? ($name, vdir, $version) : $name));
d1252 1
a1252 1
  my($verdir) = storepath($name, vdir, $version);
d1351 1
a1351 1
  my($rootdir) = storepath($name, vdir, $version, $build, rootdir);
d1368 1
a1368 1
  my($rootdir) = storepath($name, vdir, $version, $build, rootdir);
d1441 1
a1441 2
  # each name must have a vdir (but need not have a version)
  # currently, names must have no non-vdir contents
@


1.38
log
@revamped sub helplib to use dlsym();
added sub mkrootdir; tweaked sub polishrootdir
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.37 2002/09/13 20:10:19 zaphod Exp zaphod $;
d1034 1
a1034 1
    wrap mkdir(const char *pathname);
d1037 1
a1037 1
    wrap chmod(const char *pathname);
@


1.37
log
@auto-renice build subprocess; fix minor toast arm bug;
toast status optimization; major sub helplib rewrite using objcopy (broken)
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.36 2002/09/10 22:36:16 zaphod Exp zaphod $;
a951 3
  my($realprefix) = $myname . "_real_";

  my(@@wrapnames);
d960 2
a1051 1
    my($realname) = $realprefix . $name;
d1053 8
a1060 6
    push(@@wrapnames, $name) if $iswrap;
    $code .= qq[

extern $realname($proto);
] .  ($iswrap ? qq[
int __$name($proto)
d1062 1
d1071 7
a1077 1
  result = $realname($newargs);
d1091 1
a1091 1
    result = $realname($args);
d1101 6
a1106 2
] : qq[
int __$name($proto)
a1115 2
]) . qq[

d1117 2
d1121 2
d1124 1
a1124 15
  writefile(path($helperdir, "dummy.c"), "static int dummy(int x) { }\n");

  my(@@onames, @@redef) = map { "$_.o" } @@wrapnames;
  push(@@redef, "--redefine-sym", "__$_=$realprefix$_") foreach @@wrapnames;
  push(@@redef, "-K", "$realprefix$_") foreach @@wrapnames;

  my($libc, $combined, $renamed) =
      ("/usr/lib/libc.a", "combined.o", "renamed.o");

  cdrun($helperdir, "ar", "x", $libc, @@onames);
  cdrun($helperdir, "ld", "-i", @@onames, "-o", $combined);
  cdrun($helperdir, "objcopy", @@redef, $combined, $renamed);
  cdrun($helperdir, "gcc", "-shared", "rewrite.c", $renamed,
      "-o", "rewrite.so.helper");
  cdrun($helperdir, "gcc", "-shared", "dummy.c", "-o", "rewrite.so");
d1181 31
d1225 1
a1225 1
    md($rootdir);
d1236 1
a1236 1
    md($rootdir);
a1239 1
}
d1241 1
a1241 12
sub polishrootdir($)
{
  my($rootdir) = @@_;
  my($total, $count) = 0;
  dfs
  (
    $rootdir,
    sub { $count = 0; true },
    sub { $count++; $total++ },
    sub { $count || rd($_) }
  );
  $total || error("no files found in $rootdir");
a1277 1
    polishrootdir($rootdir);
@


1.36
log
@tweaked debug spew
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.35 2002/09/09 03:19:32 zaphod Exp zaphod $;
d70 10
d275 5
d310 1
d443 2
a444 1
    "tmpsuffix" => ".tmp"
d952 1
a952 23
  my(@@syscalls);
  for(split(/\n/,
q[creat(const char *pathname, int flags)
open(const char *pathname, int flags, int mode)
access(const char *pathname, int flags)
stat(const char *pathname, void *foo)
stat64(const char *pathname, void *foo)
lstat(const char *pathname, void *foo)
lstat64(const char *pathname, void *foo)
readlink(const char *pathname, char *buf, int size)
link(const char *pathname1, const char *pathname2)
symlink(const char *pathname1, const char *pathname2)
rename(const char *pathname1, const char *pathname2)
mkdir(const char *pathname)
rmdir(const char *pathname)
unlink(const char *pathname)
chmod(const char *pathname)]))
  {
    /^(\w+)\((.*)\)$/ || error;
    my($name, $proto) = ($1, $2);
    my(@@alist) = map { /\w+$/ ? $& : error } split(/, /, $proto);
    my($args) = join(", ", @@alist);
    my($newargs) = join(", ", map { /pathname/ ? "rewrite($_)" : $_ } @@alist);
d954 1
a954 1
    push(@@syscalls, qq[
d956 4
a959 3
int __$name($proto)
{
  int result;
d961 2
a962 1
  fflush(stdout);
d964 3
a966 2
  printf("%s: attempting syscall $name with rewritten arguments\n", myname);
  fflush(stdout);
d968 1
a968 1
  result = syscall(SYS_$name, $newargs);
d970 3
a972 2
  printf("%s: syscall $name returned %d\n", myname, result);
  fflush(stdout);
d974 1
a974 15
  if(result < 0)
  {
    printf("%s: retrying syscall $name with original arguments\n", myname);
    fflush(stdout);

    result = syscall(SYS_$name, $args);

    printf("%s: syscall $name returned %d\n", myname, result);
    fflush(stdout);
  }

  return result;
}

int $name($proto)
d976 1
a976 10
  return __$name($args);
}
]);
  }

  writefile(path($helperdir, "dummy.c"), "static int dummy(int x) { }\n");
  writefile(path($helperdir, "rewrite.c"),
q[#include <stdio.h>
#include <string.h>
#include <sys/syscall.h>
d978 4
a981 1
int syscall(int, ...);
a982 10
static const char *srcdir = ], cquote($srcdir), q[;
static const char *rootdir = ], cquote($rootdir), q[;
static const char *armdir = ], cquote(armdir), q[;
static const char *myname = ], cquote($myname), q[;

static int startswith(const char *s, const char *prefix)
{
  int result = strncmp(s, prefix, strlen(prefix)) == 0;
  printf("%s: startswith(%s, %s) = %d\n", myname, s, prefix, result);
  fflush(stdout);
a985 2
#define BUFSIZE 4096

d997 5
a1001 2
    printf("%s: not rewriting pathname %s\n", myname, pathname);
    fflush(stdout);
d1012 4
a1015 2
    printf("%s: rewriting pathname %s -> %s\n", myname, pathname, buffer);
    fflush(stdout);
d1021 33
a1053 3
#ifndef SYS_stat64
  #define SYS_stat64 195
#endif
d1055 2
a1056 3
#ifndef SYS_lstat64
  #define SYS_lstat64 196
#endif
d1058 3
a1060 2
], @@syscalls, q[
int __lxstat64(int version, const char *pathname, void *p)
d1062 31
a1092 1
  return lstat64(pathname, p);
d1094 2
a1095 2

int __xstat64(int version, const char *pathname, void *p)
d1097 5
a1101 2
  return stat64(pathname, p);
}
a1102 5
int chown(const char *pathname, int user, int group)
{
  fflush(stdout);
  printf("%s: suppressing chown %s\n", myname, pathname);
  fflush(stdout);
d1105 1
d1107 2
a1108 7
int lchown(const char *pathname, int user, int group)
{
  fflush(stdout);
  printf("%s: suppressing lchown %s\n", myname, pathname);
  fflush(stdout);
  return 0;
}
d1110 2
a1111 7
int fchown(int fd, int user, int group)
{
  fflush(stdout);
  printf("%s: suppressing fchown %d\n", myname, fd);
  fflush(stdout);
  return 0;
}]);
d1113 12
d1126 2
a1127 2
  cdrun($helperdir, "gcc", "-shared", "rewrite.c", "-o", "rewrite.so.helper");
  path($helperdir, "rewrite.so");
d1177 3
a1179 2
  my(@@debug) = qw(strace -f -F -o make.install.strace);
  cdrun($cwd, @@debug, "make", "install");
a1230 1
  @@urls && error;
d1250 1
d1382 1
a1384 1
  isbroken($name, $version, $build) && "broken" ||
@


1.35
log
@more diagnostics for "make install" phase of toast build
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.34 2002/09/09 02:38:34 zaphod Exp zaphod $;
d968 2
d971 1
d973 1
d978 2
d981 1
d983 1
a985 2
  fflush(stdout);

d1013 1
d1031 1
d1043 1
d1144 2
a1145 1
  cdrun($cwd, "strace", "-f", "-o", "make.install.strace", "make", "install");
@


1.34
log
@improved toast build: now detects Perl's configure.gnu
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.33 2002/09/07 00:23:14 zaphod Exp zaphod $;
d963 18
a980 2
  int result = syscall(SYS_$name, $newargs);
  return result >= 0 ? result : syscall(SYS_$name, $args);
d1061 3
d1069 3
d1077 3
d1135 1
a1135 1
  cdrun($cwd, "make", "install");
@


1.33
log
@fixed bug in sub allbuilds that affected toast arm; removed debugging output
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.32 2002/07/10 21:56:22 zaphod Exp zaphod $;
d1088 25
d1124 2
a1125 2
    cdrun($effsrcdir, "./configure", "--prefix", armdir);
    cdrun($effsrcdir, "make");
d1128 1
a1128 1
    cdrun($effsrcdir, "make", "install");
d1135 2
a1136 2
    cdrun($effsrcdir, "./configure", "--prefix", armdir);
    cdrun($effsrcdir, "make");
d1138 2
a1139 2
    cdrun($effsrcdir, "./configure", "--prefix", $rootdir);
    cdrun($effsrcdir, "make", "install");
@


1.32
log
@various tweaks and bugfixes
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.31 2002/07/09 04:19:14 zaphod Exp zaphod $;
a259 1
warn("\"@@result\"");
d643 1
a643 1
  @@_ ? @@_ : sort { $a<=>$b } grep { /^[1-9]\d*$/ }
@


1.31
log
@attempt to add sub openurl
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.30 2002/07/04 22:40:12 zaphod Exp zaphod $;
d249 15
d379 1
d698 6
d765 2
d774 2
a777 2
  $build && error;
  @@urls && error;
d786 1
a786 5
  local(*URLFILE);
  open(URLFILE, $urlfile) || error("open $urlfile for read: $!");
  @@urls = map { chomp } <URLFILE>;
  close(URLFILE) || error("close $urlfile for read: $!");

d790 2
d1136 1
d1154 1
a1154 21
  if($pid = open(CHILD, "-|")) # parent
  {
    $SIG{INT} = "IGNORE";
    local(*LOG);
    my($tmplogname) = addtmp(path($builddir, buildlog));
    open(LOG, ">", $tmplogname) || error("open $tmplogname for write: $!");
    while(<CHILD>)
    {
      print LOG $_;
      chomp;
      print("  $_\n");
    }
    my($success) = close(CHILD);
    $SIG{INT} = "DEFAULT";
    my($code) = $?;
    close(LOG) || error("close $tmplogname for write: $!");
    my($logname) = path($builddir, $success ? buildlog : brokenlog);
    mv($tmplogname, $logname);
    $success || error("child returned $code")
  }
  else # child
d1158 1
d1163 1
d1168 14
d1183 11
d1234 2
a1235 1
  @@urls && error;
d1247 2
d1640 1
a1640 1
    $build || error("unexpected build number: ",
a1643 6
  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $_ = add($_) if @@urls;
  }

a1649 7

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $_ = get($_) unless isgotten($name, $version);
  }

d1656 1
a1656 21
  my(@@parsed) = parse(@@_);

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $_ = \add(@@$_) if @@urls;
  }

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $_ = \get(@@$_) unless isgotten($name, $version);
  }

  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    $_ = \build(@@$_) unless isbuilt($name, $version);
  }

  @@parsed;
@


1.30
log
@more work on command-line parsing and @@-notation
@
text
@d3 1
a3 1
use strict;     # $^H = 0x602;
d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.29 2002/07/03 03:48:20 zaphod Exp zaphod $;
a210 106
sub cpany(*$$)
{
  local(*SOURCE) = shift;
  my($source, $dest) = @@_;

  local(*DEST);
  open(DEST, ">", $dest) || error("open $dest for write: $!");

  my($buf, $result);
  my(@@dstat) = stat(DEST);
  my($bufsize) = $dstat[11] || 4096;
  while($result = read(SOURCE, $buf, $bufsize))
  {
    (print DEST $buf) || error("write to $dest: $!");
  }
  defined($result) || error("read from $source: $!");

  close(DEST) || error("close $dest for write: $!");
  close(SOURCE) || error("close $source for read: $!");
}

sub cp($$)
{
  my($source, $dest) = @@_;
  announce("cp", $source, $dest);
  local(*SOURCE);
  open(SOURCE, "<", $source) || error("open $source for read: $!");
  cpany(*SOURCE, $source, $dest);
}

##############################################################################

sub urlunescape($)
{
  local($_) = @@_;
  s/\%([0-9a-f]{2})/chr(hex($1))/gei;
  $_;
}

sub gethttpurl($$)
{
  my($url, $destfile) = @@_;
  explain("downloading $url to $destfile");
  $url =~ m!^http://([\w\.]+)(:(\d+))?(/[\!-\~]*)?$! || error("bad url: $url");
  my($host, $port, $path) = ($1, $3 || 80, $4 || '/');
  my($ip) = gethostbyname($host) || error("gethostbyname $host: $!");
  my($uagent) = "$myname/$myversion ($^O; $myurl)";
  my($request) = "GET $path HTTP/1.0\nHost: $host\nUser-Agent: $uagent\n\n";
  local(*URL, $_);
  socket(URL, 2, 1, 0) || error("$!");
  connect(URL, pack("Sna4x8", 2, $port, $ip)) ||
      error("connect $host:$port: $!");
  unbuffer(URL);
  print URL $request || error("write to $host:$port: $!");
  $_ = <URL>;
  s/\r?\n?$//;
  m|^HTTP/[\w\.]+ 200 | || error("$url: $_");
  while(<URL>) { last if /^\r?\n?$/ }
  cpany(URL, $url, $destfile);
}

sub getfileurl($$)
{
  my($url, $destfile) = @@_;
  $url =~ m!^file://([^/]+)(/.*)$! || error("bad url: $url");
  my($host, $path) = ($1, $2);
  $host eq "localhost" || error("bad file-url hostname: $host");
  cp(urlunescape($path), $destfile);
}

sub getsshurl($$)
{
  my($url, $destfile) = @@_;
  $url =~ m!^ssh://([^/]+)(/.*)$! || error("bad url: $url");
  run("scp", urlunescape("$1:$2"), $destfile);
}

sub wget($$)
{
  my($source, $dest) = @@_;
  run("wget", "-O", $dest, $source);
}

sub geturl($$)
{
  my($url, $destfile) = @@_;
  $url =~ /^(\w+):/ || error("bad url: $url");
  my($proto) = lc($1);
  if($proto eq "http")
  {
    return gethttpurl($url, $destfile);
  }
  elsif($proto eq "file")
  {
    return getfileurl($url, $destfile);
  }
  elsif($proto eq "ssh")
  {
    return getsshurl($url, $destfile);
  }
  else
  {
    return wget($url, $destfile);
  }
}

d274 104
@


1.29
log
@fixed a command-line parsing bug and added hooks for @@-notation
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.28 2002/06/27 03:50:58 zaphod Exp zaphod $;
d577 2
a578 2
  $_;
  }
d732 2
d752 2
d1445 9
d1456 1
a1456 1
  my(@@result) = ();
d1460 1
a1460 1
    my($name, $version, $build, @@urls, $exists, $multi);
d1529 1
a1529 1
        push(@@urls, $at ? \$url : $url);
d1539 13
d1553 7
a1559 1
      for(@@urls)
d1561 2
a1562 1
        error("\@@ nyi") if ref;
d1564 1
d1566 13
a1578 1
      ($name, $version) = guessnv(@@urls) unless defined($name);
d1580 1
d1582 1
a1582 3
    push(@@result, [$name, $version, $build, @@urls]);
  }
  @@result;
@


1.28
log
@require perl 5.6.0 (?) for 3-argument open()
@
text
@d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.27 2002/06/19 01:52:25 zaphod Exp zaphod $;
d1487 12
d1501 1
d1506 1
d1509 1
a1509 1
          push(@@urls, cleanurl($_));
d1514 1
a1514 1
          push(@@urls, fileurl($_));
d1516 1
d1526 7
a1532 1
      ($name, $version) = guessnv(@@urls);
@


1.27
log
@read properties from command line; related cleanup
@
text
@d2 1
d30 1
a30 1
my($rcsid) = q$Id: toast,v 1.26 2002/06/18 03:42:17 zaphod Exp zaphod $;
@


1.26
log
@fixed error handling in sub cmd
@
text
@d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.25 2002/06/18 03:28:02 zaphod Exp zaphod $;
d391 1
a391 1
    error("eval $_: $@@");
d416 5
d451 10
a460 1
  sub prop($)
d465 3
a467 4
    $val = $propdefault{$name};
    defined($val) || error("no such property: $name");
    $val = $ENV{uc("${myname}_$name")} || loadprop($name) || $val;
    $propcurrent{$name} = $val;
d470 1
a470 1
  checkedeval("sub $_() { prop('$_') }") foreach keys(%propdefault);
d1638 9
d1662 10
a1671 8
  my($cmd, @@args) = @@_;
  return nocmd unless defined($cmd);
  my($cmdsub) = checkedeval("\\&cmd_$cmd");
  return &$cmdsub(@@args) if defined(&$cmdsub);
  my($parser) = checkedeval("\\&parse_$cmd");
  return defaultcmd(@@_) unless defined(&$parser);
  my($doer) = checkedeval("\\&$cmd");
  &$doer(@@$_) foreach (&$parser(@@args));
a1681 2

##############################################################################
@


1.25
log
@debugged property code
@
text
@d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.24 2002/06/18 03:15:03 zaphod Exp zaphod $;
d1625 13
d1641 1
a1641 1
  return help(@@_) unless defined($cmd);
d1643 1
a1643 1
  return &$cmdsub(@@args) if defined($cmdsub);
d1645 1
a1645 1
  return help(@@_) unless defined($parser);
@


1.24
log
@reworked sub cmd
@
text
@d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.23 2002/06/18 03:08:57 zaphod Exp zaphod $;
d433 2
a434 2
      /^([^\=]*)\s*\=\s*(.*)$/ ||
          error("missing \"=\" in $dotfile line $.: $_");
d437 1
a437 1
          error("unknown property name in $dotfile line $.: $name");
d453 1
a453 1
    $val = $val || $ENV{uc("${myname}_$name")} || loadprop($name);
a457 5

  sub debugprop()
  {
    print("$_ = ", prop($_), "\n") foreach sort(keys(%propdefault));
  }
@


1.23
log
@added code to read property values from environment and/or dotfile
@
text
@d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.22 2002/06/18 02:33:43 zaphod Exp zaphod $;
d1633 7
a1639 11
  my($parser) = $cmd ? checkedeval("\\&parse_$cmd") : undef;

  if(!defined($parser))
  {
    help(@@_);
  }
  else
  {
    my($doer) = checkedeval("\\&$cmd");
    &$doer(@@$_) foreach (&$parser(@@args));
  }
@


1.22
log
@removed silly PGP signature stubs
@
text
@d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.21 2002/06/17 02:05:26 zaphod Exp zaphod $;
d416 30
d448 7
a454 3
    my($propname) = @@_;
    defined($propdefault{$propname}) || error("no such property: $propname");
    $propdefault{$propname};
d458 5
@


1.21
log
@more work on manpage; made toast help less picky about heading type
@
text
@a1 10
my $pgp_header = <<'# end PGP header';
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

#!/usr/bin/perl
my $pgp_header = <<'# end PGP header';
# end PGP header

##############################################################################

d29 1
a29 1
my($rcsid) = q$Id: toast,v 1.20 2002/06/16 01:14:26 zaphod Exp zaphod $;
a1863 7

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.6 (GNU/Linux)
Comment: For info see http://www.gnupg.org

[pgp signature would go here]
-----END PGP SIGNATURE-----
@


1.20
log
@removed unneeded references to toast; improved man page and toast help
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast,v 1.19 2002/06/15 03:47:16 zaphod Exp zaphod $;
d1332 1
a1332 1
  while(<SCRIPT>) { last if /^=head1 COMMANDS$/ }
d1649 1
a1649 1
=head1 COMMANDS
d1744 1
a1744 1
=head1 ARGUMENTS
d1746 3
a1748 1
Most commands take one or more packages as arguments.
d1750 52
a1801 3
    toast add http://download.ofb.net/gale/gale-0.99egg.tar.bz2
    toast add ssh://host/foo-3.1.tgz ftp://ftp.gnu.org/gnu/bc/bc-1.06.tar.gz
    toast add less-358.tar.gz libjpeg-6a.tar.gz make-3.79.1.tar.gz
d1803 1
a1803 2
Files can be grouped into the same package by surrounding them with
square brackets.
d1805 7
a1811 3
    toast add [ linux-2.4.18.tar.gz linux-2.4.18.tar.gz.sign ]
    toast add [ popa3d-0.5.1.tar.gz popa3d-0.5.1-linux.patch ]
    toast add m4-1.4.tar.gz [ bind-8.2.5-{src,doc}.tar.gz ]
d1813 1
a1813 3
The package name and version number are automatically guessed from the
file name.  Alternately, they may be supplied explicltly before a URL
as word of the form "I<NAME>B</>I<VERSION>B<:>":
d1815 6
a1820 3
    toast add mickeymouse/4.2.5: http://example.com/mm.zip
    toast add XFree86/4.10: [ X410src-1.tgz X410src-2.tgz X410src-3.tgz ]
    toast add "GNU Make/3.99.5 pre-alpha:" make-prealpha.tar.gz
d1822 1
d1824 31
a1854 3
Each I<URL> is stored
in the package repository as a separate package.
are stored in the package repository under the given
a1863 1
# EXAMPLES
@


1.19
log
@added rcsid stuff; compactified sub trace
@
text
@d39 1
a39 1
my($rcsid) = q$Id: toast2,v 123.456 etc etc$;
d847 1
d865 1
a865 1
print("toast: rewriting $cmd @@ARGV -> $cmd @@newargs\n");
d913 1
a913 1
  writefile(path($helperdir, "dummy.c"), "void toast_dummy_foo(int x) { }\n");
d924 1
d929 1
a929 1
  printf("toast: startswith(%s, %s) = %d\n", s, prefix, result);
d946 1
a946 1
    printf("toast: not rewriting pathname %s\n", pathname);
d957 1
a957 1
    printf("toast: rewriting pathname %s -> %s\n", pathname, buffer);
d1276 1
d1322 9
d1336 1
a1336 1
    if(/^=item .*toast (\w+)/)
d1353 3
a1355 2
    print("usage:  toast *COMMAND* [*ARGUMENTS*]\n\n",
        "where *COMMAND* is one of the following words:\n\n");
d1360 1
a1360 1
      print("$_: ", " " x ($maxcmdlen - length), depodify($&), "\n");
d1362 1
a1362 1
    print("\nFor command usage:  toast help *COMMAND*\n\n");
d1585 1
d1590 1
a1590 1
  @@_ && error;
d1639 1
a1639 1
B<toast> I<COMMAND> S<[ I<ARGUMENTS> ]>
d1643 5
a1647 3
B<toast> attempts to do for plain source tarballs and the like what
traditional package-management tools like B<rpm> and B<apt-get> do for
precompiled binary packages.
d1653 1
a1653 1
=item S<B<toast add> I<NAME>B</>I<VERSION> I<URL>...>
d1655 21
a1675 21
Stores files in the local package repository.  The given files are copied
into the package repository under the given software package name and
version number.  Absolute and relative pathnames are automatically
translated into file URLs.  All files are assumed to be parts of the
same package.  Both the URLs and copies of the files they refer to will
be stored in the package repository.

=item S<B<toast grab> I<URL>...>

Adds files as separate packages, guessing names and versions.  The guessed
names and version numbers are derived solely from the given filenames,
rather than the actual contents of the files.

=item S<B<toast build> I<NAME>B</>I<VERSION>>

Creates a new build of a previously added package.  This involves
compiling the package and "installing" it in a package-specific directory
tree.  Each package can have any number of independent builds.  Builds for
a given package are automatically assigned sequential numbers starting
from 1.  Builds are stored in the same package repository used to store
source files.
d1677 1
a1677 1
=item S<B<toast arm> I<NAME>B</>I<VERSION>B</>I<BUILD>>
d1679 2
a1680 2
Creates symbolic links to each file in a build.  This is the final step
before the build can actually be used.  The links are typically created
d1682 11
a1692 3
are moved out of the way if necessary, and the corresponding builds
are still considered to be armed.  A build must be in the "built" state
(as reported by B<toast status>) before it can be armed.
d1694 1
a1694 1
=item S<B<toast disarm> I<NAME>B</>I<VERSION>B</>I<BUILD>>
d1698 3
a1700 5
out of the way.

=item S<B<toast remove> I<NAME>>

=item S<B<toast remove> I<NAME>B</>I<VERSION>>
d1702 1
a1702 1
=item S<B<toast remove> I<NAME>B</>I<VERSION>B</>I<BUILD>>
d1705 1
a1705 1
reverses the effects of B<toast build>; removing a package automatically
d1707 2
a1708 6
B<toast add>.  If one of the build to be removed is currently armed,
B<toast remove> reports an error and nothing is removed.

=item S<B<toast status>>

=item S<B<toast status> I<NAME>>
d1710 1
a1710 1
=item S<B<toast status> I<NAME>B</>I<VERSION>>
d1712 2
a1713 1
=item S<B<toast status> I<NAME>B</>I<VERSION>B</>I<BUILD>>
d1715 2
a1716 2
Displays information about packages and builds.  Each build can be in
one of four states: "building," "built," "broken," or "armed."
d1724 1
a1724 3
=item S<B<toast help>>

=item S<B<toast help>> I<COMMAND>...
d1743 28
@


1.18
log
@major reorg: hooked up new command-line parsing code
@
text
@d21 25
a68 29
sub trace($)
{
  my($i) = @@_;
  my($result, $lastfile) = ("", "");
  while(my($package, $file, $line) = caller($i++))
  {
    if($lastfile ne $file)
    {
      $result .= "; " if $result;
      $result .= "$file: ";
    }
    else
    {
      $result .= "/";
    }

    $result .= $line;
    $lastfile = $file;
  }
  $result;
}

sub error(@@)
{
  die(join('', @@_) || "assertion failed", "\n[" . trace(1) . "]\n");
}

##############################################################################

d266 1
a266 1
  my($uagent) = "toast"; warn("user-agent $uagent");
d1315 2
a1335 1
  print("\n");
@


1.17
log
@multiprotocol url support (via external programs); more parsing code
@
text
@a255 21
sub urlescapechar($) # we still use this; move it somewhere better
{
  my($char) = @@_;
  my($hex) = hex(ord($char));
  $hex = "0$hex" if length($hex) == 1;
  "\%$hex";
}

sub urlescape($) # this needs to go away; see cleanurl
{
  local($_) = @@_;
  s|[^\!-\~]|urlescapechar($&)|ge;
  $_;
}

sub isurl($) # this is going away also
{
  local($_) = @@_;
  m!^\w+://!;
}

d267 2
a268 2
  $url =~ m!^http://([\w\.]+)(:(\d+))?(/.*)?$! || error("bad url: $url");
  my($host, $port, $path) = ($1, $3 || 80, urlescape($4) || '/');
a329 6
sub cpurlorfile($$) # this is going away
{
  my($source, $dest) = @@_;
  isurl($source) ?  geturl($source, $dest) : cp($source, $dest);
}

a441 42
sub nv($$)
{
  my($name, $version) = @@_;
  "$name/$version";
}

sub nvb($$$)
{
  my($name, $version, $build) = @@_;
  "$name/$version/$build";
}

sub parsenv($)
{
  local($_) = @@_;
  m|^([^/]+)/([^/]+)$| || error("bad nv: $_");
  ($1, $2);
}

sub parsenvb($)
{
  local($_) = @@_;
  m|^([^/]+)/([^/]+)/(\d+)$| || error("bad nvb: $_");
  ($1, $2, $3);
}

sub parseoptnv($)
{
  local($_) = @@_;
  m|^([^/]+)(/([^/]+))?$| || error("bad n or nv: $_");
  ($1, $3);
}

sub parseoptnvb($)
{
  local($_) = @@_;
  m|^([^/]+)(/([^/]+)(/(\d+))?)?$| || error("bad n or nv or nvb: $_");
  ($1, $3, $5);
}

##############################################################################

a494 117
sub cleanurl($)
{
  local($_) = @@_;
  s/ /\+/g;
  s/[^\!-\~]/urlescapechar($&)/ge;
  $_;
}

sub fileurl($)
{
  local($_) = @@_;
  $_ = abspath($_) unless m|^/|;
  s/[\%]/urlescapechar($&)/ge;
  cleanurl("file://localhost$_");
}

sub pkgname($;$$)
{
  my($name, $version, $build) = @@_;
  my($result) = "$name";
  $result .= " version $version" if defined($version);
  $result .= " build $build" if defined($build);
  $result;
}

sub parse(@@)
{
  my(@@result) = ();
  while(@@_)
  {
    local($_) = shift;
    my($name, $version, $build, @@urls, $exists, $multi);

    if($_ ne "[" && m!^([^:/\.]*)(/([^:/]+)(/([1-9]\d*))?)?(:?)$!)
    {
      ($name, $version, $build, $exists) = ($1, $3, $5, !$6);
      if(!$exists)
      {
        defined($version) || error("missing version number: \"$_\"");
        defined($build) && error("unexpected build number: \"$_\"");
        @@_ || error("expected file after \"$_\"");
        $_ = shift;
      }
      elsif(defined($version) && !isversion($name, $version))
      {
        $exists = false;
        -e || error("no such file or package: \"$_\"");
      }
      else
      {
        isname($name) || error("no such package: $name");
        $version = latestversion($name) unless defined($version);
        !defined($build) || isbuild($name, $version, $build) ||
            error("no such build: ", pkgname($name, $version, $build));
      }
    }
    
    if(!$exists)
    {
      if(s/^\[//)
      {
        $multi = true unless s/\]$//;
        if($_ eq "")
        {
          ($multi && @@_) || error("expected file after \"[\"");
          $_ = shift;
        }
      }

      while($multi || !@@urls)
      {
        if(s/\]$//)
        {
          $multi = false;
          last unless $_ ne "";
        }

        if(/^\w+:/)
        {
          push(@@urls, cleanurl($_));
        }
        else
        {
          (-r && !-d) || error("unable to read file: $_");
          push(@@urls, fileurl($_));
        }

        if($multi)
        {
          @@_ || error("expected \"]\" after \"$_\"");
          $_ = shift;
        }
      }

      @@urls || error("expected at least one file between \"[\" and \"]\"");
      ($name, $version) = guessnv(@@urls);
    }

    push(@@result, [$name, $version, $build, @@urls]);
  }
  @@result;
}

sub parsegoodurl($@@)
{
  my($goodurl) = shift;
  my(@@parsed) = parse(@@_);
  for(@@parsed)
  {
    my($name, $version, $build, @@urls) = @@$_;
    error("unexpected URL: $urls[0]") if @@urls && !$goodurl;
    error("explicit URL required for package ", pkgname($name, $version));
  }
}

##############################################################################

d562 1
a562 1
sub isname($)
d564 2
a565 2
  my($name) = @@_;
  -d(storepath($name));
d568 1
a568 1
sub isversion($$)
d570 3
a572 2
  my($name, $version) = @@_;
  -d(storepath($name, vdir, $version));
d575 1
a575 1
sub isbuild($$$)
d577 1
a577 2
  my($name, $version, $build) = @@_;
  -d(storepath($name, vdir, $version, $build));
d580 3
a582 1
sub isbuilt($$$)
d584 1
a584 2
  my($name, $version, $build) = @@_;
  -f(storepath($name, vdir, $version, $build, buildlog));
d587 1
a587 1
sub isbroken($$$)
d589 2
a590 2
  my($name, $version, $build) = @@_;
  -f(storepath($name, vdir, $version, $build, brokenlog));
d593 1
a593 1
sub isarmed($$$)
d595 3
a597 20
  my($name, $version, $build) = @@_;
  my($rootdir) = storepath($name, vdir, $version, $build, rootdir);
  -d($rootdir) && !dfs
  (
    $rootdir,
    sub { true },
    sub
    {
      my($rel) = @@_;
      my($armfile) = path(armdir, $rel);
      while(-e($armfile))
      {
        my($target) = readlink($armfile);
        return false if defined($target) && $target eq $_;
        $armfile = addoff($armfile);
      }
      return true;
    },
    sub { true }
  );
d602 7
a608 1
sub pad40($)
d610 2
a611 2
  my($len) = length($_[0]);
  $len > 40 ? $_[0] : (' ' x (40 - $len)) . $_[0];
d614 1
a614 1
sub cmpab()
d616 2
a617 3
  my($na, $nb) = map { my($x) = $_; $x =~ s/\d+/pad40($&)/ge } ($a, $b);
  my($lca, $lcb) = (lc($na), lc($nb));
  $lca ne $lcb ? $lca cmp $lcb : $na ne $nb ? $na cmp $nb : $a cmp $b;
d620 3
a622 1
sub lastitem(@@)
d624 2
a625 1
  @@_ ?  $_[$#_] : error;
d630 1
a630 1
sub allnames()
d632 14
a645 1
  sort cmpab ls(storepath);
d648 3
a650 1
sub allversions($)
d652 5
a656 2
  my($name) = @@_;
  sort cmpab ls(storepath($name, vdir));
d659 1
a659 1
sub allbuilds($$)
d661 2
a662 2
  my($name, $version) = @@_;
  sort { $a<=>$b } grep { /^[1-9]\d*$/ } ls(storepath($name, vdir, $version));
d665 1
a665 1
sub latestversion($)
d667 24
a690 2
  my($name) = @@_;
  lastitem(allversions($name));
d695 1
a695 1
sub grab($)
d697 3
a699 3
  my($source) = @@_;
  add("", $source);
}
d701 4
a704 3
sub add($@@)
{
  my($nv, @@sources) = @@_;
d706 4
a709 1
  @@sources || error("nothing to add");
d711 1
a711 2
  my(@@urls);
  isurl($_) && push(@@urls, $_) || -r || error("can't read $_") foreach @@sources;
d713 5
a717 4
  my($name, $version) = $nv ? parseoptnv($nv) : guessnv(@@sources);
  my($goodname) = $nv && $name && $version;
  $name = $name || "unknown";
  $version = $version || "unknown";
d722 1
d726 7
a732 4
  optmd(storedir, $namedir, $vdir);
  md($verdir, $tempdir);
  writefile(path($verdir, urlfile), map { urlescape($_)."\n" } @@urls) if @@urls;
  cpurlorfile($_, path($tempdir, basename($_))) foreach @@sources;
d736 3
a738 1
sub remove($)
d740 2
a741 3
  my($nvb) = @@_;
  $nvb || error("nothing to remove");
  my($name, $version, $build) = parseoptnvb($nvb);
d743 1
a743 2
  isname($name) || error("not found: $name");
  for $version ($version || allversions($name))
d745 1
a745 2
    isversion($name, $version) || error("not found: $name version $version");
    for $build ($build || allbuilds($name, $version))
a746 2
      isbuild($name, $version, $build) ||
          error("not found: $name version $version build $build");
d752 2
a753 1
  rmall(storepath($version ? ($name, vdir, $version) : $name));
a757 16
sub allunbuiltnv()
{
  my(%result, $name, $version, $build);
  for $name (allnames)
  {
    for $version (allversions($name))
    {
      for $build (allbuilds($name, $version))
      {
        $result{nv($name, $version)} = 1 if isbuilt($name, $version, $build);
      }
    }
  }
  sort(keys(%result));
}

d1073 1
a1073 1
sub build($)
d1075 3
a1077 5
  my($nv) = @@_;
  my($name, $version) = parsenv($nv);

  isname($name) || error("not found: $name");
  isversion($name, $version) || error("not found: $name version $version");
d1081 1
a1081 1
  my($build) = @@allbuilds ? max(@@allbuilds) : 0;
d1163 1
a1163 1
sub arm($)
d1165 3
a1167 2
  my($nvb) = @@_;
  my($name, $version, $build) = parsenvb($nvb);
d1180 1
a1180 1
sub disarm($)
d1182 3
a1184 2
  my($nvb) = @@_;
  my($name, $version, $build) = parsenvb($nvb);
d1224 1
a1224 1
sub status($)
d1226 1
a1226 2
  my($nv) = @@_;
  my($name, $version, $build) = parseoptnv($nv);
d1228 1
a1228 1
  for $name ($name || allnames)
d1231 1
a1231 1
    for $version ($version || allversions($name))
d1234 1
a1234 1
      for $build (allbuilds($name, $version))
d1243 2
d1319 1
a1319 1
  local(*SCRIPT);
d1358 1
a1358 1
sub cmd_grab($@@)
d1360 4
a1363 2
  @@_ || error("nothing to grab");
  grab($_) foreach @@_;
d1366 1
a1366 1
sub cmd_add($@@)
d1368 4
a1371 1
  add(@@_);
d1374 1
a1374 1
sub cmd_remove($@@)
d1376 4
a1379 2
  @@_ || error("nothing to remove");
  remove($_) foreach @@_;
d1382 1
a1382 1
sub cmd_build(@@)
d1384 5
a1388 1
  build($_) foreach @@_ ? @@_ : allunbuiltnv;
d1391 3
a1393 1
sub cmd_arm($@@)
d1395 74
a1468 2
  @@_ || error("nothing to arm");
  arm($_) foreach @@_;
d1471 3
a1473 1
sub cmd_disarm($@@)
d1475 10
a1484 2
  @@_ || error("nothing to disarm");
  disarm($_) foreach @@_;
d1487 1
a1487 1
sub cmd_status(@@)
d1489 17
a1505 1
  status($_) foreach @@_ ? @@_ : allnames;
d1508 1
a1508 1
sub cmd_check(@@)
d1510 9
a1518 2
  @@_ && error("check: unexpected arguments: " . join(' ', @@_));
  check;
d1521 1
a1521 1
sub cmd_help(@@)
d1523 22
a1544 1
  help(@@_);
d1547 1
a1547 1
sub cmd_man(@@)
d1549 1
a1549 3
  @@_ && error("man: unexpected arguments: " . join(' ', @@_));
  man;
}
d1551 1
a1551 6
sub cmd_parse(@@)
{
  print("\ninput:\n\n");
  print("$_\n") foreach @@_;
  print("\noutput:\n\n");
  for(parse(@@_))
d1554 1
a1554 6
    print(defined($name) ? "name: $name\n" : "no name\n");
    print(defined($version) ? "version: $version\n" : "no version\n");
    print(defined($build) ? "build: $build\n" : "no build\n");
    print(@@urls ? "urls:\n" : "no urls\n");
    print("  $_\n") foreach @@urls;
    print("\n");
d1556 30
d1590 1
a1590 1
BEGIN
d1592 11
a1602 18
  my(@@cmdlist) =
      qw(grab add remove build arm disarm status check help man parse);
  my(%cmdsub);
  $cmdsub{$_} = checkedeval("\\&cmd_$_") foreach @@cmdlist;

  sub cmd(@@)
  {
    my($cmd, @@args) = @@_;
    
    if($cmd && $cmdsub{$cmd})
    {
      my($subname) = $cmdsub{$cmd};
      &$subname(@@args);
    }
    else
    {
      cmd_help(@@_);
    }
@


1.16
log
@crossed off TODO items: cpany block size, abspath implementation
@
text
@d256 1
a256 1
sub urlescapechar($)
d271 14
a284 1
sub geturl($$)
d286 3
a288 3
  my($source, $dest) = @@_;
  explain("downloading $source to $dest");
  $source =~ m!^http://([\w\.]+)(:(\d+))?(/.*)?$! || error("bad url: $source");
d293 3
a295 3
  local(*SOURCE, $_);
  socket(SOURCE, 2, 1, 0) || error("$!");
  connect(SOURCE, pack("Sna4x8", 2, $port, $ip)) ||
d297 3
a299 3
  unbuffer(SOURCE);
  print SOURCE $request || error("write to $host:$port: $!");
  $_ = <SOURCE>;
d301 3
a303 3
  m|^HTTP/[\w\.]+ 200 | || error("$source: $_");
  while(<SOURCE>) { last if /^\r?\n?$/ }
  cpany(SOURCE, $source, $dest);
d306 23
a328 1
sub isurl($)
d330 19
a348 2
  local($_) = @@_;
  m!^http://!;
d351 1
a351 1
sub cpurlorfile($$)
d397 7
d580 9
d610 1
a610 1
        -e || error("no such file or package: $_");
d617 1
a617 1
            error("build not found: $name version $version build $build");
d665 12
@


1.15
log
@added new parsing routine + "toast parse" test driver
@
text
@d95 2
a96 2
  s|//+|/|g && warn;
  s|/$|| && warn;
d102 1
a102 1
  path(grep { defined($_) } @@_);
d233 3
a235 1
  while($result = read(SOURCE, $buf, 4096))
d452 53
a510 6
}

sub abspath($)
{
  warn("TODO: abspath");
  path($ENV{PWD}, $_[0]);
@


1.14
log
@attempted to improve sort order for names and versions
@
text
@d262 1
a262 1
sub urlescape($)
d450 102
d594 8
a601 1
sub sanitize($) { local($_) = @@_; s/^[\W_]+//; s/[\W_]+$//; $_; }
d613 1
d688 5
d712 6
d1448 17
d1469 2
a1470 1
  my(@@cmdlist) = qw(grab add remove build arm disarm status check help man);
@


1.13
log
@added PGP signature stubs
@
text
@d565 15
d582 1
a582 1
  sort { $a cmp $b } ls(storepath);
d588 1
a588 1
  sort { $a cmp $b } ls(storepath($name, vdir));
d594 1
a594 1
  sort { $a <=> $b } grep { /^\d+$/ } ls(storepath($name, vdir, $version));
@


1.12
log
@fixed problems with sub helplib
@
text
@d2 9
d1348 1
d1480 6
@


1.11
log
@extensive work on toast build
@
text
@a791 3
#ifndef SYS_$name
  #define SYS_$name __NR_$name
#endif
d795 2
a796 1
  return syscall(SYS_$name, $newargs);
d820 3
a822 1
  return strncmp(s, prefix, strlen(prefix)) == 0;
d835 1
a835 1
  if(!pathname || pathname[0] != '/' || startswith(srcdir, pathname) ||
d844 1
a844 1
        startswith(armdir, pathname) ? pathname + strlen(armdir) : pathname;
d855 2
a856 2
#ifndef __NR_stat64
  #define __NR_stat64 195
d859 2
a860 2
#ifndef __NR_lstat64
  #define __NR_lstat64 196
@


1.10
log
@tweaks: man page, toast man/toast help, use strict/use warnings
@
text
@d22 1
a22 1
    print "@@_\n" if $verbose;
d296 12
a307 1
sub writefile($@@)
d309 1
a309 1
  my($realname, @@contents) = @@_;
d316 1
d320 12
d379 1
d701 194
a894 1
sub buildin($)
d896 26
a921 3
  my($builddir) = @@_;
  my($srcdir) = path($builddir, srcdir);
  my($rootdir) = path($builddir, rootdir);
d924 23
a946 71
  # Strategies:
  # 1. pass in paths as command-line arguments
  #
  #   a. ./configure --prefix $rootdir; make; make install
  #
  #   -> PRO: expected, supported, well-understood
  #   -> CON: autoconf required; other pkgs may try to use $rootdir directly
  #
  #   b. ./configure --prefix $armdir; make;
  #      ./configure --prefix $rootdir; make install
  #
  #   -> PRO: other pkgs are less likely to try to use $rootdir directly
  #   -> CON: may be failure-prone; make install may become confused
  #
  # 2. rewrite Makefile
  #
  #   a. ./configure --prefix $armdir; make; rewrite Makefile; make install
  #
  #   -> PRO: autoconf not required; potential problems may be detectable
  #   -> CON: may be difficult to generalize; likely to be failure-prone
  #
  # 3. play games with PATH
  #
  #   a. ./configure --prefix=$armdir; make;
  #      PATH=$wrapperdir:$PATH; make install
  #
  #   -> PRO: relatively simple; complex negative side-effects unlikely
  #   -> CON: almost certainly ineffective against GNU autoconf
  #
  #   b. PATH=$wrapperdir:$PATH;
  #      ./configure --prefix=$armdir; make; make install
  #
  #   -> PRO: may be able to fool GNU autoconf into using wrappers
  #   -> CON: still failure-prone; fails if Makefile hard-codes paths
  #
  # 4. play games with LD_PRELOAD
  #
  #   a. ./configure --prefix $armdir; make;
  #      LD_PRELOAD=rewrite.so; make install
  #
  #   -> PRO: should work with just about any package
  #   -> CON: OS and libc specific; may fail if tools are statically linked
  #
  # 5. chroot
  #
  #   a. chroot $chrootdir; ./configure --prefix $armdir; make; make install
  #
  #   -> PRO: somewhat portable; should work with almost any package
  #   -> CON: requires root; populating $chrootdir may be tricky/non-portable
  #
  # 6. combined approaches
  #
  #   a. ./configure --prefix $armdir; make;
  #      rewrite Makefile; PATH=$wrapperdir:$PATH; LD_PRELOAD=rewrite.so;
  #      make install
  #
  #   -> PRO: more likely to work on a variety of packages and platforms
  #   -> CON: multiples changes of niggling failures and bad interactions

#  # 1a
#  md($rootdir);
#  cdrun($effsrcdir, "./configure", "--prefix", $rootdir);
#  cdrun($effsrcdir, "make");
#  cdrun($effsrcdir, "make", "install");

  # 1b
  cdrun($effsrcdir, "./configure", "--prefix", armdir);
  cdrun($effsrcdir, "make");
  md($rootdir);
  cdrun($effsrcdir, "./configure", "--prefix", $rootdir);
  cdrun($effsrcdir, "make", "install");
d988 3
a990 1
    my(@@lines);
d993 1
a993 1
      push(@@lines, $_);
d1000 1
d1002 1
a1002 1
    writefile($logname, @@lines);
d1011 1
d1015 1
a1015 1
    buildin($builddir);
@


1.9
log
@tweaked man page and toast status output; improved toast help
@
text
@d1 8
a8 2
#!/usr/bin/perl -w
use strict;
d969 5
a973 2
  s/[A-Z]\<//g;
  s/\>//g;
d977 1
a977 1
sub manparser($)
d980 8
a987 1
  checkedeval("use IO::Handle; use Pod::$type; Pod::$type->new()");
d990 1
a990 1
sub man()
d994 6
a999 2
  my($parser) = manparser(-t(STDIN) ? "Text::Termcap" : "Text");
  $parser->parse_from_filehandle(*SCRIPT);
d1001 6
d1009 1
a1009 1
sub help()
d1013 1
a1013 1
  my($on, $cmd, @@cmds, %text);
d1017 1
a1017 1
    last if /^=(head1|cut)/;
d1020 2
a1021 1
      push(@@cmds, $cmd) unless $text{$cmd = $1};
d1025 1
a1025 1
      $text{$cmd} .= $_ if $cmd;
d1030 15
a1044 7
  print("\nusage:  toast <command> [<arguments>]\n\n",
      "  where <command> is one of the following words:\n\n");
  my($maxcmdlen) = max(map { length } @@cmds);
  for(@@cmds)
  {
    $text{$_} =~ /\w[^\.]+\./;
    print("$_: ", " " x ($maxcmdlen - length), depodify($&), "\n");
a1045 1
  print("\n\"toast help <command>\" summarizes usage of <command>.\n\n");
d1097 1
a1097 2
  help;
  @@_ && error("help: unexpected arguments: " . join(' ', @@_));
d1151 1
a1151 1
B<toast> I<command> S<[ I<command-arguments> ]>
d1163 1
a1163 1
=item S<B<toast add> I<name>B</>I<version> I<URL>...>
d1178 1
a1178 1
=item S<B<toast build> I<name>B</>I<version>>
d1187 1
a1187 1
=item S<B<toast arm> I<name>B</>I<version>B</>I<build>>
d1196 1
a1196 1
=item S<B<toast disarm> I<name>B</>I<version>B</>I<build>>
d1202 1
a1202 1
=item S<B<toast remove> I<name>>
d1204 1
a1204 1
=item S<B<toast remove> I<name>B</>I<version>>
d1206 1
a1206 1
=item S<B<toast remove> I<name>B</>I<version>B</>I<build>>
d1216 1
a1216 1
=item S<B<toast status> I<name>>
d1218 1
a1218 1
=item S<B<toast status> I<name>B</>I<version>>
d1220 1
a1220 1
=item S<B<toast status> I<name>B</>I<version>B</>I<build>>
d1233 8
a1240 1
Summarizes usage information from the B<toast> man page.
d1244 6
a1249 1
Displays the complete B<toast> man page.
@


1.8
log
@first substantial draft of man page
@
text
@d908 1
a908 1
  "unfinished";
d953 15
d976 2
d979 6
a984 1
  my($package, $file) = caller(0);
d986 26
a1011 3
  open(SCRIPT, "<", $file) || error("open $file for read: $!");
  $parser->parse_from_filehandle(*SCRIPT);
  close(SCRIPT) || error("close $file for read: $!");
d1061 6
a1080 6
  sub cmd_help(@@)
  {
    print("valid commands: ", join(' ', @@cmdlist), "\n");
    @@_ && error("unexpected arguments: ", join(' ', @@_));
  }

d1132 6
a1137 5
Stores the given files in the local package repository under the given
package name and version number.  Absolute and relative pathnames are
automatically translated into file URLs.  All files are assumed to be
parts of the same software package.  Both the URLs and copies of the
files they refer to will be stored in the package repository.
d1141 3
a1143 4
Guesses package names and version numbers for each URL or pathname
and adds each one as a separate package.  Names and version numbers
are derived solely from the given filenames, rather than the actual
contents of the files.
d1147 6
a1152 5
Compiles a new build of a package previously added using B<toast add> or
B<toast grab>.  Each package can have any number of independent builds.
Builds for a given package are automatically assigned sequential numbers
starting from 1.  Builds are stored in the same package repository used
to store source files.
d1156 6
a1161 5
Enables a build for general use by creating symbolic links to executables,
man pages, and so on.  The links are typically created under a directory
such as F</usr/local>.  Existing links to other builds are moved out of
the way if necessary, and the corresponding builds are still considered
to be armed.
d1175 5
a1179 3
Removes a build, a package, or an entire family of packages that differ
only by version number.  If one of the build to be removed is currently
armed, the command reports an error and nothing is removed.
d1189 2
a1190 2
Displays information about all packages, all packages with a given name,
a given package, or a given build of a package.
d1194 3
a1196 3
Checks the integrity of both the package repository and the forest of
symlinks created by B<toast arm>.  Reports any inconsistencies found,
but takes no other action.
d1200 1
a1200 1
Displays a brief summary of the different B<toast> commands.
@


1.7
log
@tinkered with toast build; wrote up list of strategies
@
text
@a5 18
=head1 NAME

toast - Compile and install programs from unmodified source

=head1 SYNOPSIS

hmm hmm hmm

=head1 DESCRIPTION

This is a test.

This is another test, also.

=cut

##############################################################################

d953 6
d961 1
a961 2
  checkedeval("use IO::Handle; use Pod::Text");
  my($parser) = Pod::Text->new();
d1064 115
@


1.6
log
@fixed bugs in sub effsrcdir and toast build
@
text
@d688 1
a688 1
sub make($$)
d690 3
a692 1
  my($srcdir, $rootdir) = @@_;
d694 70
a764 1
  cdrun($effsrcdir, "make");
d768 14
d828 1
a828 1
    md($srcdir, $rootdir);
d830 2
a831 1
    make($srcdir, $rootdir);
@


1.5
log
@use strict; misc edits; notes on toast check; added toast man
@
text
@d646 2
a647 2
  my(@@filter) = s/\.gz$//i ? ("gzip", "-d", $infile) :
      s/\.bz2$//i ? ("bzip2", "-d", $infile) : ();
d683 3
a685 2
  (abswhiledir { -d && !defined($subdir) && ($subdir = $_) } $dir)
      ? &effsrcdir($subdir) : $dir;
@


1.4
log
@cleaned up sub dfs; implemented toast disarm
@
text
@d2 19
d88 2
a89 2
sub true() { 1; }
sub false() { ""; }
d135 1
a135 1
  whiledir { &$sub($_ = path($dir, $_)); } $dir;
d142 1
a142 1
  whiledir { push(@@result, $_); } $dir;
d149 1
a149 1
  map { path($dir, $_); } ls($dir);
d224 1
a224 1
  symlink($source, $dest) || error("ln -s $source $dest: $!");
d290 1
a290 1
  while(<SOURCE>) { last if /^\r?\n?$/; }
d342 15
d381 1
a381 10
  for(keys(%propdefault))
  {
    eval qq
    {
      sub $_()
      {
        prop("$_");
      }
    };
  }
d621 1
a621 1
  my(%result);
d683 1
a683 1
  (abswhiledir { -d && !defined($subdir) && ($subdir = $_); } $dir)
d845 1
a845 1
  my($name, $version) = parseoptnv($nv);
d865 28
d939 7
a945 1
  check();
d950 1
d952 1
a952 1
  my(@@cmdlist) = qw(grab add remove build arm disarm status check help);
d954 1
a954 1
  $cmdsub{$_} = "cmd_$_" foreach @@cmdlist;
d978 2
d984 1
@


1.3
log
@rejiggered sub ls and friends; fixed toast arm
@
text
@d79 2
a80 2
  s|//+|/|g;
  s|/$||;
d84 5
d133 1
a133 1
sub dfs(&$;$)
d135 6
a140 19
  my($sub, $base, $preorder, $rel) = @@_;
  local($_) = my($abs) = defined($rel) ? path($base, $rel) : $base;
  if(-l || !-d)
  {
    return &$sub($_ = $rel, false);
  }
  else
  {
    return ($preorder ? &$sub($_ = $rel, true) : true) &&
        (whiledir { &dfs($sub, $base, $preorder,
            defined($rel) ? path($rel, $_) : $_); } $abs) &&
        ($preorder ? true : &$sub($_ = $rel, true));
  }
}

sub absdfs(&$)
{
  my($sub, $base) = @@_;
  dfs { $_ = $_[0] = defined($_) ? path($base, $_) : $base; &$sub(@@_); } $base;
d187 1
a187 1
  absdfs { $_[1] ? rd($_) : rm($_) } $_ foreach @@_;
d497 4
a500 5
  {
    my($rel, $isdir) = @@_;
    return true if $isdir;
    my($rootfile) = path($rootdir, $rel);
    for(my($link) = path(armdir, $rel); -e($link); $link = addoff($link))
d502 12
a513 5
      my($target) = readlink($link);
      return false if $target eq $rootfile;
    }
    return true;
  } $rootdir;
d734 22
a764 1
warn($rootdir);
d766 6
a771 15
  {
    my($rel, $isdir) = @@_;
    my($source) = defined($rel) ? path($rootdir, $rel) : $rootdir;
    my($target) = defined($rel) ? path(armdir, $rel) : armdir;
    if($isdir)
    {
      optmd($target);
    }
    else
    {
      displace($target);
      ln($source, $target);
    }
    true;
  } $rootdir, true;
d779 25
a803 1
  error("disarm nyi");
@


1.2
log
@fixed problems with toast remove
@
text
@d96 18
d117 3
a119 7
  local(*DIR);
  opendir(DIR, $dir) || error("opendir $dir: $!");
  my(@@files) = readdir(DIR);
  closedir(DIR) || error("closedir $dir: $!");
  shift(@@files) eq "." || error;
  shift(@@files) eq ".." || error;
  sort(@@files);
d125 1
a125 4
  my(@@files) = ls($dir);
  $dir .= "/" unless $dir =~ /\/$/;
  $_ = "$dir$_" foreach @@files;
  @@files;
d128 1
a128 1
sub dfs(&$)
d130 2
a131 3
  my($sub, $base, $rel) = @@_;
  local($_) = defined($rel) ? path($base, $rel) : $base;

d134 1
a134 2
    $_ = $rel;
    return &$sub($rel, false);
d138 4
a141 7
    for(ls($_))
    {
      return false unless
          &dfs($sub, $base, defined($rel) ? path($rel, $_) : $_);
    }
    $_ = $rel;
    return &$sub($rel, true);
d157 1
d172 1
d209 7
d522 1
a522 1
  ls(storepath);
d528 1
a528 1
  ls(storepath($name, vdir));
d534 1
a534 3
  my(@@result);
  /^\d+$/ && push(@@result, $_) foreach ls(storepath($name, vdir, $version));
  sort {$a-$b} @@result;
d659 3
a661 2
  my(@@ls) = absls($dir);
  scalar(@@ls) == 1 && -d($ls[0]) ? &effsrcdir($ls[0]) : $dir;
d745 1
d749 2
a750 1
    my($source, $target) = (path($rootdir, $rel), path(armdir, $rel));
d758 1
a758 1
      symlink($source, $target) || error("ln -s $source $target: $!");
d760 2
a761 1
  } $rootdir;
@


1.1
log
@Initial revision
@
text
@d77 1
a77 1
  defined($_) || error("undefined path component") foreach @@_;
d142 1
a142 1
  dfs { $_ = $_[0] = path($base, $_); &$sub(@@_); } $base;
d173 1
d180 1
@
